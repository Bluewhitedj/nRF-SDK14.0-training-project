<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v14.0.0: USB Device high level library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v14.0.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<!--<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>-->
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s132","s140","s212","s332"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__app__usbd.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Device high level library<div class="ingroups"><a class="el" href="group__app__common.html">SDK common libraries</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><span class="whichnRF nRF52840">nRF52840 only:</span> Module for easy support for any USB device configuration.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__app__usbd__class__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__class__base.html">USBD Class Base module</a></td></tr>
<tr class="memdesc:group__app__usbd__class__base"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> The base for any class instance is defined in this module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__core"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__core.html">USB Device high level library core module</a></td></tr>
<tr class="memdesc:group__app__usbd__core"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Core module that manages current USB state and process device requests. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__descriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__descriptor.html">USB standard descriptors</a></td></tr>
<tr class="memdesc:group__app__usbd__descriptor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types definitions used for standard descriptors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__config.html">USB Device library configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__request"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__request.html">USB standard requests</a></td></tr>
<tr class="memdesc:group__app__usbd__request"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types definitions used for standard requests processing. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__string__desc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__string__desc.html">USBD string descriptors</a></td></tr>
<tr class="memdesc:group__app__usbd__string__desc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> USBD string descriptors management. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__types"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__types.html">USB Device high level library variable types definition</a></td></tr>
<tr class="memdesc:group__app__usbd__types"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> All types used by <a class="el" href="group__app__usbd.html">USB Device high level library</a> are defined here. This helps to avoid cross referencing into types in different files. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__audio"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__audio.html">USB AUDIO class</a></td></tr>
<tr class="memdesc:group__app__usbd__audio"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by USB Audio class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__cdc__acm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__cdc__acm.html">USB CDC ACM class</a></td></tr>
<tr class="memdesc:group__app__usbd__cdc__acm"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions and API used by CDC ACM class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__hid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__hid.html">USB HID class</a></td></tr>
<tr class="memdesc:group__app__usbd__hid"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with generic HID event data processing. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__msc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__msc.html">USB MSC class</a></td></tr>
<tr class="memdesc:group__app__usbd__msc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by the USB MSC class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration passed to <a class="el" href="group__app__usbd.html#ga5b0ac80bcb0f2440027bf9173981c69f">app_usbd_init</a>.  <a href="structapp__usbd__config__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga5b0ac80bcb0f2440027bf9173981c69f">app_usbd_init</a> (<a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB library initialization.  <a href="#ga5b0ac80bcb0f2440027bf9173981c69f">More...</a><br/></td></tr>
<tr class="separator:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3acabd753250ab7e071c0a2c166b983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab3acabd753250ab7e071c0a2c166b983">app_usbd_uninit</a> (void)</td></tr>
<tr class="memdesc:gab3acabd753250ab7e071c0a2c166b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB library un-initialization.  <a href="#gab3acabd753250ab7e071c0a2c166b983">More...</a><br/></td></tr>
<tr class="separator:gab3acabd753250ab7e071c0a2c166b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gae6b56c2e6aa8074c9fa5bcf61cc608dd">app_usbd_enable</a> (void)</td></tr>
<tr class="memdesc:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable USBD.  <a href="#gae6b56c2e6aa8074c9fa5bcf61cc608dd">More...</a><br/></td></tr>
<tr class="separator:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadc4e96cec2f00e65f8a6718735d0d20a">app_usbd_disable</a> (void)</td></tr>
<tr class="memdesc:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable USBD.  <a href="#gadc4e96cec2f00e65f8a6718735d0d20a">More...</a><br/></td></tr>
<tr class="separator:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13088881a90703a337690c3eb4c930ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga13088881a90703a337690c3eb4c930ee">app_usbd_start</a> (void)</td></tr>
<tr class="memdesc:ga13088881a90703a337690c3eb4c930ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request USBD to start.  <a href="#ga13088881a90703a337690c3eb4c930ee">More...</a><br/></td></tr>
<tr class="separator:ga13088881a90703a337690c3eb4c930ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a55fed9bf7cb28106c45f58257942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga36a55fed9bf7cb28106c45f58257942d">app_usbd_stop</a> (void)</td></tr>
<tr class="memdesc:ga36a55fed9bf7cb28106c45f58257942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB to work.  <a href="#ga36a55fed9bf7cb28106c45f58257942d">More...</a><br/></td></tr>
<tr class="separator:ga36a55fed9bf7cb28106c45f58257942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a0a454061f4c4a977817e1407bec8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga80a0a454061f4c4a977817e1407bec8d">app_usbd_suspend_req</a> (void)</td></tr>
<tr class="memdesc:ga80a0a454061f4c4a977817e1407bec8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request library to suspend.  <a href="#ga80a0a454061f4c4a977817e1407bec8d">More...</a><br/></td></tr>
<tr class="separator:ga80a0a454061f4c4a977817e1407bec8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac878231bc00d806eacbd7d09ef6739f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gac878231bc00d806eacbd7d09ef6739f4">app_usbd_wakeup_req</a> (void)</td></tr>
<tr class="memdesc:gac878231bc00d806eacbd7d09ef6739f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request library to wake-up.  <a href="#gac878231bc00d806eacbd7d09ef6739f4">More...</a><br/></td></tr>
<tr class="separator:gac878231bc00d806eacbd7d09ef6739f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga7d2c8cbc33d6efed1ab6b396a852b33e">app_usbd_event_execute</a> (<a class="el" href="unionapp__usbd__internal__evt__t.html">app_usbd_internal_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD event processor.  <a href="#ga7d2c8cbc33d6efed1ab6b396a852b33e">More...</a><br/></td></tr>
<tr class="separator:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadaa7b1f5326fb702c363bac1b78d3e92">app_usbd_event_queue_process</a> (void)</td></tr>
<tr class="memdesc:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that process events from the queue.  <a href="#gadaa7b1f5326fb702c363bac1b78d3e92">More...</a><br/></td></tr>
<tr class="separator:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa376e2f9825be7630d54eb14383327ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaa376e2f9825be7630d54eb14383327ce">app_usbd_class_append</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:gaa376e2f9825be7630d54eb14383327ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add class instance.  <a href="#gaa376e2f9825be7630d54eb14383327ce">More...</a><br/></td></tr>
<tr class="separator:gaa376e2f9825be7630d54eb14383327ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd105c7b99a5220f31019063477c2855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855">app_usbd_class_remove</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:gadd105c7b99a5220f31019063477c2855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove class instance.  <a href="#gadd105c7b99a5220f31019063477c2855">More...</a><br/></td></tr>
<tr class="separator:gadd105c7b99a5220f31019063477c2855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f415ae33e0acfd6a99835effa87642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad1f415ae33e0acfd6a99835effa87642">app_usbd_class_remove_all</a> (void)</td></tr>
<tr class="memdesc:gad1f415ae33e0acfd6a99835effa87642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all class instances.  <a href="#gad1f415ae33e0acfd6a99835effa87642">More...</a><br/></td></tr>
<tr class="separator:gad1f415ae33e0acfd6a99835effa87642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3044dbc144aded985b0154741982b3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga3044dbc144aded985b0154741982b3a7">app_usbd_ep_handler_set</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst, <a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="group__app__usbd__types.html#ga400c0df37a662783894f63925b25d02a">app_usbd_ep_event_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga3044dbc144aded985b0154741982b3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change endpoint handler.  <a href="#ga3044dbc144aded985b0154741982b3a7">More...</a><br/></td></tr>
<tr class="separator:ga3044dbc144aded985b0154741982b3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e0168554e973012996eed9daa89019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019">app_usbd_class_sof_register</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:ga30e0168554e973012996eed9daa89019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register class instance as the one that requires SOF events.  <a href="#ga30e0168554e973012996eed9daa89019">More...</a><br/></td></tr>
<tr class="separator:ga30e0168554e973012996eed9daa89019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0e716ee754a178d3be4446bef2d77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga2d0e716ee754a178d3be4446bef2d77a">app_usbd_class_sof_unregister</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:ga2d0e716ee754a178d3be4446bef2d77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister class instance from SOF processing instances list.  <a href="#ga2d0e716ee754a178d3be4446bef2d77a">More...</a><br/></td></tr>
<tr class="separator:ga2d0e716ee754a178d3be4446bef2d77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8729bd01008c1b17609501acd69f1337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga8729bd01008c1b17609501acd69f1337">app_usbd_class_rwu_register</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst)</td></tr>
<tr class="memdesc:ga8729bd01008c1b17609501acd69f1337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register class on remote wake-up feature.  <a href="#ga8729bd01008c1b17609501acd69f1337">More...</a><br/></td></tr>
<tr class="separator:ga8729bd01008c1b17609501acd69f1337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a8544a25d12016dd5cd67f16c8e446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad2a8544a25d12016dd5cd67f16c8e446">app_usbd_class_rwu_unregister</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst)</td></tr>
<tr class="memdesc:gad2a8544a25d12016dd5cd67f16c8e446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister class from remote wake-up feature.  <a href="#gad2a8544a25d12016dd5cd67f16c8e446">More...</a><br/></td></tr>
<tr class="separator:gad2a8544a25d12016dd5cd67f16c8e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50116d479b383778bdd3dd9fcfe67782"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga50116d479b383778bdd3dd9fcfe67782">app_usbd_class_rwu_enabled_check</a> (void)</td></tr>
<tr class="memdesc:ga50116d479b383778bdd3dd9fcfe67782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is any class with remote wakeup.  <a href="#ga50116d479b383778bdd3dd9fcfe67782">More...</a><br/></td></tr>
<tr class="separator:ga50116d479b383778bdd3dd9fcfe67782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226da76520655d0308c996ac0e8c217b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga226da76520655d0308c996ac0e8c217b">app_usbd_class_descriptor_find</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst, uint8_t desc_type, uint8_t desc_index, size_t *p_desc_len)</td></tr>
<tr class="memdesc:ga226da76520655d0308c996ac0e8c217b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function finds a given descriptor type in class descriptors payload.  <a href="#ga226da76520655d0308c996ac0e8c217b">More...</a><br/></td></tr>
<tr class="separator:ga226da76520655d0308c996ac0e8c217b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f1037dee195344195424f5b33eb96ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga6f1037dee195344195424f5b33eb96ed">app_usbd_interface_std_req_handle</a> (<a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *p_setup_ev)</td></tr>
<tr class="memdesc:ga6f1037dee195344195424f5b33eb96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard interface request handle.  <a href="#ga6f1037dee195344195424f5b33eb96ed">More...</a><br/></td></tr>
<tr class="separator:ga6f1037dee195344195424f5b33eb96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ce7e04c37838a55531035de4397d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga89ce7e04c37838a55531035de4397d7b">app_usbd_endpoint_std_req_handle</a> (<a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *p_setup_ev)</td></tr>
<tr class="memdesc:ga89ce7e04c37838a55531035de4397d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard endpoint request handle.  <a href="#ga89ce7e04c37838a55531035de4397d7b">More...</a><br/></td></tr>
<tr class="separator:ga89ce7e04c37838a55531035de4397d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2c0aa4636c97fc17bd9db7a034be63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga4c2c0aa4636c97fc17bd9db7a034be63">app_usbd_req_std_set_interface</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst, <a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *const p_setup_ev)</td></tr>
<tr class="memdesc:ga4c2c0aa4636c97fc17bd9db7a034be63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard interface set request handle.  <a href="#ga4c2c0aa4636c97fc17bd9db7a034be63">More...</a><br/></td></tr>
<tr class="separator:ga4c2c0aa4636c97fc17bd9db7a034be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Iterate through classes lists</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5d32e66acf3dcfa8984b7a04a042eeab"></a>Functions that helps to iterate through internally chained classes. </p>
</td></tr>
<tr class="memitem:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga077f1cd8183ae5dbe75d472bc21a3fa7">app_usbd_class_first_get</a> (void)</td></tr>
<tr class="memdesc:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first class instance in the list.  <a href="#ga077f1cd8183ae5dbe75d472bc21a3fa7">More...</a><br/></td></tr>
<tr class="separator:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> <br class="typebreak"/>
const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gae1148b331aedb38bd70f8fdf61b2c73e">app_usbd_class_next_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst)</td></tr>
<tr class="memdesc:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next instance in the list.  <a href="#gae1148b331aedb38bd70f8fdf61b2c73e">More...</a><br/></td></tr>
<tr class="separator:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66079874e7a71aadc2d59fcd77a3415a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga66079874e7a71aadc2d59fcd77a3415a">app_usbd_class_sof_first_get</a> (void)</td></tr>
<tr class="memdesc:ga66079874e7a71aadc2d59fcd77a3415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first instance in SOF list.  <a href="#ga66079874e7a71aadc2d59fcd77a3415a">More...</a><br/></td></tr>
<tr class="separator:ga66079874e7a71aadc2d59fcd77a3415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> <br class="typebreak"/>
const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaf6af0d27465ce259f0e9ae06c0e342f7">app_usbd_class_sof_next_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst)</td></tr>
<tr class="memdesc:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next instance in the SOF list.  <a href="#gaf6af0d27465ce259f0e9ae06c0e342f7">More...</a><br/></td></tr>
<tr class="separator:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Communicate with interfaces, endpoints and instances inside usbd library</h2></td></tr>
<tr class="memitem:gaa29e80c7208c892ebe2322448694e461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaa29e80c7208c892ebe2322448694e461">app_usbd_iface_call</a> (uint8_t iface, <a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gaa29e80c7208c892ebe2322448694e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call interface event handler.  <a href="#gaa29e80c7208c892ebe2322448694e461">More...</a><br/></td></tr>
<tr class="separator:gaa29e80c7208c892ebe2322448694e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b8dc3687095fca39b1711d53eaaa04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab6b8dc3687095fca39b1711d53eaaa04">app_usbd_ep_call</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gab6b8dc3687095fca39b1711d53eaaa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call endpoint event handler.  <a href="#gab6b8dc3687095fca39b1711d53eaaa04">More...</a><br/></td></tr>
<tr class="separator:gab6b8dc3687095fca39b1711d53eaaa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67397463798b5bbc3030195ee7fdca92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga67397463798b5bbc3030195ee7fdca92">app_usbd_all_call</a> (<a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:ga67397463798b5bbc3030195ee7fdca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function that process event by every instance in the list.  <a href="#ga67397463798b5bbc3030195ee7fdca92">More...</a><br/></td></tr>
<tr class="separator:ga67397463798b5bbc3030195ee7fdca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37d21a790ed702538b0042cc5f6cda0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab37d21a790ed702538b0042cc5f6cda0">app_usbd_all_until_served_call</a> (<a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gab37d21a790ed702538b0042cc5f6cda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call interface event handlers and stop when served.  <a href="#gab37d21a790ed702538b0042cc5f6cda0">More...</a><br/></td></tr>
<tr class="separator:gab37d21a790ed702538b0042cc5f6cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><span class="whichnRF nRF52840">nRF52840 only:</span> Module for easy support for any USB device configuration. </p>
<p>This module manages class instances that would create the USB device, manages endpoints and interfaces transactions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga67397463798b5bbc3030195ee7fdca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_all_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function that process event by every instance in the list. </p>
<p>This function ignores the result of called handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_event</td><td>Event to pass to every instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab37d21a790ed702538b0042cc5f6cda0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_all_until_served_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call interface event handlers and stop when served. </p>
<p>Call event handlers from instances as long as we get result different than <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138">NRF_ERROR_NOT_SUPPORTED</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status or <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138">NRF_ERROR_NOT_SUPPORTED</a> if none of instances in the list can support given event. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa376e2f9825be7630d54eb14383327ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add class instance. </p>
<p>This function connects given instance into internal class instance chain and into all required endpoints. The instance event handler would be connected into endpoint by default, but this can be overwritten by <a class="el" href="group__app__usbd.html#ga3044dbc144aded985b0154741982b3a7">app_usbd_ep_handler_set</a>.</p>
<p>After successful attachment <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a6861c224b4be018a8963c1c8eb4bbbab">APP_USBD_EVT_INST_APPEND</a> would be passed to class instance.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_cinst</td><td>Instance to connect. Chain data would be written into writable instance data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga226da76520655d0308c996ac0e8c217b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* app_usbd_class_descriptor_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desc_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_desc_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function finds a given descriptor type in class descriptors payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Instance of a class </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc_type</td><td>Descriptor type (<a class="el" href="group__app__usbd__request.html#ggaa03fea88741a39e8508db5687ad2e745aa91a15ab7782721836c5d4f4e7c957b2">APP_USBD_SETUP_STDREQ_GET_DESCRIPTOR</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc_index</td><td>Descriptor index (<a class="el" href="group__app__usbd__request.html#ggaa03fea88741a39e8508db5687ad2e745aa91a15ab7782721836c5d4f4e7c957b2">APP_USBD_SETUP_STDREQ_GET_DESCRIPTOR</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc_len</td><td>Descriptor length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the descriptor (NULL if not found) </dd></dl>

</div>
</div>
<a class="anchor" id="ga077f1cd8183ae5dbe75d472bc21a3fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_first_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first class instance in the list. </p>
<p>Get first instance from the list of active class instances. That instance may be used then in <a class="el" href="group__app__usbd.html#gae1148b331aedb38bd70f8fdf61b2c73e">app_usbd_class_next_get</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>First instance in the list or NULL if there are no instances available. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1148b331aedb38bd70f8fdf61b2c73e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_next_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next instance in the list. </p>
<p>Get the next instance from the list of active instances. Used to iterate through all instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>The current instance from with next one is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next instance to the given one or NULL if there is no more instances in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd105c7b99a5220f31019063477c2855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove class instance. </p>
<p>Instance is removed from instance chain. Instance and event handlers are removed also from endpoints. Endpoints used by by the class instance are left disabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance pointer to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance successfully removed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Instance not found in the instance chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1f415ae33e0acfd6a99835effa87642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_remove_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all class instances. </p>
<p>This function basically calls <a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855">app_usbd_class_remove</a> on instances chain as long as there is any element left.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855" title="Remove class instance.">app_usbd_class_remove</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Is should always return <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a>. Any error value returned would mean there is an error inside the library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50116d479b383778bdd3dd9fcfe67782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_class_rwu_enabled_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is any class with remote wakeup. </p>
<p>The function checks internal registered class with remote wakeup counter.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga8729bd01008c1b17609501acd69f1337" title="Register class on remote wake-up feature.">app_usbd_class_rwu_register</a>, <a class="el" href="group__app__usbd.html#gad2a8544a25d12016dd5cd67f16c8e446" title="Unregister class from remote wake-up feature.">app_usbd_class_rwu_unregister</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The remote wakeup functionality is required by some class instance </td></tr>
    <tr><td class="paramname">false</td><td>There is no class instance that requires wakeup functionality </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8729bd01008c1b17609501acd69f1337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_rwu_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register class on remote wake-up feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inst</td><td>Instance of the class</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance that requires remote wake-up registered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad2a8544a25d12016dd5cd67f16c8e446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_rwu_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister class from remote wake-up feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inst</td><td>Instance of the class</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance that requires remote wake-up removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66079874e7a71aadc2d59fcd77a3415a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_first_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first instance in SOF list. </p>
<p>Start iteration through the list of instances that requires SOF event processing.</p>
<dl class="section return"><dt>Returns</dt><dd>First instance in the list or NULL if the list is empty</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga077f1cd8183ae5dbe75d472bc21a3fa7" title="Get first class instance in the list.">app_usbd_class_first_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6af0d27465ce259f0e9ae06c0e342f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_next_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next instance in the SOF list. </p>
<p>Get the next instance from the list of instances requiring SOF event processing. Used to iterate through all SOF instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>The current instance from with next one is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next instance to the given one or NULL if there is no more instances in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30e0168554e973012996eed9daa89019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register class instance as the one that requires SOF events. </p>
<p>This function should be called in reaction on APP_USBD_EVT_INST_APPEND event. Connect the class instance to the list of instances that requires SOF processing. If none of the appended instances requires SOF event - it is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance that requires SOF event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga2d0e716ee754a178d3be4446bef2d77a" title="Unregister class instance from SOF processing instances list.">app_usbd_class_sof_unregister</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d0e716ee754a178d3be4446bef2d77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister class instance from SOF processing instances list. </p>
<p>Every class that calls <a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019">app_usbd_class_sof_register</a> have to call also unregistering function in reaction to <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a13857bc6299925773250eae65fe1e866">APP_USBD_EVT_INST_REMOVE</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance to be unregistered from SOF event processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing list. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Instance not found in the SOF processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019" title="Register class instance as the one that requires SOF events.">app_usbd_class_sof_register</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadc4e96cec2f00e65f8a6718735d0d20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable USBD. </p>
<p>Disabled USDB peripheral cannot be accessed but also stops requesting High Frequency clock and releases power regulator.</p>
<dl class="section note"><dt>Note</dt><dd>This function cannot be called when USB is started. Stop it first. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6b56c2e6aa8074c9fa5bcf61cc608dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable USBD. </p>
<p>USBD is enabled. Since now the high frequency clock may be requested when USB RESET would be detected. </p>

</div>
</div>
<a class="anchor" id="ga89ce7e04c37838a55531035de4397d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_endpoint_std_req_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *&#160;</td>
          <td class="paramname"><em>p_setup_ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard endpoint request handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_setup_ev</td><td>Setup event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a class="anchor" id="gab6b8dc3687095fca39b1711d53eaaa04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call endpoint event handler. </p>
<p>Call event handler for the selected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a class="anchor" id="ga3044dbc144aded985b0154741982b3a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_handler_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__app__usbd__types.html#ga400c0df37a662783894f63925b25d02a">app_usbd_ep_event_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change endpoint handler. </p>
<p>This function may be called for the endpoint only if the class instance is already properly attached by the <a class="el" href="group__app__usbd.html#gaa376e2f9825be7630d54eb14383327ce">app_usbd_class_append</a> function.</p>
<p>The endpoint event handler function can be only overwritten by the class instance that was connected into the endpoint.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Instance of a class that wish to set new event handler. It has to match currently configured instance for the selected endpoint. In other situation error would be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint address to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler function to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>New handler successfully set </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>p_cinst is not the same as currently set for the endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d2c8cbc33d6efed1ab6b396a852b33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_event_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__internal__evt__t.html">app_usbd_internal_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD event processor. </p>
<p>Function to be called on each event to be processed by the library. </p>

</div>
</div>
<a class="anchor" id="gadaa7b1f5326fb702c363bac1b78d3e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_event_queue_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that process events from the queue. </p>
<dl class="section note"><dt>Note</dt><dd>This function calls <a class="el" href="group__app__usbd.html#ga7d2c8cbc33d6efed1ab6b396a852b33e">app_usbd_event_execute</a> internally.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Event was processed </td></tr>
    <tr><td class="paramname">false</td><td>The event queue is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa29e80c7208c892ebe2322448694e461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_iface_call </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call interface event handler. </p>
<p>Call event handler for selected interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Target interface number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b0ac80bcb0f2440027bf9173981c69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB library initialization. </p>
<p>Call this function before any configuration or class attachment. USBD peripheral would be ready to accept commands, and library would be ready, but it would not be connected to the bus. Call <a class="el" href="group__app__usbd.html#gae6b56c2e6aa8074c9fa5bcf61cc608dd">app_usbd_enable</a> to enable USBD communication with the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_config</td><td>Configuration. NULL pointer might be passed here and default configuration will be applied then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f1037dee195344195424f5b33eb96ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_interface_std_req_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *&#160;</td>
          <td class="paramname"><em>p_setup_ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard interface request handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_setup_ev</td><td>Setup event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c2c0aa4636c97fc17bd9db7a034be63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_req_std_set_interface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapp__usbd__setup__evt__t.html">app_usbd_setup_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_setup_ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard interface set request handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Instance of a class </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_setup_ev</td><td>Setup event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga13088881a90703a337690c3eb4c930ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request USBD to start. </p>
<p>The function sends start request to the event queue. If the queue is enabled (<a class="el" href="group__app__usbd__config.html#gad0b3082ff1a4048a6c914cc08cce1a61">APP_USBD_EVENT_QUEUE_ENABLE</a>) it would be processed when the queue is processed. If queue is disabled it would be processed immediately inside this function. It means that if queue is disabled this function cannot be called from interrupt with priority higher than USB interrupt.</p>
<p>When start is processed it would:</p>
<ol type="1">
<li>Start library.</li>
<li>Enable interrupts.</li>
<li>Enable USB pull-ups.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>In some specific circumstances the library can be left not started and this function would silently exit. This may happen if some glitches appears on USB power line or if the plug was disconnected before whole starting process finishes. User would get the event from POWER peripheral then. Also no <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event would be generated to the classes and user event handler. For the safe code it is recommended to wait for <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event if anything has to be initialized after USB driver is started (just before enabling the interrupts). If library is properly started the <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event passed to the user handler from this function body. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36a55fed9bf7cb28106c45f58257942d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop USB to work. </p>
<p>The function sends stop request to the event queue. If the queue is enabled (<a class="el" href="group__app__usbd__config.html#gad0b3082ff1a4048a6c914cc08cce1a61">APP_USBD_EVENT_QUEUE_ENABLE</a>) it would be processed when the queue is processed. If queue is disabled it would be processed immediately inside this function. It means that if queue is disabled this function cannot be called from interrupt with priority higher than USB interrupt.</p>
<p>When the event is processed interrupts and USB pull-ups are disabled. The peripheral itself is left enabled so it can be programmed, but a HOST sees it as a peripheral disconnection.</p>
<dl class="section note"><dt>Note</dt><dd>If the library is not started when this function is called it exits silently - also no <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331afbd9412ac094f05e4a23e99ce5e8ec80">APP_USBD_EVT_STOPPED</a> is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a0a454061f4c4a977817e1407bec8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_suspend_req </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request library to suspend. </p>
<p>This function send suspend request to the event queue.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called after <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331aa999a8dda6bb54847f07e1aafe7e5416">APP_USBD_EVT_DRV_SUSPEND</a> os received. Internal suspend request processing would give no effect if the bus is not in suspend state. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3acabd753250ab7e071c0a2c166b983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB library un-initialization. </p>
<dl class="section note"><dt>Note</dt><dd>Currently not supported </dd></dl>

</div>
</div>
<a class="anchor" id="gac878231bc00d806eacbd7d09ef6739f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_wakeup_req </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request library to wake-up. </p>
<p>This function send wakeup request to the event queue.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function does not mean that peripheral is active - the wakeup request is sent into message queue and needs to be processed.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Wakeup generation has been started. </td></tr>
    <tr><td class="paramname">false</td><td>No wakeup would be generated becouse it is disabled by the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Thu Aug 3 2017" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
