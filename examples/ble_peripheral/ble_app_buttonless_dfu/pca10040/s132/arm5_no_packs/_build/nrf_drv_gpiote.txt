; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_drv_gpiote.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_gpiote.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_drv_gpiote.crf ..\..\..\..\..\..\components\drivers_nrf\gpiote\nrf_drv_gpiote.c]
                          THUMB

                          AREA ||i.GPIOTE_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIOTE_IRQHandler PROC
;;;645    
;;;646    void GPIOTE_IRQHandler(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;647    {
000004  b089              SUB      sp,sp,#0x24
;;;648        uint32_t status            = 0;
000006  f04f0800          MOV      r8,#0
;;;649        uint32_t input[GPIO_COUNT] = {0};
00000a  2000              MOVS     r0,#0
00000c  9008              STR      r0,[sp,#0x20]
;;;650    
;;;651        /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
;;;652        uint32_t            i;
;;;653        nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
00000e  f44f7080          MOV      r0,#0x100
000012  9007              STR      r0,[sp,#0x1c]
;;;654        uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
000014  2601              MOVS     r6,#1
;;;655    
;;;656        for (i = 0; i < GPIOTE_CH_NUM; i++)
000016  2400              MOVS     r4,#0
000018  e013              B        |L1.66|
                  |L1.26|
;;;657        {
;;;658            if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
00001a  9807              LDR      r0,[sp,#0x1c]
00001c  f7fffffe          BL       nrf_gpiote_event_is_set
000020  b148              CBZ      r0,|L1.54|
000022  bf00              NOP      
000024  4881              LDR      r0,|L1.556|
000026  6800              LDR      r0,[r0,#0]
000028  4030              ANDS     r0,r0,r6
00002a  b120              CBZ      r0,|L1.54|
;;;659            {
;;;660                nrf_gpiote_event_clear(event);
00002c  9807              LDR      r0,[sp,#0x1c]
00002e  f7fffffe          BL       nrf_gpiote_event_clear
;;;661                status |= mask;
000032  ea480806          ORR      r8,r8,r6
                  |L1.54|
;;;662            }
;;;663            mask <<= 1;
000036  0076              LSLS     r6,r6,#1
;;;664            /* Incrementing to next event, utilizing the fact that events are grouped together
;;;665             * in ascending order. */
;;;666            event = (nrf_gpiote_events_t)((uint32_t)event + sizeof(uint32_t));
000038  9807              LDR      r0,[sp,#0x1c]
00003a  1d00              ADDS     r0,r0,#4
00003c  b280              UXTH     r0,r0
00003e  9007              STR      r0,[sp,#0x1c]
000040  1c64              ADDS     r4,r4,#1              ;656
                  |L1.66|
000042  2c08              CMP      r4,#8                 ;656
000044  d3e9              BCC      |L1.26|
;;;667        }
;;;668    
;;;669        /* collect PORT status event, if event is set read pins state. Processing is postponed to the
;;;670         * end of interrupt. */
;;;671        if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
000046  f44f70be          MOV      r0,#0x17c
00004a  f7fffffe          BL       nrf_gpiote_event_is_set
00004e  b150              CBZ      r0,|L1.102|
;;;672        {
;;;673            nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
000050  f44f70be          MOV      r0,#0x17c
000054  f7fffffe          BL       nrf_gpiote_event_clear
;;;674            status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
000058  f0484800          ORR      r8,r8,#0x80000000
;;;675            nrf_gpio_ports_read(0, GPIO_COUNT, input);
00005c  aa08              ADD      r2,sp,#0x20
00005e  2101              MOVS     r1,#1
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       nrf_gpio_ports_read
                  |L1.102|
;;;676        }
;;;677    
;;;678        /* Process pin events. */
;;;679        if (status & NRF_GPIOTE_INT_IN_MASK)
000066  f00800ff          AND      r0,r8,#0xff
00006a  b300              CBZ      r0,|L1.174|
;;;680        {
;;;681            mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
00006c  2601              MOVS     r6,#1
;;;682    
;;;683            for (i = 0; i < GPIOTE_CH_NUM; i++)
00006e  2400              MOVS     r4,#0
000070  e01b              B        |L1.170|
                  |L1.114|
;;;684            {
;;;685                if (mask & status)
000072  ea060008          AND      r0,r6,r8
000076  b1b0              CBZ      r0,|L1.166|
;;;686                {
;;;687                    nrf_drv_gpiote_pin_t pin = nrf_gpiote_event_pin_get(i);
000078  bf00              NOP      
00007a  486d              LDR      r0,|L1.560|
00007c  f8500024          LDR      r0,[r0,r4,LSL #2]
000080  f3c02004          UBFX     r0,r0,#8,#5
000084  4607              MOV      r7,r0
;;;688                    NRF_LOG_DEBUG("Event in number: %d.", i);
;;;689                    nrf_gpiote_polarity_t        polarity = nrf_gpiote_event_polarity_get(i);
000086  bf00              NOP      
000088  4869              LDR      r0,|L1.560|
00008a  f8500024          LDR      r0,[r0,r4,LSL #2]
00008e  f3c04001          UBFX     r0,r0,#16,#2
000092  4681              MOV      r9,r0
;;;690                    nrf_drv_gpiote_evt_handler_t handler  = channel_handler_get(i);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       channel_handler_get
00009a  4605              MOV      r5,r0
;;;691                    NRF_LOG_DEBUG("Pin: %d, polarity: %d.", pin, polarity);
;;;692                    if (handler)
00009c  b115              CBZ      r5,|L1.164|
;;;693                    {
;;;694                        handler(pin, polarity);
00009e  4649              MOV      r1,r9
0000a0  4638              MOV      r0,r7
0000a2  47a8              BLX      r5
                  |L1.164|
;;;695                    }
;;;696                }
0000a4  bf00              NOP      
                  |L1.166|
;;;697                mask <<= 1;
0000a6  0076              LSLS     r6,r6,#1
0000a8  1c64              ADDS     r4,r4,#1              ;683
                  |L1.170|
0000aa  2c08              CMP      r4,#8                 ;683
0000ac  d3e1              BCC      |L1.114|
                  |L1.174|
;;;698            }
;;;699        }
;;;700    
;;;701        if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
0000ae  f0084000          AND      r0,r8,#0x80000000
0000b2  2800              CMP      r0,#0
0000b4  d07e              BEQ      |L1.436|
;;;702        {
;;;703            /* Process port event. */
;;;704            uint32_t port_idx;
;;;705            uint8_t  repeat                  = 0;
0000b6  2000              MOVS     r0,#0
0000b8  9006              STR      r0,[sp,#0x18]
;;;706            uint32_t toggle_mask[GPIO_COUNT] = {0};
0000ba  9005              STR      r0,[sp,#0x14]
;;;707            uint32_t pins_to_check[GPIO_COUNT];
;;;708    
;;;709            // Faster way of doing memset because in interrupt context.
;;;710            for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
0000bc  2500              MOVS     r5,#0
0000be  e005              B        |L1.204|
                  |L1.192|
;;;711            {
;;;712                pins_to_check[port_idx] = 0xFFFFFFFF;
0000c0  f04f30ff          MOV      r0,#0xffffffff
0000c4  a904              ADD      r1,sp,#0x10
0000c6  f8410025          STR      r0,[r1,r5,LSL #2]
0000ca  1c6d              ADDS     r5,r5,#1              ;710
                  |L1.204|
0000cc  2d00              CMP      r5,#0                 ;710
0000ce  d0f7              BEQ      |L1.192|
;;;713            }
;;;714    
;;;715            do
0000d0  bf00              NOP      
                  |L1.210|
;;;716            {
;;;717                repeat = 0;
0000d2  2000              MOVS     r0,#0
0000d4  9006              STR      r0,[sp,#0x18]
;;;718    
;;;719                for (i = 0; i < GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
0000d6  2400              MOVS     r4,#0
0000d8  e06f              B        |L1.442|
                  |L1.218|
;;;720                {
;;;721                    uint8_t              pin_and_sense = m_cb.port_handlers_pins[i];
0000da  4856              LDR      r0,|L1.564|
0000dc  5d00              LDRB     r0,[r0,r4]
0000de  9003              STR      r0,[sp,#0xc]
;;;722                    nrf_drv_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
0000e0  9803              LDR      r0,[sp,#0xc]
0000e2  f02007c0          BIC      r7,r0,#0xc0
;;;723    
;;;724                    if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
0000e6  4853              LDR      r0,|L1.564|
0000e8  5700              LDRSB    r0,[r0,r4]
0000ea  1c40              ADDS     r0,r0,#1
0000ec  2800              CMP      r0,#0
0000ee  d063              BEQ      |L1.440|
;;;725                        && nrf_bitmask_bit_is_set(pin, pins_to_check))
0000f0  a904              ADD      r1,sp,#0x10
0000f2  4638              MOV      r0,r7
0000f4  f7fffffe          BL       nrf_bitmask_bit_is_set
0000f8  2800              CMP      r0,#0
0000fa  d05d              BEQ      |L1.440|
;;;726                    {
;;;727                        nrf_gpiote_polarity_t polarity =
0000fc  9803              LDR      r0,[sp,#0xc]
0000fe  ea4f1a90          LSR      r10,r0,#6
;;;728                            (nrf_gpiote_polarity_t)((pin_and_sense &
;;;729                                                     SENSE_FIELD_MASK) >> SENSE_FIELD_POS);
;;;730                        nrf_drv_gpiote_evt_handler_t handler =
000102  4638              MOV      r0,r7
000104  f7fffffe          BL       channel_port_get
000108  4681              MOV      r9,r0
00010a  f7fffffe          BL       channel_handler_get
00010e  9002              STR      r0,[sp,#8]
;;;731                            channel_handler_get(channel_port_get(pin));
;;;732                        if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
000110  9802              LDR      r0,[sp,#8]
000112  b910              CBNZ     r0,|L1.282|
000114  f1ba0f03          CMP      r10,#3
000118  d14b              BNE      |L1.434|
                  |L1.282|
;;;733                        {
;;;734                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00011a  f1ba0f03          CMP      r10,#3
00011e  d111              BNE      |L1.324|
;;;735                            {
;;;736                                nrf_bitmask_bit_set(pin, toggle_mask);
000120  4639              MOV      r1,r7
000122  a805              ADD      r0,sp,#0x14
000124  4602              MOV      r2,r0
000126  08cb              LSRS     r3,r1,#3
000128  f0010107          AND      r1,r1,#7
00012c  f812c003          LDRB     r12,[r2,r3]
000130  f04f0e01          MOV      lr,#1
000134  fa0efe01          LSL      lr,lr,r1
000138  ea4c0c0e          ORR      r12,r12,lr
00013c  f802c003          STRB     r12,[r2,r3]
000140  bf00              NOP      
000142  bf00              NOP      
                  |L1.324|
;;;737                            }
;;;738                            nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
000144  bf00              NOP      
000146  bf00              NOP      
000148  f04f41a0          MOV      r1,#0x50000000
00014c  4608              MOV      r0,r1
00014e  f50061e0          ADD      r1,r0,#0x700
000152  f8511027          LDR      r1,[r1,r7,LSL #2]
000156  f3c14901          UBFX     r9,r1,#16,#2
00015a  bf00              NOP      
;;;739                            uint32_t             pin_state = nrf_bitmask_bit_is_set(pin, input);
00015c  a908              ADD      r1,sp,#0x20
00015e  4638              MOV      r0,r7
000160  f7fffffe          BL       nrf_bitmask_bit_is_set
000164  4683              MOV      r11,r0
;;;740                            if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
000166  f1bb0f00          CMP      r11,#0
00016a  d002              BEQ      |L1.370|
00016c  f1b90f02          CMP      r9,#2
000170  d005              BEQ      |L1.382|
                  |L1.370|
;;;741                                (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
000172  f1bb0f00          CMP      r11,#0
000176  d11b              BNE      |L1.432|
000178  f1b90f03          CMP      r9,#3
00017c  d118              BNE      |L1.432|
                  |L1.382|
;;;742                            {
;;;743                                NRF_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin,
;;;744                                              polarity);
;;;745                                if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00017e  f1ba0f03          CMP      r10,#3
000182  d10f              BNE      |L1.420|
;;;746                                {
;;;747                                    nrf_gpio_pin_sense_t next_sense =
000184  f1b90f02          CMP      r9,#2
000188  d101              BNE      |L1.398|
;;;748                                        (sense == NRF_GPIO_PIN_SENSE_HIGH) ?
;;;749                                        NRF_GPIO_PIN_SENSE_LOW :
00018a  2003              MOVS     r0,#3
00018c  e000              B        |L1.400|
                  |L1.398|
;;;750                                        NRF_GPIO_PIN_SENSE_HIGH;
00018e  2002              MOVS     r0,#2
                  |L1.400|
000190  9001              STR      r0,[sp,#4]
;;;751                                    nrf_gpio_cfg_sense_set(pin, next_sense);
000192  4638              MOV      r0,r7
000194  9901              LDR      r1,[sp,#4]
000196  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;752                                    ++repeat;
00019a  9806              LDR      r0,[sp,#0x18]
00019c  1c40              ADDS     r0,r0,#1
00019e  b2c0              UXTB     r0,r0
0001a0  9006              STR      r0,[sp,#0x18]
;;;753    
;;;754                                }
0001a2  bf00              NOP      
                  |L1.420|
;;;755                                if (handler)
0001a4  9802              LDR      r0,[sp,#8]
0001a6  b118              CBZ      r0,|L1.432|
;;;756                                {
;;;757                                    handler(pin, polarity);
0001a8  4651              MOV      r1,r10
0001aa  4638              MOV      r0,r7
0001ac  9a02              LDR      r2,[sp,#8]
0001ae  4790              BLX      r2
                  |L1.432|
;;;758                                }
;;;759                            }
;;;760                        }
0001b0  bf00              NOP      
                  |L1.434|
;;;761                    }
0001b2  e000              B        |L1.438|
                  |L1.436|
0001b4  e036              B        |L1.548|
                  |L1.438|
0001b6  bf00              NOP      
                  |L1.440|
0001b8  1c64              ADDS     r4,r4,#1              ;719
                  |L1.442|
0001ba  2c04              CMP      r4,#4                 ;719
0001bc  d38d              BCC      |L1.218|
;;;762                }
;;;763    
;;;764                if (repeat)
0001be  9806              LDR      r0,[sp,#0x18]
0001c0  b358              CBZ      r0,|L1.538|
;;;765                {
;;;766                    // When one of the pins in low-accuracy and toggle mode becomes active,
;;;767                    // it's sense mode is inverted to clear the internal SENSE signal.
;;;768                    // State of any other enabled low-accuracy input in toggle mode must be checked
;;;769                    // explicitly, because it does not trigger the interrput when SENSE signal is active.
;;;770                    // For more information about SENSE functionality, refer to Product Specification.
;;;771    
;;;772                    uint32_t new_input[GPIO_COUNT];
;;;773                    bool     input_unchanged = true;
0001c2  2701              MOVS     r7,#1
;;;774                    nrf_gpio_ports_read(0, GPIO_COUNT, new_input);
0001c4  aa03              ADD      r2,sp,#0xc
0001c6  2101              MOVS     r1,#1
0001c8  2000              MOVS     r0,#0
0001ca  f7fffffe          BL       nrf_gpio_ports_read
;;;775    
;;;776                    // Faster way of doing memcmp because in interrupt context.
;;;777                    for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
0001ce  2500              MOVS     r5,#0
0001d0  e00a              B        |L1.488|
                  |L1.466|
;;;778                    {
;;;779                        if (new_input[port_idx] != input[port_idx])
0001d2  a803              ADD      r0,sp,#0xc
0001d4  f8500025          LDR      r0,[r0,r5,LSL #2]
0001d8  a908              ADD      r1,sp,#0x20
0001da  f8511025          LDR      r1,[r1,r5,LSL #2]
0001de  4288              CMP      r0,r1
0001e0  d001              BEQ      |L1.486|
;;;780                        {
;;;781                            input_unchanged = false;
0001e2  2700              MOVS     r7,#0
;;;782                            break;
0001e4  e002              B        |L1.492|
                  |L1.486|
0001e6  1c6d              ADDS     r5,r5,#1              ;777
                  |L1.488|
0001e8  2d00              CMP      r5,#0                 ;777
0001ea  d0f2              BEQ      |L1.466|
                  |L1.492|
0001ec  bf00              NOP      
;;;783                        }
;;;784                    }
;;;785    
;;;786                    if (input_unchanged)
0001ee  b117              CBZ      r7,|L1.502|
;;;787                    {
;;;788                        // No change.
;;;789                        repeat = 0;
0001f0  2000              MOVS     r0,#0
0001f2  9006              STR      r0,[sp,#0x18]
0001f4  e010              B        |L1.536|
                  |L1.502|
;;;790                    }
;;;791                    else
;;;792                    {
;;;793                        // Faster way of doing memcpy because in interrupt context.
;;;794                        for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
0001f6  2500              MOVS     r5,#0
0001f8  e00c              B        |L1.532|
                  |L1.506|
;;;795                        {
;;;796                            input[port_idx]         = new_input[port_idx];
0001fa  a803              ADD      r0,sp,#0xc
0001fc  f8500025          LDR      r0,[r0,r5,LSL #2]
000200  a908              ADD      r1,sp,#0x20
000202  f8410025          STR      r0,[r1,r5,LSL #2]
;;;797                            pins_to_check[port_idx] = toggle_mask[port_idx];
000206  a805              ADD      r0,sp,#0x14
000208  f8500025          LDR      r0,[r0,r5,LSL #2]
00020c  a904              ADD      r1,sp,#0x10
00020e  f8410025          STR      r0,[r1,r5,LSL #2]
000212  1c6d              ADDS     r5,r5,#1              ;794
                  |L1.532|
000214  2d00              CMP      r5,#0                 ;794
000216  d0f0              BEQ      |L1.506|
                  |L1.536|
;;;798                        }
;;;799                    }
;;;800                }
000218  bf00              NOP      
                  |L1.538|
;;;801            }
;;;802            while (repeat);
00021a  9806              LDR      r0,[sp,#0x18]
00021c  2800              CMP      r0,#0
00021e  f47faf58          BNE      |L1.210|
;;;803        }
000222  bf00              NOP      
                  |L1.548|
;;;804    }
000224  b009              ADD      sp,sp,#0x24
000226  e8bd8ff0          POP      {r4-r11,pc}
;;;805    
                          ENDP

00022a  0000              DCW      0x0000
                  |L1.556|
                          DCD      0x40006304
                  |L1.560|
                          DCD      0x40006510
                  |L1.564|
                          DCD      m_cb+0x50

                          AREA ||i.channel_free||, CODE, READONLY, ALIGN=2

                  channel_free PROC
;;;213    
;;;214    static void channel_free(uint8_t channel_id)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;215    {
;;;216        m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
000004  4a05              LDR      r2,|L2.28|
000006  f8421020          STR      r1,[r2,r0,LSL #2]
;;;217        if (channel_id >= GPIOTE_CH_NUM)
00000a  2808              CMP      r0,#8
00000c  db04              BLT      |L2.24|
;;;218        {
;;;219            m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
00000e  23ff              MOVS     r3,#0xff
000010  f1a00108          SUB      r1,r0,#8
000014  3250              ADDS     r2,r2,#0x50
000016  5453              STRB     r3,[r2,r1]
                  |L2.24|
;;;220        }
;;;221    }
000018  4770              BX       lr
;;;222    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      m_cb

                          AREA ||i.channel_handler_get||, CODE, READONLY, ALIGN=2

                  channel_handler_get PROC
;;;182    
;;;183    __STATIC_INLINE nrf_drv_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
000000  4601              MOV      r1,r0
;;;184    {
;;;185        return m_cb.handlers[channel];
000002  4802              LDR      r0,|L3.12|
000004  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;186    }
000008  4770              BX       lr
;;;187    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      m_cb

                          AREA ||i.channel_port_alloc||, CODE, READONLY, ALIGN=2

                  channel_port_alloc PROC
;;;188    
;;;189    static int8_t channel_port_alloc(uint32_t pin, nrf_drv_gpiote_evt_handler_t handler, bool channel)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;190    {
000004  4603              MOV      r3,r0
000006  460c              MOV      r4,r1
;;;191        int8_t   channel_id = NO_CHANNELS;
000008  f04f39ff          MOV      r9,#0xffffffff
;;;192        uint32_t i;
;;;193    
;;;194        uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
00000c  b10a              CBZ      r2,|L4.18|
00000e  2000              MOVS     r0,#0
000010  e000              B        |L4.20|
                  |L4.18|
000012  2008              MOVS     r0,#8
                  |L4.20|
000014  4684              MOV      r12,r0
;;;195        uint32_t end_idx   =
000016  b10a              CBZ      r2,|L4.28|
;;;196            channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
000018  2008              MOVS     r0,#8
00001a  e000              B        |L4.30|
                  |L4.28|
00001c  200c              MOVS     r0,#0xc
                  |L4.30|
00001e  4680              MOV      r8,r0
;;;197    
;;;198        // critical section
;;;199    
;;;200        for (i = start_idx; i < end_idx; i++)
000020  4661              MOV      r1,r12
000022  e024              B        |L4.110|
                  |L4.36|
;;;201        {
;;;202            if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
000024  4815              LDR      r0,|L4.124|
000026  f8500021          LDR      r0,[r0,r1,LSL #2]
00002a  1c40              ADDS     r0,r0,#1
00002c  b9f0              CBNZ     r0,|L4.108|
;;;203            {
;;;204                pin_in_use_by_te_set(pin, i, handler, channel);
00002e  461d              MOV      r5,r3
000030  4608              MOV      r0,r1
000032  4627              MOV      r7,r4
000034  4616              MOV      r6,r2
000036  fa4ffb80          SXTB     r11,r0
00003a  f8dfa040          LDR      r10,|L4.124|
00003e  f10a0a30          ADD      r10,r10,#0x30
000042  f80ab005          STRB     r11,[r10,r5]
000046  f8dfa034          LDR      r10,|L4.124|
00004a  f84a7020          STR      r7,[r10,r0,LSL #2]
00004e  b94e              CBNZ     r6,|L4.100|
000050  fa4ffb85          SXTB     r11,r5
000054  f1a00a08          SUB      r10,r0,#8
000058  f8dfe020          LDR      lr,|L4.124|
00005c  f10e0e50          ADD      lr,lr,#0x50
000060  f80eb00a          STRB     r11,[lr,r10]
                  |L4.100|
000064  bf00              NOP      
;;;205                channel_id = i;
000066  fa4ff981          SXTB     r9,r1
;;;206                break;
00006a  e002              B        |L4.114|
                  |L4.108|
00006c  1c49              ADDS     r1,r1,#1              ;200
                  |L4.110|
00006e  4541              CMP      r1,r8                 ;200
000070  d3d8              BCC      |L4.36|
                  |L4.114|
000072  bf00              NOP      
;;;207            }
;;;208        }
;;;209        // critical section
;;;210        return channel_id;
000074  4648              MOV      r0,r9
;;;211    }
000076  e8bd8ff0          POP      {r4-r11,pc}
;;;212    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      m_cb

                          AREA ||i.channel_port_get||, CODE, READONLY, ALIGN=2

                  channel_port_get PROC
;;;176    
;;;177    __STATIC_INLINE int8_t channel_port_get(uint32_t pin)
000000  4601              MOV      r1,r0
;;;178    {
;;;179        return m_cb.pin_assignments[pin];
000002  4801              LDR      r0,|L5.8|
000004  5640              LDRSB    r0,[r0,r1]
;;;180    }
000006  4770              BX       lr
;;;181    
                          ENDP

                  |L5.8|
                          DCD      m_cb+0x30

                          AREA ||i.nrf_bitmask_bit_is_set||, CODE, READONLY, ALIGN=1

                  nrf_bitmask_bit_is_set PROC
;;;60      */
;;;61     __STATIC_INLINE uint32_t nrf_bitmask_bit_is_set(uint32_t bit, void const * p_mask)
000000  b530              PUSH     {r4,r5,lr}
;;;62     {
000002  4602              MOV      r2,r0
;;;63         uint8_t const * p_mask8 = (uint8_t const *)p_mask;
000004  460b              MOV      r3,r1
;;;64         uint32_t byte_idx = BITMASK_BYTE_GET(bit);
000006  08d4              LSRS     r4,r2,#3
;;;65         bit = BITMASK_RELBIT_GET(bit);
000008  f0020207          AND      r2,r2,#7
;;;66         return (1 << bit) & p_mask8[byte_idx];
00000c  2001              MOVS     r0,#1
00000e  4090              LSLS     r0,r0,r2
000010  5d1d              LDRB     r5,[r3,r4]
000012  4028              ANDS     r0,r0,r5
;;;67     }
000014  bd30              POP      {r4,r5,pc}
;;;68     
                          ENDP


                          AREA ||i.nrf_drv_gpiote_clr_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_clr_task_addr_get PROC
;;;435    #if defined(GPIOTE_FEATURE_CLR_PRESENT)
;;;436    uint32_t nrf_drv_gpiote_clr_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;437    {
000002  4604              MOV      r4,r0
;;;438        ASSERT(pin < NUMBER_OF_PINS);
;;;439        ASSERT(pin_in_use_by_te(pin));
;;;440    
;;;441        nrf_gpiote_tasks_t task = TE_CLR_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3060              ADDS     r0,r0,#0x60
00000e  b2c5              UXTB     r5,r0
;;;442        return nrf_gpiote_task_addr_get(task);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;443    }
000016  bd70              POP      {r4-r6,pc}
;;;444    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_clr_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_clr_task_trigger PROC
;;;485    #if  defined(GPIOTE_FEATURE_CLR_PRESENT)
;;;486    void nrf_drv_gpiote_clr_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;487    {
000002  4604              MOV      r4,r0
;;;488        ASSERT(pin < NUMBER_OF_PINS);
;;;489        ASSERT(pin_in_use(pin));
;;;490        ASSERT(pin_in_use_by_te(pin));
;;;491    
;;;492        nrf_gpiote_tasks_t task = TE_CLR_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3060              ADDS     r0,r0,#0x60
00000e  b2c5              UXTB     r5,r0
;;;493        nrf_gpiote_task_set(task);
000010  bf00              NOP      
000012  2001              MOVS     r0,#1
000014  4901              LDR      r1,|L8.28|
000016  5068              STR      r0,[r5,r1]
000018  bf00              NOP      
;;;494    }
00001a  bd70              POP      {r4-r6,pc}
;;;495    
                          ENDP

                  |L8.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_in_event_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_event_addr_get PROC
;;;630    
;;;631    uint32_t nrf_drv_gpiote_in_event_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;632    {
000002  4604              MOV      r4,r0
;;;633        ASSERT(pin < NUMBER_OF_PINS);
;;;634        ASSERT(pin_in_use_by_port(pin) || pin_in_use_by_te(pin));
;;;635    
;;;636        nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_PORT;
000004  f44f75be          MOV      r5,#0x17c
;;;637    
;;;638        if (pin_in_use_by_te(pin))
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       pin_in_use_by_te
00000e  b130              CBZ      r0,|L9.30|
;;;639        {
;;;640            event = TE_IDX_TO_EVENT_ADDR(channel_port_get(pin));
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       channel_port_get
000016  0080              LSLS     r0,r0,#2
000018  f5007080          ADD      r0,r0,#0x100
00001c  b285              UXTH     r5,r0
                  |L9.30|
;;;641        }
;;;642        return nrf_gpiote_event_addr_get(event);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       nrf_gpiote_event_addr_get
;;;643    }
000024  bd70              POP      {r4-r6,pc}
;;;644    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_event_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_disable PROC
;;;591    
;;;592    void nrf_drv_gpiote_in_event_disable(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
000002  4605              MOV      r5,r0
;;;594        ASSERT(pin < NUMBER_OF_PINS);
;;;595        ASSERT(pin_in_use_by_gpiote(pin));
;;;596        if (pin_in_use_by_port(pin))
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       pin_in_use_by_port
00000a  b120              CBZ      r0,|L10.22|
;;;597        {
;;;598            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
00000c  2100              MOVS     r1,#0
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_gpio_cfg_sense_set
000014  e018              B        |L10.72|
                  |L10.22|
;;;599        }
;;;600        else if (pin_in_use_by_te(pin))
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       pin_in_use_by_te
00001c  b1a0              CBZ      r0,|L10.72|
;;;601        {
;;;602            int32_t channel = (int32_t)channel_port_get(pin);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       channel_port_get
000024  4604              MOV      r4,r0
;;;603            nrf_gpiote_event_disable(channel);
000026  4620              MOV      r0,r4
000028  4908              LDR      r1,|L10.76|
00002a  f8511020          LDR      r1,[r1,r0,LSL #2]
00002e  f0210201          BIC      r2,r1,#1
000032  4906              LDR      r1,|L10.76|
000034  f8412020          STR      r2,[r1,r0,LSL #2]
000038  bf00              NOP      
;;;604            nrf_gpiote_int_disable(1 << channel);
00003a  2101              MOVS     r1,#1
00003c  fa01f004          LSL      r0,r1,r4
000040  4903              LDR      r1,|L10.80|
000042  6008              STR      r0,[r1,#0]
000044  bf00              NOP      
;;;605        }
000046  bf00              NOP      
                  |L10.72|
;;;606    }
000048  bd70              POP      {r4-r6,pc}
;;;607    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      0x40006510
                  |L10.80|
                          DCD      0x40006308

                          AREA ||i.nrf_drv_gpiote_in_event_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_enable PROC
;;;546    
;;;547    void nrf_drv_gpiote_in_event_enable(nrf_drv_gpiote_pin_t pin, bool int_enable)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;548    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;549        ASSERT(pin < NUMBER_OF_PINS);
;;;550        ASSERT(pin_in_use_by_gpiote(pin));
;;;551        if (pin_in_use_by_port(pin))
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       pin_in_use_by_port
00000e  b1e0              CBZ      r0,|L11.74|
;;;552        {
;;;553            uint8_t pin_and_sense =
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       channel_port_get
000016  3808              SUBS     r0,r0,#8
000018  4922              LDR      r1,|L11.164|
00001a  5c0f              LDRB     r7,[r1,r0]
;;;554                m_cb.port_handlers_pins[channel_port_get(pin) - GPIOTE_CH_NUM];
;;;555            nrf_gpiote_polarity_t polarity =
00001c  11bc              ASRS     r4,r7,#6
;;;556                (nrf_gpiote_polarity_t)(pin_and_sense >> SENSE_FIELD_POS);
;;;557            nrf_gpio_pin_sense_t sense;
;;;558            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00001e  2c03              CMP      r4,#3
000020  d108              BNE      |L11.52|
;;;559            {
;;;560                /* read current pin state and set for next sense to oposit */
;;;561                sense = (nrf_gpio_pin_read(pin)) ?
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       nrf_gpio_pin_read
000028  b108              CBZ      r0,|L11.46|
;;;562                        NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
00002a  2003              MOVS     r0,#3
00002c  e000              B        |L11.48|
                  |L11.46|
00002e  2002              MOVS     r0,#2
                  |L11.48|
000030  4680              MOV      r8,r0
000032  e005              B        |L11.64|
                  |L11.52|
;;;563            }
;;;564            else
;;;565            {
;;;566                sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
000034  2c01              CMP      r4,#1
000036  d101              BNE      |L11.60|
;;;567                        NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
000038  2002              MOVS     r0,#2
00003a  e000              B        |L11.62|
                  |L11.60|
00003c  2003              MOVS     r0,#3
                  |L11.62|
00003e  4680              MOV      r8,r0
                  |L11.64|
;;;568            }
;;;569            nrf_gpio_cfg_sense_set(pin, sense);
000040  4641              MOV      r1,r8
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;570        }
000048  e02a              B        |L11.160|
                  |L11.74|
;;;571        else if (pin_in_use_by_te(pin))
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       pin_in_use_by_te
000050  b330              CBZ      r0,|L11.160|
;;;572        {
;;;573            int32_t             channel = (int32_t)channel_port_get(pin);
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       channel_port_get
000058  4604              MOV      r4,r0
;;;574            nrf_gpiote_events_t event   = TE_IDX_TO_EVENT_ADDR(channel);
00005a  00a0              LSLS     r0,r4,#2
00005c  f5007080          ADD      r0,r0,#0x100
000060  b287              UXTH     r7,r0
;;;575    
;;;576            nrf_gpiote_event_enable(channel);
000062  4620              MOV      r0,r4
000064  4910              LDR      r1,|L11.168|
000066  f8511020          LDR      r1,[r1,r0,LSL #2]
00006a  f0410201          ORR      r2,r1,#1
00006e  490e              LDR      r1,|L11.168|
000070  f8412020          STR      r2,[r1,r0,LSL #2]
000074  bf00              NOP      
;;;577    
;;;578            nrf_gpiote_event_clear(event);
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       nrf_gpiote_event_clear
;;;579            if (int_enable)
00007c  b17d              CBZ      r5,|L11.158|
;;;580            {
;;;581                nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(channel_port_get(pin));
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       channel_port_get
000084  4681              MOV      r9,r0
000086  f7fffffe          BL       channel_handler_get
00008a  4680              MOV      r8,r0
;;;582                // Enable the interrupt only if event handler was provided.
;;;583                if (handler)
00008c  f1b80f00          CMP      r8,#0
000090  d004              BEQ      |L11.156|
;;;584                {
;;;585                    nrf_gpiote_int_enable(1 << channel);
000092  2101              MOVS     r1,#1
000094  fa01f004          LSL      r0,r1,r4
000098  f7fffffe          BL       nrf_gpiote_int_enable
                  |L11.156|
;;;586                }
;;;587            }
00009c  bf00              NOP      
                  |L11.158|
;;;588        }
00009e  bf00              NOP      
                  |L11.160|
;;;589    }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;590    
                          ENDP

                  |L11.164|
                          DCD      m_cb+0x50
                  |L11.168|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_in_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_init PROC
;;;498    
;;;499    ret_code_t nrf_drv_gpiote_in_init(nrf_drv_gpiote_pin_t               pin,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;500                                      nrf_drv_gpiote_in_config_t const * p_config,
;;;501                                      nrf_drv_gpiote_evt_handler_t       evt_handler)
;;;502    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;503        ASSERT(pin < NUMBER_OF_PINS);
;;;504        ret_code_t err_code = NRF_SUCCESS;
00000a  f04f0800          MOV      r8,#0
;;;505    
;;;506        /* Only one GPIOTE channel can be assigned to one physical pin. */
;;;507        if (pin_in_use_by_gpiote(pin))
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pin_in_use_by_gpiote
000014  b110              CBZ      r0,|L12.28|
;;;508        {
;;;509            err_code = NRF_ERROR_INVALID_STATE;
000016  f04f0808          MOV      r8,#8
00001a  e055              B        |L12.200|
                  |L12.28|
;;;510        }
;;;511        else
;;;512        {
;;;513            int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
00001c  78f2              LDRB     r2,[r6,#3]
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       channel_port_alloc
000026  4605              MOV      r5,r0
;;;514            if (channel != NO_CHANNELS)
000028  1c68              ADDS     r0,r5,#1
00002a  2800              CMP      r0,#0
00002c  d049              BEQ      |L12.194|
;;;515            {
;;;516                if (p_config->is_watcher)
00002e  78b0              LDRB     r0,[r6,#2]
000030  b180              CBZ      r0,|L12.84|
;;;517                {
;;;518                    nrf_gpio_cfg_watcher(pin);
000032  bf00              NOP      
000034  bf00              NOP      
000036  f04f42a0          MOV      r2,#0x50000000
00003a  4610              MOV      r0,r2
00003c  f50062e0          ADD      r2,r0,#0x700
000040  f8522024          LDR      r2,[r2,r4,LSL #2]
000044  f0220102          BIC      r1,r2,#2
000048  f50062e0          ADD      r2,r0,#0x700
00004c  f8421024          STR      r1,[r2,r4,LSL #2]
000050  bf00              NOP      
000052  e00c              B        |L12.110|
                  |L12.84|
;;;519                }
;;;520                else
;;;521                {
;;;522                    nrf_gpio_cfg_input(pin, p_config->pull);
000054  f8969001          LDRB     r9,[r6,#1]
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  464b              MOV      r3,r9
00005e  4602              MOV      r2,r0
000060  4601              MOV      r1,r0
000062  9001              STR      r0,[sp,#4]
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       nrf_gpio_cfg
00006a  bf00              NOP      
00006c  bf00              NOP      
                  |L12.110|
;;;523                }
;;;524    
;;;525                if (p_config->hi_accuracy)
00006e  78f0              LDRB     r0,[r6,#3]
000070  b1d0              CBZ      r0,|L12.168|
;;;526                {
;;;527                    nrf_gpiote_event_configure(channel, pin, p_config->sense);
000072  7830              LDRB     r0,[r6,#0]
000074  4916              LDR      r1,|L12.208|
000076  f8511025          LDR      r1,[r1,r5,LSL #2]
00007a  4a16              LDR      r2,|L12.212|
00007c  4011              ANDS     r1,r1,r2
00007e  4a14              LDR      r2,|L12.208|
000080  f8421025          STR      r1,[r2,r5,LSL #2]
000084  4611              MOV      r1,r2
000086  f8511025          LDR      r1,[r1,r5,LSL #2]
00008a  f44f52f8          MOV      r2,#0x1f00
00008e  ea022204          AND      r2,r2,r4,LSL #8
000092  f44f3340          MOV      r3,#0x30000
000096  ea034300          AND      r3,r3,r0,LSL #16
00009a  431a              ORRS     r2,r2,r3
00009c  4311              ORRS     r1,r1,r2
00009e  4a0c              LDR      r2,|L12.208|
0000a0  f8421025          STR      r1,[r2,r5,LSL #2]
0000a4  bf00              NOP      
0000a6  e00e              B        |L12.198|
                  |L12.168|
;;;528                }
;;;529                else
;;;530                {
;;;531                    m_cb.port_handlers_pins[channel -
0000a8  f1a50008          SUB      r0,r5,#8
0000ac  490a              LDR      r1,|L12.216|
0000ae  5c08              LDRB     r0,[r1,r0]
0000b0  7831              LDRB     r1,[r6,#0]
0000b2  ea401081          ORR      r0,r0,r1,LSL #6
0000b6  b242              SXTB     r2,r0
0000b8  f1a50008          SUB      r0,r5,#8
0000bc  4906              LDR      r1,|L12.216|
0000be  540a              STRB     r2,[r1,r0]
0000c0  e001              B        |L12.198|
                  |L12.194|
;;;532                                            GPIOTE_CH_NUM] |= (p_config->sense) << SENSE_FIELD_POS;
;;;533                }
;;;534            }
;;;535            else
;;;536            {
;;;537                err_code = NRF_ERROR_NO_MEM;
0000c2  f04f0804          MOV      r8,#4
                  |L12.198|
;;;538            }
;;;539        }
0000c6  bf00              NOP      
                  |L12.200|
;;;540    
;;;541        NRF_LOG_INFO("Function: %s, error code: %s.", (uint32_t)__func__,
;;;542                     (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;543        return err_code;
0000c8  4640              MOV      r0,r8
;;;544    }
0000ca  e8bd87fc          POP      {r2-r10,pc}
;;;545    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L12.208|
                          DCD      0x40006510
                  |L12.212|
                          DCD      0xfffce0ff
                  |L12.216|
                          DCD      m_cb+0x50

                          AREA ||i.nrf_drv_gpiote_in_is_set||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_is_set PROC
;;;623    
;;;624    bool nrf_drv_gpiote_in_is_set(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;625    {
000002  4604              MOV      r4,r0
;;;626        ASSERT(pin < NUMBER_OF_PINS);
;;;627        return nrf_gpio_pin_read(pin) ? true : false;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_read
00000a  b108              CBZ      r0,|L13.16|
00000c  2001              MOVS     r0,#1
                  |L13.14|
;;;628    }
00000e  bd10              POP      {r4,pc}
                  |L13.16|
000010  2000              MOVS     r0,#0                 ;627
000012  e7fc              B        |L13.14|
;;;629    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_uninit PROC
;;;608    
;;;609    void nrf_drv_gpiote_in_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
000002  4604              MOV      r4,r0
;;;611        ASSERT(pin < NUMBER_OF_PINS);
;;;612        ASSERT(pin_in_use_by_gpiote(pin));
;;;613        nrf_drv_gpiote_in_event_disable(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_drv_gpiote_in_event_disable
;;;614        if (pin_in_use_by_te(pin))
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       pin_in_use_by_te
000010  b128              CBZ      r0,|L14.30|
;;;615        {
;;;616            nrf_gpiote_te_default(channel_port_get(pin));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       channel_port_get
000018  4605              MOV      r5,r0
00001a  f7fffffe          BL       nrf_gpiote_te_default
                  |L14.30|
;;;617        }
;;;618        nrf_gpio_cfg_default(pin);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       nrf_gpio_cfg_default
;;;619        channel_free((uint8_t)channel_port_get(pin));
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       channel_port_get
00002a  b2c5              UXTB     r5,r0
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       channel_free
;;;620        pin_in_use_clear(pin);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       pin_in_use_clear
;;;621    }
000038  bd70              POP      {r4-r6,pc}
;;;622    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_init PROC
;;;223    
;;;224    ret_code_t nrf_drv_gpiote_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;225    {
;;;226        ret_code_t err_code;
;;;227    
;;;228        if (m_cb.state != NRF_DRV_STATE_UNINITIALIZED)
000002  4816              LDR      r0,|L15.92|
000004  f8900054          LDRB     r0,[r0,#0x54]  ; m_cb
000008  b110              CBZ      r0,|L15.16|
;;;229        {
;;;230            err_code = NRF_ERROR_INVALID_STATE;
00000a  2508              MOVS     r5,#8
;;;231            NRF_LOG_WARNING("Function: %s, error code: %s.",
;;;232                            (uint32_t)__func__,
;;;233                            (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;234            return err_code;
00000c  4628              MOV      r0,r5
                  |L15.14|
;;;235        }
;;;236    
;;;237        uint8_t i;
;;;238    
;;;239        for (i = 0; i < NUMBER_OF_PINS; i++)
;;;240        {
;;;241            pin_in_use_clear(i);
;;;242        }
;;;243    
;;;244        for (i = 0; i < (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
;;;245        {
;;;246            channel_free(i);
;;;247        }
;;;248    
;;;249        nrf_drv_common_irq_enable(GPIOTE_IRQn, GPIOTE_CONFIG_IRQ_PRIORITY);
;;;250        nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
;;;251        nrf_gpiote_int_enable(GPIOTE_INTENSET_PORT_Msk);
;;;252        m_cb.state = NRF_DRV_STATE_INITIALIZED;
;;;253    
;;;254        err_code = NRF_SUCCESS;
;;;255        NRF_LOG_INFO("Function: %s, error code: %s.", (uint32_t)__func__,
;;;256                     (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;257        return err_code;
;;;258    }
00000e  bd70              POP      {r4-r6,pc}
                  |L15.16|
000010  2400              MOVS     r4,#0                 ;239
000012  e004              B        |L15.30|
                  |L15.20|
000014  4620              MOV      r0,r4                 ;241
000016  f7fffffe          BL       pin_in_use_clear
00001a  1c60              ADDS     r0,r4,#1              ;239
00001c  b2c4              UXTB     r4,r0                 ;239
                  |L15.30|
00001e  2c20              CMP      r4,#0x20              ;239
000020  dbf8              BLT      |L15.20|
000022  2400              MOVS     r4,#0                 ;244
000024  e004              B        |L15.48|
                  |L15.38|
000026  4620              MOV      r0,r4                 ;246
000028  f7fffffe          BL       channel_free
00002c  1c60              ADDS     r0,r4,#1              ;244
00002e  b2c4              UXTB     r4,r0                 ;244
                  |L15.48|
000030  2c0c              CMP      r4,#0xc               ;244
000032  dbf8              BLT      |L15.38|
000034  2107              MOVS     r1,#7                 ;249
000036  2006              MOVS     r0,#6                 ;249
000038  f7fffffe          BL       nrf_drv_common_irq_enable
00003c  f44f70be          MOV      r0,#0x17c             ;250
000040  f7fffffe          BL       nrf_gpiote_event_clear
000044  f04f4000          MOV      r0,#0x80000000        ;251
000048  f7fffffe          BL       nrf_gpiote_int_enable
00004c  2001              MOVS     r0,#1                 ;252
00004e  4903              LDR      r1,|L15.92|
000050  f8810054          STRB     r0,[r1,#0x54]         ;252
000054  2500              MOVS     r5,#0                 ;254
000056  4628              MOV      r0,r5                 ;257
000058  e7d9              B        |L15.14|
;;;259    
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      m_cb

                          AREA ||i.nrf_drv_gpiote_is_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_is_init PROC
;;;260    
;;;261    bool nrf_drv_gpiote_is_init(void)
000000  4803              LDR      r0,|L16.16|
;;;262    {
;;;263        return (m_cb.state != NRF_DRV_STATE_UNINITIALIZED) ? true : false;
000002  f8900054          LDRB     r0,[r0,#0x54]  ; m_cb
000006  b108              CBZ      r0,|L16.12|
000008  2001              MOVS     r0,#1
                  |L16.10|
;;;264    }
00000a  4770              BX       lr
                  |L16.12|
00000c  2000              MOVS     r0,#0                 ;263
00000e  e7fc              B        |L16.10|
;;;265    
                          ENDP

                  |L16.16|
                          DCD      m_cb

                          AREA ||i.nrf_drv_gpiote_out_clear||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_clear PROC
;;;371    
;;;372    void nrf_drv_gpiote_out_clear(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;373    {
000002  4604              MOV      r4,r0
;;;374        ASSERT(pin < NUMBER_OF_PINS);
;;;375        ASSERT(pin_in_use(pin));
;;;376        ASSERT(!pin_in_use_by_te(pin))
;;;377    
;;;378        nrf_gpio_pin_clear(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_clear
;;;379    }
00000a  bd10              POP      {r4,pc}
;;;380    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_init PROC
;;;291    
;;;292    ret_code_t nrf_drv_gpiote_out_init(nrf_drv_gpiote_pin_t                pin,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;293                                       nrf_drv_gpiote_out_config_t const * p_config)
;;;294    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;295        ASSERT(pin < NUMBER_OF_PINS);
;;;296        ASSERT(m_cb.state == NRF_DRV_STATE_INITIALIZED);
;;;297        ASSERT(p_config);
;;;298    
;;;299        ret_code_t err_code = NRF_SUCCESS;
000008  2700              MOVS     r7,#0
;;;300    
;;;301        if (pin_in_use(pin))
00000a  4620              MOV      r0,r4
00000c  492c              LDR      r1,|L18.192|
00000e  5609              LDRSB    r1,[r1,r0]
000010  1c49              ADDS     r1,r1,#1
000012  b109              CBZ      r1,|L18.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L18.26|
                  |L18.24|
000018  2100              MOVS     r1,#0
                  |L18.26|
00001a  b109              CBZ      r1,|L18.32|
;;;302        {
;;;303            err_code = NRF_ERROR_INVALID_STATE;
00001c  2708              MOVS     r7,#8
00001e  e04b              B        |L18.184|
                  |L18.32|
;;;304        }
;;;305        else
;;;306        {
;;;307            if (p_config->task_pin)
000020  78b0              LDRB     r0,[r6,#2]
000022  b360              CBZ      r0,|L18.126|
;;;308            {
;;;309                int8_t channel = channel_port_alloc(pin, NULL, true);
000024  2201              MOVS     r2,#1
000026  2100              MOVS     r1,#0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       channel_port_alloc
00002e  4605              MOV      r5,r0
;;;310    
;;;311                if (channel != NO_CHANNELS)
000030  1c68              ADDS     r0,r5,#1
000032  b310              CBZ      r0,|L18.122|
;;;312                {
;;;313                    nrf_gpiote_task_configure(channel, pin, p_config->action, p_config->init_state);
000034  7830              LDRB     r0,[r6,#0]
000036  7871              LDRB     r1,[r6,#1]
000038  4a22              LDR      r2,|L18.196|
00003a  f8522025          LDR      r2,[r2,r5,LSL #2]
00003e  4b22              LDR      r3,|L18.200|
000040  401a              ANDS     r2,r2,r3
000042  4b20              LDR      r3,|L18.196|
000044  f8432025          STR      r2,[r3,r5,LSL #2]
000048  461a              MOV      r2,r3
00004a  f8523025          LDR      r3,[r2,r5,LSL #2]
00004e  f44f52f8          MOV      r2,#0x1f00
000052  ea022204          AND      r2,r2,r4,LSL #8
000056  f44f3c40          MOV      r12,#0x30000
00005a  ea0c4c00          AND      r12,r12,r0,LSL #16
00005e  ea42020c          ORR      r2,r2,r12
000062  f44f1c80          MOV      r12,#0x100000
000066  ea0c5c01          AND      r12,r12,r1,LSL #20
00006a  ea42020c          ORR      r2,r2,r12
00006e  4313              ORRS     r3,r3,r2
000070  4a14              LDR      r2,|L18.196|
000072  f8423025          STR      r3,[r2,r5,LSL #2]
000076  bf00              NOP      
000078  e000              B        |L18.124|
                  |L18.122|
;;;314                }
;;;315                else
;;;316                {
;;;317                    err_code = NRF_ERROR_NO_MEM;
00007a  2704              MOVS     r7,#4
                  |L18.124|
;;;318                }
;;;319            }
00007c  e005              B        |L18.138|
                  |L18.126|
;;;320            else
;;;321            {
;;;322                pin_in_use_set(pin);
00007e  bf00              NOP      
000080  21fe              MOVS     r1,#0xfe
000082  480f              LDR      r0,|L18.192|
000084  5501              STRB     r1,[r0,r4]
000086  bf00              NOP      
000088  bf00              NOP      
                  |L18.138|
;;;323            }
;;;324    
;;;325            if (err_code == NRF_SUCCESS)
00008a  b9af              CBNZ     r7,|L18.184|
;;;326            {
;;;327                if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
00008c  7870              LDRB     r0,[r6,#1]
00008e  2801              CMP      r0,#1
000090  d103              BNE      |L18.154|
;;;328                {
;;;329                    nrf_gpio_pin_set(pin);
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       nrf_gpio_pin_set
000098  e002              B        |L18.160|
                  |L18.154|
;;;330                }
;;;331                else
;;;332                {
;;;333                    nrf_gpio_pin_clear(pin);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       nrf_gpio_pin_clear
                  |L18.160|
;;;334                }
;;;335    
;;;336                nrf_gpio_cfg_output(pin);
0000a0  bf00              NOP      
0000a2  2000              MOVS     r0,#0
0000a4  9000              STR      r0,[sp,#0]
0000a6  4603              MOV      r3,r0
0000a8  2201              MOVS     r2,#1
0000aa  4611              MOV      r1,r2
0000ac  9001              STR      r0,[sp,#4]
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       nrf_gpio_cfg
0000b4  bf00              NOP      
0000b6  bf00              NOP      
                  |L18.184|
;;;337            }
;;;338        }
;;;339    
;;;340        NRF_LOG_INFO("Function: %s, error code: %s.", (uint32_t)__func__,
;;;341                     (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;342        return err_code;
0000b8  4638              MOV      r0,r7
;;;343    }
0000ba  e8bd81fc          POP      {r2-r8,pc}
;;;344    
                          ENDP

0000be  0000              DCW      0x0000
                  |L18.192|
                          DCD      m_cb+0x30
                  |L18.196|
                          DCD      0x40006510
                  |L18.200|
                          DCD      0xffece0ff

                          AREA ||i.nrf_drv_gpiote_out_set||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_set PROC
;;;361    
;;;362    void nrf_drv_gpiote_out_set(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;363    {
000002  4604              MOV      r4,r0
;;;364        ASSERT(pin < NUMBER_OF_PINS);
;;;365        ASSERT(pin_in_use(pin));
;;;366        ASSERT(!pin_in_use_by_te(pin))
;;;367    
;;;368        nrf_gpio_pin_set(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_set
;;;369    }
00000a  bd10              POP      {r4,pc}
;;;370    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_task_addr_get PROC
;;;411    
;;;412    uint32_t nrf_drv_gpiote_out_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;413    {
000002  4604              MOV      r4,r0
;;;414        ASSERT(pin < NUMBER_OF_PINS);
;;;415        ASSERT(pin_in_use_by_te(pin));
;;;416    
;;;417        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e05              LSRS     r5,r0,#24
;;;418        return nrf_gpiote_task_addr_get(task);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;419    }
000014  bd70              POP      {r4-r6,pc}
;;;420    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_task_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_disable PROC
;;;401    
;;;402    void nrf_drv_gpiote_out_task_disable(nrf_drv_gpiote_pin_t pin)
000000  4601              MOV      r1,r0
;;;403    {
;;;404        ASSERT(pin < NUMBER_OF_PINS);
;;;405        ASSERT(pin_in_use(pin));
;;;406        ASSERT(pin_in_use_by_te(pin))
;;;407    
;;;408        nrf_gpiote_task_disable(m_cb.pin_assignments[pin]);
000002  4a06              LDR      r2,|L21.28|
000004  5650              LDRSB    r0,[r2,r1]
000006  4a06              LDR      r2,|L21.32|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
00000c  f0220303          BIC      r3,r2,#3
000010  4a03              LDR      r2,|L21.32|
000012  f8423020          STR      r3,[r2,r0,LSL #2]
000016  bf00              NOP      
;;;409    }
000018  4770              BX       lr
;;;410    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      m_cb+0x30
                  |L21.32|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_enable PROC
;;;391    
;;;392    void nrf_drv_gpiote_out_task_enable(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;393    {
000002  4601              MOV      r1,r0
;;;394        ASSERT(pin < NUMBER_OF_PINS);
;;;395        ASSERT(pin_in_use(pin));
;;;396        ASSERT(pin_in_use_by_te(pin))
;;;397    
;;;398        nrf_gpiote_task_enable(m_cb.pin_assignments[pin]);
000004  4a06              LDR      r2,|L22.32|
000006  5650              LDRSB    r0,[r2,r1]
000008  4c06              LDR      r4,|L22.36|
00000a  eb040380          ADD      r3,r4,r0,LSL #2
00000e  f8d33510          LDR      r3,[r3,#0x510]
000012  f0430203          ORR      r2,r3,#3
000016  4b04              LDR      r3,|L22.40|
000018  f8432020          STR      r2,[r3,r0,LSL #2]
00001c  bf00              NOP      
;;;399    }
00001e  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  |L22.32|
                          DCD      m_cb+0x30
                  |L22.36|
                          DCD      0x40006000
                  |L22.40|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_force||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_force PROC
;;;447    
;;;448    void nrf_drv_gpiote_out_task_force(nrf_drv_gpiote_pin_t pin, uint8_t state)
000000  b530              PUSH     {r4,r5,lr}
;;;449    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;450        ASSERT(pin < NUMBER_OF_PINS);
;;;451        ASSERT(pin_in_use(pin));
;;;452        ASSERT(pin_in_use_by_te(pin));
;;;453    
;;;454        nrf_gpiote_outinit_t init_val =
000006  b10b              CBZ      r3,|L23.12|
;;;455            state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
000008  2101              MOVS     r1,#1
00000a  e000              B        |L23.14|
                  |L23.12|
00000c  2100              MOVS     r1,#0
                  |L23.14|
00000e  4608              MOV      r0,r1
;;;456        nrf_gpiote_task_force(m_cb.pin_assignments[pin], init_val);
000010  4c05              LDR      r4,|L23.40|
000012  56a1              LDRSB    r1,[r4,r2]
000014  4c05              LDR      r4,|L23.44|
000016  f8544021          LDR      r4,[r4,r1,LSL #2]
00001a  f3605414          BFI      r4,r0,#20,#1
00001e  4d03              LDR      r5,|L23.44|
000020  f8454021          STR      r4,[r5,r1,LSL #2]
000024  bf00              NOP      
;;;457    }
000026  bd30              POP      {r4,r5,pc}
;;;458    
                          ENDP

                  |L23.40|
                          DCD      m_cb+0x30
                  |L23.44|
                          DCD      0x40006510

                          AREA ||i.nrf_drv_gpiote_out_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_trigger PROC
;;;459    
;;;460    void nrf_drv_gpiote_out_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;461    {
000002  4604              MOV      r4,r0
;;;462        ASSERT(pin < NUMBER_OF_PINS);
;;;463        ASSERT(pin_in_use(pin));
;;;464        ASSERT(pin_in_use_by_te(pin));
;;;465    
;;;466        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e05              LSRS     r5,r0,#24
;;;467        nrf_gpiote_task_set(task);
00000e  bf00              NOP      
000010  2001              MOVS     r0,#1
000012  4902              LDR      r1,|L24.28|
000014  5068              STR      r0,[r5,r1]
000016  bf00              NOP      
;;;468    }
000018  bd70              POP      {r4-r6,pc}
;;;469    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_toggle||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_toggle PROC
;;;381    
;;;382    void nrf_drv_gpiote_out_toggle(nrf_drv_gpiote_pin_t pin)
000000  bf00              NOP      
000002  bf00              NOP      
000004  f04f43a0          MOV      r3,#0x50000000
000008  4619              MOV      r1,r3
00000a  f8d12504          LDR      r2,[r1,#0x504]
00000e  2301              MOVS     r3,#1
000010  4083              LSLS     r3,r3,r0
000012  4393              BICS     r3,r3,r2
000014  f8c13508          STR      r3,[r1,#0x508]
000018  2301              MOVS     r3,#1
00001a  4083              LSLS     r3,r3,r0
00001c  4013              ANDS     r3,r3,r2
00001e  f8c1350c          STR      r3,[r1,#0x50c]
000022  bf00              NOP      
;;;383    {
;;;384        ASSERT(pin < NUMBER_OF_PINS);
;;;385        ASSERT(pin_in_use(pin));
;;;386        ASSERT(!pin_in_use_by_te(pin))
;;;387    
;;;388        nrf_gpio_pin_toggle(pin);
;;;389    }
000024  4770              BX       lr
;;;390    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_uninit PROC
;;;345    
;;;346    void nrf_drv_gpiote_out_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;347    {
000002  4604              MOV      r4,r0
;;;348        ASSERT(pin < NUMBER_OF_PINS);
;;;349        ASSERT(pin_in_use(pin));
;;;350    
;;;351        if (pin_in_use_by_te(pin))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       pin_in_use_by_te
00000a  b160              CBZ      r0,|L26.38|
;;;352        {
;;;353            channel_free((uint8_t)channel_port_get(pin));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       channel_port_get
000012  b2c5              UXTB     r5,r0
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       channel_free
;;;354            nrf_gpiote_te_default(channel_port_get(pin));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       channel_port_get
000020  4605              MOV      r5,r0
000022  f7fffffe          BL       nrf_gpiote_te_default
                  |L26.38|
;;;355        }
;;;356        pin_in_use_clear(pin);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       pin_in_use_clear
;;;357    
;;;358        nrf_gpio_cfg_default(pin);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       nrf_gpio_cfg_default
;;;359    }
000032  bd70              POP      {r4-r6,pc}
;;;360    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_set_task_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_set_task_addr_get PROC
;;;422    #if defined(GPIOTE_FEATURE_SET_PRESENT)
;;;423    uint32_t nrf_drv_gpiote_set_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;424    {
000002  4604              MOV      r4,r0
;;;425        ASSERT(pin < NUMBER_OF_PINS);
;;;426        ASSERT(pin_in_use_by_te(pin));
;;;427    
;;;428        nrf_gpiote_tasks_t task = TE_SET_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3030              ADDS     r0,r0,#0x30
00000e  b2c5              UXTB     r5,r0
;;;429        return nrf_gpiote_task_addr_get(task);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_gpiote_task_addr_get
;;;430    }
000016  bd70              POP      {r4-r6,pc}
;;;431    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_set_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_set_task_trigger PROC
;;;471    #if defined(GPIOTE_FEATURE_SET_PRESENT)
;;;472    void nrf_drv_gpiote_set_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;473    {
000002  4604              MOV      r4,r0
;;;474        ASSERT(pin < NUMBER_OF_PINS);
;;;475        ASSERT(pin_in_use(pin));
;;;476        ASSERT(pin_in_use_by_te(pin));
;;;477    
;;;478        nrf_gpiote_tasks_t task = TE_SET_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0080              LSLS     r0,r0,#2
00000c  3030              ADDS     r0,r0,#0x30
00000e  b2c5              UXTB     r5,r0
;;;479        nrf_gpiote_task_set(task);
000010  bf00              NOP      
000012  2001              MOVS     r0,#1
000014  4901              LDR      r1,|L28.28|
000016  5068              STR      r0,[r5,r1]
000018  bf00              NOP      
;;;480    }
00001a  bd70              POP      {r4-r6,pc}
;;;481    
                          ENDP

                  |L28.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_uninit PROC
;;;266    
;;;267    void nrf_drv_gpiote_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;268    {
;;;269        ASSERT(m_cb.state != NRF_DRV_STATE_UNINITIALIZED);
;;;270    
;;;271        uint32_t i;
;;;272    
;;;273        for (i = 0; i < NUMBER_OF_PINS; i++)
000002  2400              MOVS     r4,#0
000004  e014              B        |L29.48|
                  |L29.6|
;;;274        {
;;;275            if (pin_in_use_as_non_task_out(i))
000006  4620              MOV      r0,r4
000008  490d              LDR      r1,|L29.64|
00000a  5609              LDRSB    r1,[r1,r0]
00000c  1c89              ADDS     r1,r1,#2
00000e  b909              CBNZ     r1,|L29.20|
000010  2101              MOVS     r1,#1
000012  e000              B        |L29.22|
                  |L29.20|
000014  2100              MOVS     r1,#0
                  |L29.22|
000016  b119              CBZ      r1,|L29.32|
;;;276            {
;;;277                nrf_drv_gpiote_out_uninit(i);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       nrf_drv_gpiote_out_uninit
00001e  e006              B        |L29.46|
                  |L29.32|
;;;278            }
;;;279            else if ( pin_in_use_by_gpiote(i))
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       pin_in_use_by_gpiote
000026  b110              CBZ      r0,|L29.46|
;;;280            {
;;;281                /* Disable gpiote_in is having the same effect on out pin as gpiote_out_uninit on
;;;282                 * so it can be called on all pins used by GPIOTE.
;;;283                 */
;;;284                nrf_drv_gpiote_in_uninit(i);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       nrf_drv_gpiote_in_uninit
                  |L29.46|
00002e  1c64              ADDS     r4,r4,#1              ;273
                  |L29.48|
000030  2c20              CMP      r4,#0x20              ;273
000032  d3e8              BCC      |L29.6|
;;;285            }
;;;286        }
;;;287        m_cb.state = NRF_DRV_STATE_UNINITIALIZED;
000034  2000              MOVS     r0,#0
000036  4902              LDR      r1,|L29.64|
000038  3930              SUBS     r1,r1,#0x30
00003a  f8810054          STRB     r0,[r1,#0x54]
;;;288        NRF_LOG_INFO("Uninitialized.");
;;;289    }
00003e  bd10              POP      {r4,pc}
;;;290    
                          ENDP

                  |L29.64|
                          DCD      m_cb+0x30

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg PROC
;;;503    
;;;504    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;505        uint32_t             pin_number,
;;;506        nrf_gpio_pin_dir_t   dir,
;;;507        nrf_gpio_pin_input_t input,
;;;508        nrf_gpio_pin_pull_t  pull,
;;;509        nrf_gpio_pin_drive_t drive,
;;;510        nrf_gpio_pin_sense_t sense)
;;;511    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;512        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  bf00              NOP      
000008  f04f47a0          MOV      r7,#0x50000000
00000c  463e              MOV      r6,r7
;;;513    
;;;514        reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
00000e  ea410742          ORR      r7,r1,r2,LSL #1
000012  ea470783          ORR      r7,r7,r3,LSL #2
000016  ea472704          ORR      r7,r7,r4,LSL #8
00001a  ea474c05          ORR      r12,r7,r5,LSL #16
00001e  f50667e0          ADD      r7,r6,#0x700
000022  f847c020          STR      r12,[r7,r0,LSL #2]
;;;515                                   | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;516                                   | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
;;;517                                   | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;518                                   | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;519    }
000026  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;545    
;;;546    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;547    {
000002  4604              MOV      r4,r0
;;;548        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;549            pin_number,
;;;550            NRF_GPIO_PIN_DIR_INPUT,
;;;551            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;552            NRF_GPIO_PIN_NOPULL,
;;;553            NRF_GPIO_PIN_S0S1,
;;;554            NRF_GPIO_PIN_NOSENSE);
;;;555    }
000016  bd1c              POP      {r2-r4,pc}
;;;556    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_sense_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_sense_set PROC
;;;591    
;;;592    __STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
000000  b510              PUSH     {r4,lr}
;;;593    {
000002  460a              MOV      r2,r1
;;;594        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000004  bf00              NOP      
000006  f04f43a0          MOV      r3,#0x50000000
00000a  4619              MOV      r1,r3
;;;595    
;;;596        /*lint -e{845} // A zero has been given as right argument to operator '|'" */
;;;597        reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
00000c  f50163e0          ADD      r3,r1,#0x700
000010  f8533020          LDR      r3,[r3,r0,LSL #2]
000014  f4233440          BIC      r4,r3,#0x30000
000018  f50163e0          ADD      r3,r1,#0x700
00001c  f8434020          STR      r4,[r3,r0,LSL #2]
;;;598        reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
000020  f8533020          LDR      r3,[r3,r0,LSL #2]
000024  ea434402          ORR      r4,r3,r2,LSL #16
000028  f50163e0          ADD      r3,r1,#0x700
00002c  f8434020          STR      r4,[r3,r0,LSL #2]
;;;599    }
000030  bd10              POP      {r4,pc}
;;;600    
                          ENDP


                          AREA ||i.nrf_gpio_pin_clear||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_clear PROC
;;;629    
;;;630    __STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
000000  bf00              NOP      
000002  f04f41a0          MOV      r1,#0x50000000
;;;631    {
;;;632        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;633    
;;;634        nrf_gpio_port_out_clear(reg, 1UL << pin_number);
000008  2301              MOVS     r3,#1
00000a  fa03f100          LSL      r1,r3,r0
00000e  f8c2150c          STR      r1,[r2,#0x50c]
000012  bf00              NOP      
;;;635    }
000014  4770              BX       lr
;;;636    
                          ENDP


                          AREA ||i.nrf_gpio_pin_read||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_read PROC
;;;660    
;;;661    __STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
000000  4601              MOV      r1,r0
;;;662    {
;;;663        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  f04f40a0          MOV      r0,#0x50000000
000008  4602              MOV      r2,r0
;;;664    
;;;665        return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
00000a  bf00              NOP      
00000c  f8d20510          LDR      r0,[r2,#0x510]
000010  40c8              LSRS     r0,r0,r1
000012  f0000001          AND      r0,r0,#1
;;;666    }
000016  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_set PROC
;;;621    
;;;622    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  bf00              NOP      
000002  f04f41a0          MOV      r1,#0x50000000
;;;623    {
;;;624        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;625    
;;;626        nrf_gpio_port_out_set(reg, 1UL << pin_number);
000008  2301              MOVS     r3,#1
00000a  fa03f100          LSL      r1,r3,r0
00000e  f8c21508          STR      r1,[r2,#0x508]
000012  bf00              NOP      
;;;627    }
000014  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.nrf_gpio_ports_read||, CODE, READONLY, ALIGN=2

                  nrf_gpio_ports_read PROC
;;;739    
;;;740    __STATIC_INLINE void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks)
000000  b538              PUSH     {r3-r5,lr}
;;;741    {
000002  460b              MOV      r3,r1
;;;742        NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
000004  4c07              LDR      r4,|L36.36|
000006  6824              LDR      r4,[r4,#0]  ; <Data1>
000008  9400              STR      r4,[sp,#0]
;;;743    
;;;744        ASSERT(start_port + length <= GPIO_COUNT);
;;;745        uint32_t i;
;;;746    
;;;747        for (i = start_port; i < (start_port + length); i++)
00000a  4601              MOV      r1,r0
00000c  e006              B        |L36.28|
                  |L36.14|
;;;748        {
;;;749            *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
00000e  f85d4021          LDR      r4,[sp,r1,LSL #2]
000012  f8d45510          LDR      r5,[r4,#0x510]
000016  6015              STR      r5,[r2,#0]
;;;750            p_masks++;
000018  1d12              ADDS     r2,r2,#4
00001a  1c49              ADDS     r1,r1,#1              ;747
                  |L36.28|
00001c  18c4              ADDS     r4,r0,r3              ;747
00001e  428c              CMP      r4,r1                 ;747
000020  d8f5              BHI      |L36.14|
;;;751        }
;;;752    }
000022  bd38              POP      {r3-r5,pc}
;;;753    
                          ENDP

                  |L36.36|
                          DCD      ||.constdata||

                          AREA ||i.nrf_gpiote_event_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_event_addr_get PROC
;;;330    
;;;331    __STATIC_INLINE uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event)
000000  4601              MOV      r1,r0
;;;332    {
;;;333        return ((uint32_t)NRF_GPIOTE + event);
000002  4801              LDR      r0,|L37.8|
000004  4408              ADD      r0,r0,r1
;;;334    }
000006  4770              BX       lr
;;;335    
                          ENDP

                  |L37.8|
                          DCD      0x40006000

                          AREA ||i.nrf_gpiote_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_clear PROC
;;;321    
;;;322    __STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
000000  b538              PUSH     {r3-r5,lr}
;;;323    {
000002  4604              MOV      r4,r0
;;;324        *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
;;;325    #if __CORTEX_M == 0x04
;;;326        volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       nrf_gpiote_event_addr_get
000014  6800              LDR      r0,[r0,#0]
000016  9000              STR      r0,[sp,#0]
;;;327        (void)dummy;
000018  bf00              NOP      
;;;328    #endif
;;;329    }
00001a  bd38              POP      {r3-r5,pc}
;;;330    
                          ENDP


                          AREA ||i.nrf_gpiote_event_is_set||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_is_set PROC
;;;316    
;;;317    __STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319        return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  6800              LDR      r0,[r0,#0]
00000c  2801              CMP      r0,#1
00000e  d100              BNE      |L39.18|
                  |L39.16|
;;;320    }
000010  bd10              POP      {r4,pc}
                  |L39.18|
000012  2000              MOVS     r0,#0                 ;319
000014  e7fc              B        |L39.16|
;;;321    
                          ENDP


                          AREA ||i.nrf_gpiote_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_int_enable PROC
;;;335    
;;;336    __STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask)
000000  4901              LDR      r1,|L40.8|
;;;337    {
;;;338        NRF_GPIOTE->INTENSET = mask;
000002  6008              STR      r0,[r1,#0]
;;;339    }
000004  4770              BX       lr
;;;340    
                          ENDP

000006  0000              DCW      0x0000
                  |L40.8|
                          DCD      0x40006304

                          AREA ||i.nrf_gpiote_task_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_task_addr_get PROC
;;;311    
;;;312    __STATIC_INLINE uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task)
000000  4601              MOV      r1,r0
;;;313    {
;;;314        return ((uint32_t)NRF_GPIOTE + task);
000002  4801              LDR      r0,|L41.8|
000004  4408              ADD      r0,r0,r1
;;;315    }
000006  4770              BX       lr
;;;316    
                          ENDP

                  |L41.8|
                          DCD      0x40006000

                          AREA ||i.nrf_gpiote_te_default||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_te_default PROC
;;;417    
;;;418    __STATIC_INLINE void nrf_gpiote_te_default(uint32_t idx)
000000  2200              MOVS     r2,#0
;;;419    {
;;;420        NRF_GPIOTE->CONFIG[idx] = 0;
000002  4902              LDR      r1,|L42.12|
000004  f8412020          STR      r2,[r1,r0,LSL #2]
;;;421    }
000008  4770              BX       lr
;;;422    #endif //SUPPRESS_INLINE_IMPLEMENTATION
                          ENDP

00000a  0000              DCW      0x0000
                  |L42.12|
                          DCD      0x40006510

                          AREA ||i.pin_in_use_by_gpiote||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_gpiote PROC
;;;144    
;;;145    __STATIC_INLINE bool pin_in_use_by_gpiote(uint32_t pin)
000000  4601              MOV      r1,r0
;;;146    {
;;;147        return (m_cb.pin_assignments[pin] >= 0);
000002  4805              LDR      r0,|L43.24|
000004  5640              LDRSB    r0,[r0,r1]
000006  2201              MOVS     r2,#1
000008  eb0270e0          ADD      r0,r2,r0,ASR #31
00000c  b108              CBZ      r0,|L43.18|
00000e  2001              MOVS     r0,#1
                  |L43.16|
;;;148    }
000010  4770              BX       lr
                  |L43.18|
000012  2000              MOVS     r0,#0                 ;147
000014  e7fc              B        |L43.16|
;;;149    
                          ENDP

000016  0000              DCW      0x0000
                  |L43.24|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_by_port||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_port PROC
;;;138    
;;;139    __STATIC_INLINE bool pin_in_use_by_port(uint32_t pin)
000000  4601              MOV      r1,r0
;;;140    {
;;;141        return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
000002  4804              LDR      r0,|L44.20|
000004  5640              LDRSB    r0,[r0,r1]
000006  2808              CMP      r0,#8
000008  db01              BLT      |L44.14|
00000a  2001              MOVS     r0,#1
                  |L44.12|
;;;142    }
00000c  4770              BX       lr
                  |L44.14|
00000e  2000              MOVS     r0,#0                 ;141
000010  e7fc              B        |L44.12|
;;;143    
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_by_te||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_te PROC
;;;131    
;;;132    __STATIC_INLINE bool pin_in_use_by_te(uint32_t pin)
000000  4601              MOV      r1,r0
;;;133    {
;;;134        return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] <
000002  4806              LDR      r0,|L45.28|
000004  5640              LDRSB    r0,[r0,r1]
000006  2800              CMP      r0,#0
000008  db05              BLT      |L45.22|
00000a  4804              LDR      r0,|L45.28|
00000c  5640              LDRSB    r0,[r0,r1]
00000e  2808              CMP      r0,#8
000010  da01              BGE      |L45.22|
;;;135                GPIOTE_CH_NUM) ? true : false;
000012  2001              MOVS     r0,#1
                  |L45.20|
;;;136    }
000014  4770              BX       lr
                  |L45.22|
000016  2000              MOVS     r0,#0                 ;135
000018  e7fc              B        |L45.20|
;;;137    
                          ENDP

00001a  0000              DCW      0x0000
                  |L45.28|
                          DCD      m_cb+0x30

                          AREA ||i.pin_in_use_clear||, CODE, READONLY, ALIGN=2

                  pin_in_use_clear PROC
;;;170    
;;;171    __STATIC_INLINE void pin_in_use_clear(uint32_t pin)
000000  22ff              MOVS     r2,#0xff
;;;172    {
;;;173        m_cb.pin_assignments[pin] = PIN_NOT_USED;
000002  4901              LDR      r1,|L46.8|
000004  540a              STRB     r2,[r1,r0]
;;;174    }
000006  4770              BX       lr
;;;175    
                          ENDP

                  |L46.8|
                          DCD      m_cb+0x30

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        88

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x50000000
                  __func__
000004  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000008  6472765f          DCB      0x64,0x72,0x76,0x5f
00000c  6770696f          DCB      0x67,0x70,0x69,0x6f
000010  74655f69          DCB      0x74,0x65,0x5f,0x69
000014  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.129|
000018  6e72665f          DCB      0x6e,0x72,0x66,0x5f
00001c  6472765f          DCB      0x64,0x72,0x76,0x5f
000020  6770696f          DCB      0x67,0x70,0x69,0x6f
000024  74655f6f          DCB      0x74,0x65,0x5f,0x6f
000028  75745f69          DCB      0x75,0x74,0x5f,0x69
00002c  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.130|
000030  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000034  6472765f          DCB      0x64,0x72,0x76,0x5f
000038  6770696f          DCB      0x67,0x70,0x69,0x6f
00003c  74655f69          DCB      0x74,0x65,0x5f,0x69
000040  6e5f696e          DCB      0x6e,0x5f,0x69,0x6e
000044  697400            DCB      0x69,0x74,0x00

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=2

000000  6770696f          DCB      0x67,0x70,0x69,0x6f
000004  746500            DCB      0x74,0x65,0x00

                          AREA log_const_data, DATA, READONLY, ALIGN=2

                  m_nrf_log_gpiote_logs_data_const
                  ||__tagsym$$used||
                          DCD      ||.conststrlit||
000004  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA log_dynamic_data, DATA, ALIGN=2

                  m_nrf_log_gpiote_logs_data_dynamic
                  |symbol_number.367|
                          %        12

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\gpiote\\nrf_drv_gpiote.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_f5456f9d____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_nrf_drv_gpiote_c_f5456f9d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_f5456f9d____REVSH|
#line 402
|__asm___16_nrf_drv_gpiote_c_f5456f9d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_f5456f9d____RRX|
#line 587
|__asm___16_nrf_drv_gpiote_c_f5456f9d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
