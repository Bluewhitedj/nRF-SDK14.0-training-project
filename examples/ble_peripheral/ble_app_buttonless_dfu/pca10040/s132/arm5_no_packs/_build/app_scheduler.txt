; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\app_scheduler.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\app_scheduler.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\app_scheduler.crf ..\..\..\..\..\..\components\libraries\scheduler\app_scheduler.c]
                          THUMB

                          AREA ||i.app_sched_event_put||, CODE, READONLY, ALIGN=2

                  app_sched_event_put PROC
;;;163    
;;;164    uint32_t app_sched_event_put(void const              * p_event_data,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;165                                 uint16_t                  event_data_size,
;;;166                                 app_sched_event_handler_t handler)
;;;167    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;168        uint32_t err_code;
;;;169    
;;;170        if (event_data_size <= m_queue_event_size)
00000a  4826              LDR      r0,|L1.164|
00000c  8800              LDRH     r0,[r0,#0]  ; m_queue_event_size
00000e  4284              CMP      r4,r0
000010  dc44              BGT      |L1.156|
;;;171        {
;;;172            uint16_t event_index = 0xFFFF;
000012  f64f75ff          MOV      r5,#0xffff
;;;173    
;;;174            CRITICAL_REGION_ENTER();
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       app_util_critical_region_enter
;;;175    
;;;176            if (!APP_SCHED_QUEUE_FULL())
000020  bf00              NOP      
000022  4821              LDR      r0,|L1.168|
000024  f8909000          LDRB     r9,[r0,#0]  ; m_queue_start_index
000028  4820              LDR      r0,|L1.172|
00002a  7800              LDRB     r0,[r0,#0]  ; m_queue_end_index
00002c  f7fffffe          BL       next_index
000030  4548              CMP      r0,r9
000032  d101              BNE      |L1.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L1.58|
                  |L1.56|
000038  2000              MOVS     r0,#0
                  |L1.58|
00003a  b930              CBNZ     r0,|L1.74|
;;;177            {
;;;178                event_index       = m_queue_end_index;
00003c  481b              LDR      r0,|L1.172|
00003e  7805              LDRB     r5,[r0,#0]  ; m_queue_end_index
;;;179                m_queue_end_index = next_index(m_queue_end_index);
000040  7800              LDRB     r0,[r0,#0]  ; m_queue_end_index
000042  f7fffffe          BL       next_index
000046  4919              LDR      r1,|L1.172|
000048  7008              STRB     r0,[r1,#0]
                  |L1.74|
;;;180    
;;;181            #if APP_SCHEDULER_WITH_PROFILER
;;;182                // This function call must be protected with critical region because
;;;183                // it modifies 'm_max_queue_utilization'.
;;;184                queue_utilization_check();
;;;185            #endif
;;;186            }
;;;187    
;;;188            CRITICAL_REGION_EXIT();
00004a  f89d0000          LDRB     r0,[sp,#0]
00004e  f7fffffe          BL       app_util_critical_region_exit
;;;189    
;;;190            if (event_index != 0xFFFF)
000052  f64f70ff          MOV      r0,#0xffff
000056  4285              CMP      r5,r0
000058  d01e              BEQ      |L1.152|
;;;191            {
;;;192                // NOTE: This can be done outside the critical region since the event consumer will
;;;193                //       always be called from the main loop, and will thus never interrupt this code.
;;;194                m_queue_event_headers[event_index].handler = handler;
00005a  4815              LDR      r0,|L1.176|
00005c  6800              LDR      r0,[r0,#0]  ; m_queue_event_headers
00005e  f8408035          STR      r8,[r0,r5,LSL #3]
;;;195                if ((p_event_data != NULL) && (event_data_size > 0))
000062  b18f              CBZ      r7,|L1.136|
000064  2c00              CMP      r4,#0
000066  dd0f              BLE      |L1.136|
;;;196                {
;;;197                    memcpy(&m_queue_event_data[event_index * m_queue_event_size],
000068  4912              LDR      r1,|L1.180|
00006a  6809              LDR      r1,[r1,#0]  ; m_queue_event_data
00006c  4a0d              LDR      r2,|L1.164|
00006e  8812              LDRH     r2,[r2,#0]  ; m_queue_event_size
000070  fb051002          MLA      r0,r5,r2,r1
000074  4622              MOV      r2,r4
000076  4639              MOV      r1,r7
000078  f7fffffe          BL       __aeabi_memcpy
;;;198                           p_event_data,
;;;199                           event_data_size);
;;;200                    m_queue_event_headers[event_index].event_data_size = event_data_size;
00007c  480c              LDR      r0,|L1.176|
00007e  6800              LDR      r0,[r0,#0]  ; m_queue_event_headers
000080  eb0000c5          ADD      r0,r0,r5,LSL #3
000084  8084              STRH     r4,[r0,#4]
000086  e005              B        |L1.148|
                  |L1.136|
;;;201                }
;;;202                else
;;;203                {
;;;204                    m_queue_event_headers[event_index].event_data_size = 0;
000088  2000              MOVS     r0,#0
00008a  4909              LDR      r1,|L1.176|
00008c  6809              LDR      r1,[r1,#0]  ; m_queue_event_headers
00008e  eb0101c5          ADD      r1,r1,r5,LSL #3
000092  8088              STRH     r0,[r1,#4]
                  |L1.148|
;;;205                }
;;;206    
;;;207                err_code = NRF_SUCCESS;
000094  2600              MOVS     r6,#0
000096  e000              B        |L1.154|
                  |L1.152|
;;;208            }
;;;209            else
;;;210            {
;;;211                err_code = NRF_ERROR_NO_MEM;
000098  2604              MOVS     r6,#4
                  |L1.154|
;;;212            }
;;;213        }
00009a  e000              B        |L1.158|
                  |L1.156|
;;;214        else
;;;215        {
;;;216            err_code = NRF_ERROR_INVALID_LENGTH;
00009c  2609              MOVS     r6,#9
                  |L1.158|
;;;217        }
;;;218    
;;;219        return err_code;
00009e  4630              MOV      r0,r6
;;;220    }
0000a0  e8bd83f8          POP      {r3-r9,pc}
;;;221    
                          ENDP

                  |L1.164|
                          DCD      m_queue_event_size
                  |L1.168|
                          DCD      m_queue_start_index
                  |L1.172|
                          DCD      m_queue_end_index
                  |L1.176|
                          DCD      m_queue_event_headers
                  |L1.180|
                          DCD      m_queue_event_data

                          AREA ||i.app_sched_execute||, CODE, READONLY, ALIGN=2

                  app_sched_execute PROC
;;;262    
;;;263    void app_sched_execute(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;264    {
;;;265        while (!is_app_sched_paused() && !APP_SCHED_QUEUE_EMPTY())
000004  e01a              B        |L2.60|
                  |L2.6|
;;;266        {
;;;267            // Since this function is only called from the main loop, there is no
;;;268            // need for a critical region here, however a special care must be taken
;;;269            // regarding update of the queue start index (see the end of the loop).
;;;270            uint16_t event_index = m_queue_start_index;
000006  4816              LDR      r0,|L2.96|
000008  7804              LDRB     r4,[r0,#0]  ; m_queue_start_index
;;;271    
;;;272            void * p_event_data;
;;;273            uint16_t event_data_size;
;;;274            app_sched_event_handler_t event_handler;
;;;275    
;;;276            p_event_data = &m_queue_event_data[event_index * m_queue_event_size];
00000a  4816              LDR      r0,|L2.100|
00000c  6800              LDR      r0,[r0,#0]  ; m_queue_event_data
00000e  4916              LDR      r1,|L2.104|
000010  8809              LDRH     r1,[r1,#0]  ; m_queue_event_size
000012  fb040501          MLA      r5,r4,r1,r0
;;;277            event_data_size = m_queue_event_headers[event_index].event_data_size;
000016  4815              LDR      r0,|L2.108|
000018  6800              LDR      r0,[r0,#0]  ; m_queue_event_headers
00001a  eb0000c4          ADD      r0,r0,r4,LSL #3
00001e  8886              LDRH     r6,[r0,#4]
;;;278            event_handler   = m_queue_event_headers[event_index].handler;
000020  4812              LDR      r0,|L2.108|
000022  6800              LDR      r0,[r0,#0]  ; m_queue_event_headers
000024  f8507034          LDR      r7,[r0,r4,LSL #3]
;;;279    
;;;280            event_handler(p_event_data, event_data_size);
000028  4631              MOV      r1,r6
00002a  4628              MOV      r0,r5
00002c  47b8              BLX      r7
;;;281    
;;;282            // Event processed, now it is safe to move the queue start index,
;;;283            // so the queue entry occupied by this event can be used to store
;;;284            // a next one.
;;;285            m_queue_start_index = next_index(m_queue_start_index);
00002e  480c              LDR      r0,|L2.96|
000030  7800              LDRB     r0,[r0,#0]  ; m_queue_start_index
000032  f7fffffe          BL       next_index
000036  490a              LDR      r1,|L2.96|
000038  7008              STRB     r0,[r1,#0]
;;;286        }
00003a  bf00              NOP      
                  |L2.60|
00003c  bf00              NOP                            ;265
00003e  2000              MOVS     r0,#0                 ;265
000040  b958              CBNZ     r0,|L2.90|
000042  bf00              NOP                            ;265
000044  4906              LDR      r1,|L2.96|
000046  7808              LDRB     r0,[r1,#0]            ;265  ; m_queue_start_index
000048  4909              LDR      r1,|L2.112|
00004a  7809              LDRB     r1,[r1,#0]            ;265  ; m_queue_end_index
00004c  4281              CMP      r1,r0                 ;265
00004e  d101              BNE      |L2.84|
000050  2101              MOVS     r1,#1                 ;265
000052  e000              B        |L2.86|
                  |L2.84|
000054  2100              MOVS     r1,#0                 ;265
                  |L2.86|
000056  2900              CMP      r1,#0                 ;265
000058  d0d5              BEQ      |L2.6|
                  |L2.90|
;;;287    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;288    #endif //NRF_MODULE_ENABLED(APP_SCHEDULER)
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      m_queue_start_index
                  |L2.100|
                          DCD      m_queue_event_data
                  |L2.104|
                          DCD      m_queue_event_size
                  |L2.108|
                          DCD      m_queue_event_headers
                  |L2.112|
                          DCD      m_queue_end_index

                          AREA ||i.app_sched_init||, CODE, READONLY, ALIGN=2

                  app_sched_init PROC
;;;106    
;;;107    uint32_t app_sched_init(uint16_t event_size, uint16_t queue_size, void * p_event_buffer)
000000  b530              PUSH     {r4,r5,lr}
;;;108    {
000002  4603              MOV      r3,r0
;;;109        uint16_t data_start_index = (queue_size + 1) * sizeof(event_header_t);
000004  1c48              ADDS     r0,r1,#1
000006  f64f75ff          MOV      r5,#0xffff
00000a  ea0504c0          AND      r4,r5,r0,LSL #3
;;;110    
;;;111        // Check that buffer is correctly aligned
;;;112        if (!is_word_aligned(p_event_buffer))
00000e  4610              MOV      r0,r2
000010  f0000503          AND      r5,r0,#3
000014  b90d              CBNZ     r5,|L3.26|
000016  2501              MOVS     r5,#1
000018  e000              B        |L3.28|
                  |L3.26|
00001a  2500              MOVS     r5,#0
                  |L3.28|
00001c  b90d              CBNZ     r5,|L3.34|
;;;113        {
;;;114            return NRF_ERROR_INVALID_PARAM;
00001e  2007              MOVS     r0,#7
                  |L3.32|
;;;115        }
;;;116    
;;;117        // Initialize event scheduler
;;;118        m_queue_event_headers = p_event_buffer;
;;;119        m_queue_event_data    = &((uint8_t *)p_event_buffer)[data_start_index];
;;;120        m_queue_end_index     = 0;
;;;121        m_queue_start_index   = 0;
;;;122        m_queue_event_size    = event_size;
;;;123        m_queue_size          = queue_size;
;;;124    
;;;125    #if APP_SCHEDULER_WITH_PROFILER
;;;126        m_max_queue_utilization = 0;
;;;127    #endif
;;;128    
;;;129        return NRF_SUCCESS;
;;;130    }
000020  bd30              POP      {r4,r5,pc}
                  |L3.34|
000022  4808              LDR      r0,|L3.68|
000024  6002              STR      r2,[r0,#0]            ;118  ; m_queue_event_headers
000026  1910              ADDS     r0,r2,r4              ;119
000028  4d07              LDR      r5,|L3.72|
00002a  6028              STR      r0,[r5,#0]            ;119  ; m_queue_event_data
00002c  2000              MOVS     r0,#0                 ;120
00002e  4d07              LDR      r5,|L3.76|
000030  7028              STRB     r0,[r5,#0]            ;120
000032  4d07              LDR      r5,|L3.80|
000034  7028              STRB     r0,[r5,#0]            ;121
000036  4807              LDR      r0,|L3.84|
000038  8003              STRH     r3,[r0,#0]            ;122
00003a  4807              LDR      r0,|L3.88|
00003c  8001              STRH     r1,[r0,#0]            ;123
00003e  2000              MOVS     r0,#0                 ;129
000040  e7ee              B        |L3.32|
;;;131    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      m_queue_event_headers
                  |L3.72|
                          DCD      m_queue_event_data
                  |L3.76|
                          DCD      m_queue_end_index
                  |L3.80|
                          DCD      m_queue_start_index
                  |L3.84|
                          DCD      m_queue_event_size
                  |L3.88|
                          DCD      m_queue_size

                          AREA ||i.app_sched_queue_space_get||, CODE, READONLY, ALIGN=2

                  app_sched_queue_space_get PROC
;;;132    
;;;133    uint16_t app_sched_queue_space_get()
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135        uint16_t start = m_queue_start_index;
000002  4b09              LDR      r3,|L4.40|
000004  7819              LDRB     r1,[r3,#0]  ; m_queue_start_index
;;;136        uint16_t end   = m_queue_end_index;
000006  4b09              LDR      r3,|L4.44|
000008  781a              LDRB     r2,[r3,#0]  ; m_queue_end_index
;;;137        uint16_t free_space = m_queue_size - ((end >= start) ?
00000a  428a              CMP      r2,r1
00000c  db01              BLT      |L4.18|
;;;138                               (end - start) : (m_queue_size + 1 - start + end));
00000e  1a53              SUBS     r3,r2,r1
000010  e004              B        |L4.28|
                  |L4.18|
000012  4b07              LDR      r3,|L4.48|
000014  881b              LDRH     r3,[r3,#0]  ; m_queue_size
000016  1c5b              ADDS     r3,r3,#1
000018  1a5b              SUBS     r3,r3,r1
00001a  4413              ADD      r3,r3,r2
                  |L4.28|
00001c  4c04              LDR      r4,|L4.48|
00001e  8824              LDRH     r4,[r4,#0]  ; m_queue_size
000020  1ae3              SUBS     r3,r4,r3
000022  b298              UXTH     r0,r3
;;;139        return free_space;
;;;140    }
000024  bd10              POP      {r4,pc}
;;;141    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      m_queue_start_index
                  |L4.44|
                          DCD      m_queue_end_index
                  |L4.48|
                          DCD      m_queue_size

                          AREA ||i.next_index||, CODE, READONLY, ALIGN=2

                  next_index PROC
;;;80      */
;;;81     static __INLINE uint8_t next_index(uint8_t index)
000000  4601              MOV      r1,r0
;;;82     {
;;;83         return (index < m_queue_size) ? (index + 1) : 0;
000002  4804              LDR      r0,|L5.20|
000004  8800              LDRH     r0,[r0,#0]  ; m_queue_size
000006  4281              CMP      r1,r0
000008  da01              BGE      |L5.14|
00000a  1c48              ADDS     r0,r1,#1
00000c  e000              B        |L5.16|
                  |L5.14|
00000e  2000              MOVS     r0,#0
                  |L5.16|
000010  b2c0              UXTB     r0,r0
;;;84     }
000012  4770              BX       lr
;;;85     
                          ENDP

                  |L5.20|
                          DCD      m_queue_size

                          AREA ||.data||, DATA, ALIGN=2

                  m_queue_event_headers
                          DCD      0x00000000
                  m_queue_event_data
                          DCD      0x00000000
                  m_queue_start_index
000008  00                DCB      0x00
                  m_queue_end_index
000009  00                DCB      0x00
                  m_queue_event_size
00000a  0000              DCB      0x00,0x00
                  m_queue_size
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\scheduler\\app_scheduler.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_app_scheduler_c_d997b682____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_app_scheduler_c_d997b682____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_app_scheduler_c_d997b682____REVSH|
#line 402
|__asm___15_app_scheduler_c_d997b682____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_app_scheduler_c_d997b682____RRX|
#line 587
|__asm___15_app_scheduler_c_d997b682____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
