; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_drv_uart.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_drv_uart.crf ..\..\..\..\..\..\components\drivers_nrf\uart\nrf_drv_uart.c]
                          THUMB

                          AREA ||i.UARTE0_UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UARTE0_UART0_IRQHandler PROC
;;;957    #if UART0_ENABLED
;;;958    IRQ_HANDLER(0)
000000  b510              PUSH     {r4,lr}
;;;959    {
;;;960        CODE_FOR_UARTE_INT
000002  4806              LDR      r0,|L1.28|
000004  7f00              LDRB     r0,[r0,#0x1c]  ; m_cb
000006  b120              CBZ      r0,|L1.18|
000008  4904              LDR      r1,|L1.28|
00000a  4805              LDR      r0,|L1.32|
00000c  f7fffffe          BL       uarte_irq_handler
000010  e003              B        |L1.26|
                  |L1.18|
;;;961        (
;;;962            UART0_INSTANCE_INDEX,
;;;963            uarte_irq_handler(NRF_UARTE0, &m_cb[UART0_INSTANCE_INDEX]);
;;;964        )
;;;965        CODE_FOR_UART
000012  4902              LDR      r1,|L1.28|
000014  4802              LDR      r0,|L1.32|
000016  f7fffffe          BL       uart_irq_handler
                  |L1.26|
;;;966        (
;;;967            uart_irq_handler(NRF_UART0, &m_cb[UART0_INSTANCE_INDEX]);
;;;968        )
;;;969    }
00001a  bd10              POP      {r4,pc}
;;;970    #endif
                          ENDP

                  |L1.28|
                          DCD      m_cb
                  |L1.32|
                          DCD      0x40002000

                          AREA ||i.apply_config||, CODE, READONLY, ALIGN=2

                  apply_config PROC
;;;109    
;;;110    __STATIC_INLINE void apply_config(nrf_drv_uart_t const * p_instance, nrf_drv_uart_config_t const * p_config)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;112        if (p_config->pseltxd != NRF_UART_PSEL_DISCONNECTED)
000006  6820              LDR      r0,[r4,#0]
000008  1c40              ADDS     r0,r0,#1
00000a  b128              CBZ      r0,|L2.24|
;;;113        {
;;;114            nrf_gpio_pin_set(p_config->pseltxd);
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       nrf_gpio_pin_set
;;;115            nrf_gpio_cfg_output(p_config->pseltxd);
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_gpio_cfg_output
                  |L2.24|
;;;116        }
;;;117        if (p_config->pselrxd != NRF_UART_PSEL_DISCONNECTED)
000018  6860              LDR      r0,[r4,#4]
00001a  1c40              ADDS     r0,r0,#1
00001c  b118              CBZ      r0,|L2.38|
;;;118        {
;;;119            nrf_gpio_cfg_input(p_config->pselrxd, NRF_GPIO_PIN_NOPULL);
00001e  2100              MOVS     r1,#0
000020  6860              LDR      r0,[r4,#4]
000022  f7fffffe          BL       nrf_gpio_cfg_input
                  |L2.38|
;;;120        }
;;;121    
;;;122        CODE_FOR_UARTE
000026  7928              LDRB     r0,[r5,#4]
000028  492d              LDR      r1,|L2.224|
00002a  eb011040          ADD      r0,r1,r0,LSL #5
00002e  7f00              LDRB     r0,[r0,#0x1c]
000030  b350              CBZ      r0,|L2.136|
000032  6828              LDR      r0,[r5,#0]
000034  69a1              LDR      r1,[r4,#0x18]
000036  f8c01524          STR      r1,[r0,#0x524]
00003a  bf00              NOP      
00003c  7d61              LDRB     r1,[r4,#0x15]
00003e  7d22              LDRB     r2,[r4,#0x14]
000040  6828              LDR      r0,[r5,#0]
000042  ea410302          ORR      r3,r1,r2
000046  f8c0356c          STR      r3,[r0,#0x56c]
00004a  bf00              NOP      
00004c  e9d41200          LDRD     r1,r2,[r4,#0]
000050  6828              LDR      r0,[r5,#0]
000052  f7fffffe          BL       nrf_uarte_txrx_pins_set
000056  7d20              LDRB     r0,[r4,#0x14]
000058  2801              CMP      r0,#1
00005a  d13f              BNE      |L2.220|
00005c  68a0              LDR      r0,[r4,#8]
00005e  1c40              ADDS     r0,r0,#1
000060  b118              CBZ      r0,|L2.106|
000062  2100              MOVS     r1,#0
000064  68a0              LDR      r0,[r4,#8]
000066  f7fffffe          BL       nrf_gpio_cfg_input
                  |L2.106|
00006a  68e0              LDR      r0,[r4,#0xc]
00006c  1c40              ADDS     r0,r0,#1
00006e  b128              CBZ      r0,|L2.124|
000070  68e0              LDR      r0,[r4,#0xc]
000072  f7fffffe          BL       nrf_gpio_pin_set
000076  68e0              LDR      r0,[r4,#0xc]
000078  f7fffffe          BL       nrf_gpio_cfg_output
                  |L2.124|
00007c  e9d42102          LDRD     r2,r1,[r4,#8]
000080  6828              LDR      r0,[r5,#0]
000082  f7fffffe          BL       nrf_uarte_hwfc_pins_set
000086  e029              B        |L2.220|
                  |L2.136|
;;;123        (
;;;124            nrf_uarte_baudrate_set(p_instance->reg.p_uarte, (nrf_uarte_baudrate_t)p_config->baudrate);
;;;125            nrf_uarte_configure(p_instance->reg.p_uarte, (nrf_uarte_parity_t)p_config->parity,
;;;126                                (nrf_uarte_hwfc_t)p_config->hwfc);
;;;127            nrf_uarte_txrx_pins_set(p_instance->reg.p_uarte, p_config->pseltxd, p_config->pselrxd);
;;;128            if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;129            {
;;;130                if (p_config->pselcts != NRF_UART_PSEL_DISCONNECTED)
;;;131                {
;;;132                    nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;133                }
;;;134                if (p_config->pselrts != NRF_UART_PSEL_DISCONNECTED)
;;;135                {
;;;136                    nrf_gpio_pin_set(p_config->pselrts);
;;;137                    nrf_gpio_cfg_output(p_config->pselrts);
;;;138                }
;;;139                nrf_uarte_hwfc_pins_set(p_instance->reg.p_uarte, p_config->pselrts, p_config->pselcts);
;;;140            }
;;;141        )
;;;142        CODE_FOR_UART
000088  6828              LDR      r0,[r5,#0]
00008a  69a1              LDR      r1,[r4,#0x18]
00008c  f8c01524          STR      r1,[r0,#0x524]
000090  bf00              NOP      
000092  7d61              LDRB     r1,[r4,#0x15]
000094  7d22              LDRB     r2,[r4,#0x14]
000096  6828              LDR      r0,[r5,#0]
000098  ea410302          ORR      r3,r1,r2
00009c  f8c0356c          STR      r3,[r0,#0x56c]
0000a0  bf00              NOP      
0000a2  e9d41200          LDRD     r1,r2,[r4,#0]
0000a6  6828              LDR      r0,[r5,#0]
0000a8  f7fffffe          BL       nrf_uart_txrx_pins_set
0000ac  7d20              LDRB     r0,[r4,#0x14]
0000ae  2801              CMP      r0,#1
0000b0  d114              BNE      |L2.220|
0000b2  68a0              LDR      r0,[r4,#8]
0000b4  1c40              ADDS     r0,r0,#1
0000b6  b118              CBZ      r0,|L2.192|
0000b8  2100              MOVS     r1,#0
0000ba  68a0              LDR      r0,[r4,#8]
0000bc  f7fffffe          BL       nrf_gpio_cfg_input
                  |L2.192|
0000c0  68e0              LDR      r0,[r4,#0xc]
0000c2  1c40              ADDS     r0,r0,#1
0000c4  b128              CBZ      r0,|L2.210|
0000c6  68e0              LDR      r0,[r4,#0xc]
0000c8  f7fffffe          BL       nrf_gpio_pin_set
0000cc  68e0              LDR      r0,[r4,#0xc]
0000ce  f7fffffe          BL       nrf_gpio_cfg_output
                  |L2.210|
0000d2  e9d42102          LDRD     r2,r1,[r4,#8]
0000d6  6828              LDR      r0,[r5,#0]
0000d8  f7fffffe          BL       nrf_uart_hwfc_pins_set
                  |L2.220|
;;;143        (
;;;144            nrf_uart_baudrate_set(p_instance->reg.p_uart, p_config->baudrate);
;;;145            nrf_uart_configure(p_instance->reg.p_uart, p_config->parity, p_config->hwfc);
;;;146            nrf_uart_txrx_pins_set(p_instance->reg.p_uart, p_config->pseltxd, p_config->pselrxd);
;;;147            if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;148            {
;;;149                if (p_config->pselcts != NRF_UART_PSEL_DISCONNECTED)
;;;150                {
;;;151                    nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;152                }
;;;153                if (p_config->pselrts != NRF_UART_PSEL_DISCONNECTED)
;;;154                {
;;;155                    nrf_gpio_pin_set(p_config->pselrts);
;;;156                    nrf_gpio_cfg_output(p_config->pselrts);
;;;157                }
;;;158                nrf_uart_hwfc_pins_set(p_instance->reg.p_uart, p_config->pselrts, p_config->pselcts);
;;;159            }
;;;160        )
;;;161    }
0000dc  bd70              POP      {r4-r6,pc}
;;;162    
                          ENDP

0000de  0000              DCW      0x0000
                  |L2.224|
                          DCD      m_cb

                          AREA ||i.interrupts_enable||, CODE, READONLY, ALIGN=2

                  interrupts_enable PROC
;;;162    
;;;163    __STATIC_INLINE void interrupts_enable(const nrf_drv_uart_t * p_instance, uint8_t interrupt_priority)
000000  b570              PUSH     {r4-r6,lr}
;;;164    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;165        CODE_FOR_UARTE
000006  7920              LDRB     r0,[r4,#4]
000008  491d              LDR      r1,|L3.128|
00000a  eb011040          ADD      r0,r1,r0,LSL #5
00000e  7f00              LDRB     r0,[r0,#0x1c]
000010  b1f8              CBZ      r0,|L3.82|
000012  f44f7188          MOV      r1,#0x110
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       nrf_uarte_event_clear
00001c  f44f7190          MOV      r1,#0x120
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       nrf_uarte_event_clear
000026  f44f7192          MOV      r1,#0x124
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       nrf_uarte_event_clear
000030  f44f71a2          MOV      r1,#0x144
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       nrf_uarte_event_clear
00003a  4912              LDR      r1,|L3.132|
00003c  6820              LDR      r0,[r4,#0]
00003e  f7fffffe          BL       nrf_uarte_int_enable
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       nrf_drv_get_IRQn
000048  4606              MOV      r6,r0
00004a  4629              MOV      r1,r5
00004c  f7fffffe          BL       nrf_drv_common_irq_enable
000050  e014              B        |L3.124|
                  |L3.82|
;;;166        (
;;;167            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
;;;168            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
;;;169            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
;;;170            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
;;;171            nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ENDRX_MASK |
;;;172                                             NRF_UARTE_INT_ENDTX_MASK |
;;;173                                             NRF_UARTE_INT_ERROR_MASK |
;;;174                                             NRF_UARTE_INT_RXTO_MASK);
;;;175            nrf_drv_common_irq_enable(nrf_drv_get_IRQn((void *)p_instance->reg.p_uarte), interrupt_priority);
;;;176        )
;;;177        CODE_FOR_UART
000052  f44f718e          MOV      r1,#0x11c
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       nrf_uart_event_clear
00005c  f44f71a2          MOV      r1,#0x144
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       nrf_uart_event_clear
000066  4908              LDR      r1,|L3.136|
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       nrf_uart_int_enable
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       nrf_drv_get_IRQn
000074  4606              MOV      r6,r0
000076  4629              MOV      r1,r5
000078  f7fffffe          BL       nrf_drv_common_irq_enable
                  |L3.124|
;;;178        (
;;;179            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY);
;;;180            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
;;;181            nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_TXDRDY |
;;;182                                           NRF_UART_INT_MASK_RXTO);
;;;183            nrf_drv_common_irq_enable(nrf_drv_get_IRQn((void *)p_instance->reg.p_uart), interrupt_priority);
;;;184        )
;;;185    }
00007c  bd70              POP      {r4-r6,pc}
;;;186    
                          ENDP

00007e  0000              DCW      0x0000
                  |L3.128|
                          DCD      m_cb
                  |L3.132|
                          DCD      0x00020310
                  |L3.136|
                          DCD      0x00020080

                          AREA ||i.nrf_drv_common_irq_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_common_irq_disable PROC
;;;299    
;;;300    __STATIC_INLINE void nrf_drv_common_irq_disable(IRQn_Type IRQn)
000000  bf00              NOP      
000002  f000021f          AND      r2,r0,#0x1f
000006  2101              MOVS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  4a03              LDR      r2,|L4.24|
00000c  0943              LSRS     r3,r0,#5
00000e  f8421023          STR      r1,[r2,r3,LSL #2]
000012  bf00              NOP      
;;;301    {
;;;302        NVIC_DisableIRQ(IRQn);
;;;303    }
000014  4770              BX       lr
;;;304    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0xe000e180

                          AREA ||i.nrf_drv_get_IRQn||, CODE, READONLY, ALIGN=1

                  nrf_drv_get_IRQn PROC
;;;314    
;;;315    __STATIC_INLINE IRQn_Type nrf_drv_get_IRQn(void const * const pinst)
000000  4601              MOV      r1,r0
;;;316    {
;;;317        uint8_t ret = (uint8_t)((uint32_t)pinst>>12U);
000002  f3c13207          UBFX     r2,r1,#12,#8
;;;318        return (IRQn_Type) ret;
000006  b250              SXTB     r0,r2
;;;319    }
000008  4770              BX       lr
;;;320    
                          ENDP


                          AREA ||i.nrf_drv_is_in_RAM||, CODE, READONLY, ALIGN=1

                  nrf_drv_is_in_RAM PROC
;;;342    
;;;343    __STATIC_INLINE bool nrf_drv_is_in_RAM(void const * const ptr)
000000  4601              MOV      r1,r0
;;;344    {
;;;345        return ((((uintptr_t)ptr) & 0xE0000000u) == 0x20000000u);
000002  f0014060          AND      r0,r1,#0xe0000000
000006  f1b05f00          CMP      r0,#0x20000000
00000a  d101              BNE      |L6.16|
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;346    }
00000e  4770              BX       lr
                  |L6.16|
000010  2000              MOVS     r0,#0                 ;345
000012  e7fc              B        |L6.14|
;;;347    
                          ENDP


                          AREA ||i.nrf_drv_uart_errorsrc_get||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_errorsrc_get PROC
;;;717    
;;;718    uint32_t nrf_drv_uart_errorsrc_get(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;719    {
000002  4604              MOV      r4,r0
;;;720        uint32_t errsrc;
;;;721        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490d              LDR      r1,|L7.60|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b148              CBZ      r0,|L7.36|
000010  f44f7192          MOV      r1,#0x124
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_uarte_event_clear
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uarte_errorsrc_get_and_clear
000020  4605              MOV      r5,r0
000022  e008              B        |L7.54|
                  |L7.36|
;;;722        (
;;;723            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
;;;724            errsrc = nrf_uarte_errorsrc_get_and_clear(p_instance->reg.p_uarte);
;;;725        )
;;;726        CODE_FOR_UART
000024  f44f7192          MOV      r1,#0x124
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       nrf_uart_event_clear
00002e  6820              LDR      r0,[r4,#0]
000030  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
000034  4605              MOV      r5,r0
                  |L7.54|
;;;727        (
;;;728            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
;;;729            errsrc = nrf_uart_errorsrc_get_and_clear(p_instance->reg.p_uart);
;;;730        )
;;;731        return errsrc;
000036  4628              MOV      r0,r5
;;;732    }
000038  bd70              POP      {r4-r6,pc}
;;;733    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_init PROC
;;;268    
;;;269    ret_code_t nrf_drv_uart_init(const nrf_drv_uart_t * p_instance, nrf_drv_uart_config_t const * p_config,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;270                                 nrf_uart_event_handler_t event_handler)
;;;271    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;272        ASSERT(p_config);
;;;273        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7928              LDRB     r0,[r5,#4]
00000c  491c              LDR      r1,|L8.128|
00000e  eb011440          ADD      r4,r1,r0,LSL #5
;;;274        ret_code_t err_code = NRF_SUCCESS;
000012  f04f0800          MOV      r8,#0
;;;275    
;;;276        if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)
000016  7ee0              LDRB     r0,[r4,#0x1b]
000018  b120              CBZ      r0,|L8.36|
;;;277        {
;;;278            err_code = NRF_ERROR_INVALID_STATE;
00001a  f04f0808          MOV      r8,#8
;;;279            NRF_LOG_ERROR("Init failed. id:%d in wrong state", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;280            return err_code;
00001e  4640              MOV      r0,r8
                  |L8.32|
;;;281        }
;;;282    
;;;283    #if (defined(UARTE_IN_USE) && defined(UART_IN_USE))
;;;284        p_cb->use_easy_dma = p_config->use_easy_dma;
;;;285    #endif
;;;286        apply_config(p_instance, p_config);
;;;287    
;;;288        p_cb->handler = event_handler;
;;;289        p_cb->p_context = p_config->p_context;
;;;290    
;;;291        if (p_cb->handler)
;;;292        {
;;;293            interrupts_enable(p_instance, p_config->interrupt_priority);
;;;294        }
;;;295    
;;;296        uart_enable(p_instance);
;;;297        p_cb->rx_buffer_length = 0;
;;;298        p_cb->rx_secondary_buffer_length = 0;
;;;299        p_cb->tx_buffer_length = 0;
;;;300        p_cb->state = NRF_DRV_STATE_INITIALIZED;
;;;301        p_cb->rx_enabled = false;
;;;302        return err_code;
;;;303    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L8.36|
000024  7f70              LDRB     r0,[r6,#0x1d]         ;284
000026  7720              STRB     r0,[r4,#0x1c]         ;284
000028  4631              MOV      r1,r6                 ;286
00002a  4628              MOV      r0,r5                 ;286
00002c  f7fffffe          BL       apply_config
000030  6067              STR      r7,[r4,#4]            ;288
000032  6930              LDR      r0,[r6,#0x10]         ;289
000034  6020              STR      r0,[r4,#0]            ;289
000036  6860              LDR      r0,[r4,#4]            ;291
000038  b118              CBZ      r0,|L8.66|
00003a  7f31              LDRB     r1,[r6,#0x1c]         ;293
00003c  4628              MOV      r0,r5                 ;293
00003e  f7fffffe          BL       interrupts_enable
                  |L8.66|
000042  bf00              NOP                            ;296
000044  7928              LDRB     r0,[r5,#4]            ;296
000046  490e              LDR      r1,|L8.128|
000048  eb011040          ADD      r0,r1,r0,LSL #5       ;296
00004c  7f00              LDRB     r0,[r0,#0x1c]         ;296
00004e  b128              CBZ      r0,|L8.92|
000050  6828              LDR      r0,[r5,#0]            ;296
000052  2108              MOVS     r1,#8                 ;296
000054  f8c01500          STR      r1,[r0,#0x500]        ;296
000058  bf00              NOP                            ;296
00005a  e005              B        |L8.104|
                  |L8.92|
00005c  6828              LDR      r0,[r5,#0]            ;296
00005e  2104              MOVS     r1,#4                 ;296
000060  f8c01500          STR      r1,[r0,#0x500]        ;296
000064  bf00              NOP                            ;296
000066  bf00              NOP                            ;296
                  |L8.104|
000068  bf00              NOP                            ;296
00006a  2000              MOVS     r0,#0                 ;297
00006c  75e0              STRB     r0,[r4,#0x17]         ;297
00006e  7620              STRB     r0,[r4,#0x18]         ;298
000070  75a0              STRB     r0,[r4,#0x16]         ;299
000072  2001              MOVS     r0,#1                 ;300
000074  76e0              STRB     r0,[r4,#0x1b]         ;300
000076  2000              MOVS     r0,#0                 ;301
000078  76a0              STRB     r0,[r4,#0x1a]         ;301
00007a  4640              MOV      r0,r8                 ;302
00007c  e7d0              B        |L8.32|
;;;304    
                          ENDP

00007e  0000              DCW      0x0000
                  |L8.128|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx PROC
;;;592    
;;;593    ret_code_t nrf_drv_uart_rx(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;594    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;595        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7920              LDRB     r0,[r4,#4]
00000c  4930              LDR      r1,|L9.208|
00000e  eb011540          ADD      r5,r1,r0,LSL #5
;;;596    
;;;597        ASSERT(m_cb[p_instance->drv_inst_idx].state == NRF_DRV_STATE_INITIALIZED);
;;;598        ASSERT(length>0);
;;;599    
;;;600        ret_code_t err_code;
;;;601    
;;;602        CODE_FOR_UARTE
000012  7920              LDRB     r0,[r4,#4]
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  7f00              LDRB     r0,[r0,#0x1c]
00001a  b140              CBZ      r0,|L9.46|
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       nrf_drv_is_in_RAM
000022  b920              CBNZ     r0,|L9.46|
000024  f04f0810          MOV      r8,#0x10
000028  4640              MOV      r0,r8
                  |L9.42|
;;;603        (
;;;604            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;605            // signal error if the are not.
;;;606            if (!nrf_drv_is_in_RAM(p_data))
;;;607            {
;;;608                err_code = NRF_ERROR_INVALID_ADDR;
;;;609                NRF_LOG_ERROR("Id:%d, Easy-DMA buffer not in RAM: %08x",
;;;610                                                           nrf_drv_get_IRQn((void *)p_instance->reg.p_reg), p_data);
;;;611                return err_code;
;;;612            }
;;;613        )
;;;614    
;;;615        bool second_buffer = false;
;;;616    
;;;617        if (p_cb->handler)
;;;618        {
;;;619            CODE_FOR_UARTE
;;;620            (
;;;621                nrf_uarte_int_disable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;622            )
;;;623            CODE_FOR_UART
;;;624            (
;;;625                nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;626            )
;;;627        }
;;;628        if (p_cb->rx_buffer_length != 0)
;;;629        {
;;;630            if (p_cb->rx_secondary_buffer_length != 0)
;;;631            {
;;;632                if (p_cb->handler)
;;;633                {
;;;634                    CODE_FOR_UARTE
;;;635                    (
;;;636                        nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;637                    )
;;;638                    CODE_FOR_UART
;;;639                    (
;;;640                        nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;641                    )
;;;642                }
;;;643                err_code = NRF_ERROR_BUSY;
;;;644                NRF_LOG_WARNING("RX Id:%d, busy", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;645                return err_code;
;;;646            }
;;;647            second_buffer = true;
;;;648        }
;;;649    
;;;650        if (!second_buffer)
;;;651        {
;;;652            p_cb->rx_buffer_length = length;
;;;653            p_cb->p_rx_buffer      = p_data;
;;;654            p_cb->rx_counter       = 0;
;;;655            p_cb->rx_secondary_buffer_length = 0;
;;;656        }
;;;657        else
;;;658        {
;;;659            p_cb->p_rx_secondary_buffer = p_data;
;;;660            p_cb->rx_secondary_buffer_length = length;
;;;661        }
;;;662    
;;;663        NRF_LOG_INFO("RX Id:%d len:%d", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg), length);
;;;664    
;;;665        CODE_FOR_UARTE
;;;666        (
;;;667            return nrf_drv_uart_rx_for_uarte(p_instance, p_data, length, second_buffer);
;;;668        )
;;;669        CODE_FOR_UART
;;;670        (
;;;671            return nrf_drv_uart_rx_for_uart(p_instance, p_data, length, second_buffer);
;;;672        )
;;;673    }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L9.46|
00002e  f04f0900          MOV      r9,#0                 ;615
000032  6868              LDR      r0,[r5,#4]            ;617
000034  b180              CBZ      r0,|L9.88|
000036  7920              LDRB     r0,[r4,#4]            ;619
000038  4925              LDR      r1,|L9.208|
00003a  eb011040          ADD      r0,r1,r0,LSL #5       ;619
00003e  7f00              LDRB     r0,[r0,#0x1c]         ;619
000040  b128              CBZ      r0,|L9.78|
000042  f44f7104          MOV      r1,#0x210             ;619
000046  6820              LDR      r0,[r4,#0]            ;619
000048  f7fffffe          BL       nrf_uarte_int_disable
00004c  e004              B        |L9.88|
                  |L9.78|
00004e  f44f7101          MOV      r1,#0x204             ;623
000052  6820              LDR      r0,[r4,#0]            ;623
000054  f7fffffe          BL       nrf_uart_int_disable
                  |L9.88|
000058  7de8              LDRB     r0,[r5,#0x17]         ;628
00005a  b1d0              CBZ      r0,|L9.146|
00005c  7e28              LDRB     r0,[r5,#0x18]         ;630
00005e  b1b0              CBZ      r0,|L9.142|
000060  6868              LDR      r0,[r5,#4]            ;632
000062  b180              CBZ      r0,|L9.134|
000064  7920              LDRB     r0,[r4,#4]            ;634
000066  491a              LDR      r1,|L9.208|
000068  eb011040          ADD      r0,r1,r0,LSL #5       ;634
00006c  7f00              LDRB     r0,[r0,#0x1c]         ;634
00006e  b128              CBZ      r0,|L9.124|
000070  f44f7104          MOV      r1,#0x210             ;634
000074  6820              LDR      r0,[r4,#0]            ;634
000076  f7fffffe          BL       nrf_uarte_int_enable
00007a  e004              B        |L9.134|
                  |L9.124|
00007c  f44f7101          MOV      r1,#0x204             ;638
000080  6820              LDR      r0,[r4,#0]            ;638
000082  f7fffffe          BL       nrf_uart_int_enable
                  |L9.134|
000086  f04f0811          MOV      r8,#0x11              ;643
00008a  4640              MOV      r0,r8                 ;645
00008c  e7cd              B        |L9.42|
                  |L9.142|
00008e  f04f0901          MOV      r9,#1                 ;647
                  |L9.146|
000092  f1b90f00          CMP      r9,#0                 ;650
000096  d105              BNE      |L9.164|
000098  75ef              STRB     r7,[r5,#0x17]         ;652
00009a  60ee              STR      r6,[r5,#0xc]          ;653
00009c  2000              MOVS     r0,#0                 ;654
00009e  7668              STRB     r0,[r5,#0x19]         ;654
0000a0  7628              STRB     r0,[r5,#0x18]         ;655
0000a2  e001              B        |L9.168|
                  |L9.164|
0000a4  612e              STR      r6,[r5,#0x10]         ;659
0000a6  762f              STRB     r7,[r5,#0x18]         ;660
                  |L9.168|
0000a8  7920              LDRB     r0,[r4,#4]            ;665
0000aa  4909              LDR      r1,|L9.208|
0000ac  eb011040          ADD      r0,r1,r0,LSL #5       ;665
0000b0  7f00              LDRB     r0,[r0,#0x1c]         ;665
0000b2  b130              CBZ      r0,|L9.194|
0000b4  464b              MOV      r3,r9                 ;665
0000b6  463a              MOV      r2,r7                 ;665
0000b8  4631              MOV      r1,r6                 ;665
0000ba  4620              MOV      r0,r4                 ;665
0000bc  f7fffffe          BL       nrf_drv_uart_rx_for_uarte
0000c0  e7b3              B        |L9.42|
                  |L9.194|
0000c2  464b              MOV      r3,r9                 ;669
0000c4  463a              MOV      r2,r7                 ;669
0000c6  4631              MOV      r1,r6                 ;669
0000c8  4620              MOV      r0,r4                 ;669
0000ca  f7fffffe          BL       nrf_drv_uart_rx_for_uart
0000ce  e7ac              B        |L9.42|
;;;674    
                          ENDP

                  |L9.208|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_abort||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_abort PROC
;;;786    
;;;787    void nrf_drv_uart_rx_abort(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;788    {
000002  4604              MOV      r4,r0
;;;789        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490a              LDR      r1,|L10.48|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b120              CBZ      r0,|L10.26|
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uarte_task_trigger
000018  e008              B        |L10.44|
                  |L10.26|
;;;790        (
;;;791            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPRX);
;;;792        )
;;;793        CODE_FOR_UART
00001a  f44f7101          MOV      r1,#0x204
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       nrf_uart_int_disable
000024  2104              MOVS     r1,#4
000026  6820              LDR      r0,[r4,#0]
000028  f7fffffe          BL       nrf_uart_task_trigger
                  |L10.44|
;;;794        (
;;;795            nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;796            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;797        )
;;;798        NRF_LOG_INFO("RX abort Id:%d", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;799    }
00002c  bd10              POP      {r4,pc}
;;;800    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_disable PROC
;;;703    
;;;704    void nrf_drv_uart_rx_disable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;705    {
000002  4604              MOV      r4,r0
;;;706        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;707        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  4908              LDR      r1,|L11.40|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b948              CBNZ     r0,|L11.36|
;;;708        (
;;;709            ASSERT(false);
;;;710        )
;;;711        CODE_FOR_UART
000010  2104              MOVS     r1,#4
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_task_trigger
000018  2000              MOVS     r0,#0
00001a  7921              LDRB     r1,[r4,#4]
00001c  4a02              LDR      r2,|L11.40|
00001e  eb021141          ADD      r1,r2,r1,LSL #5
000022  7688              STRB     r0,[r1,#0x1a]
                  |L11.36|
;;;712        (
;;;713            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;714            m_cb[p_instance->drv_inst_idx].rx_enabled = false;
;;;715        )
;;;716    }
000024  bd10              POP      {r4,pc}
;;;717    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_enable PROC
;;;686    
;;;687    void nrf_drv_uart_rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;688    {
000002  4604              MOV      r4,r0
;;;689        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;690        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  490a              LDR      r1,|L12.48|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b968              CBNZ     r0,|L12.44|
;;;691        (
;;;692            ASSERT(false);
;;;693        )
;;;694        CODE_FOR_UART
000010  7920              LDRB     r0,[r4,#4]
000012  eb011040          ADD      r0,r1,r0,LSL #5
000016  7e80              LDRB     r0,[r0,#0x1a]
000018  b940              CBNZ     r0,|L12.44|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rx_enable
000020  2001              MOVS     r0,#1
000022  7921              LDRB     r1,[r4,#4]
000024  4a02              LDR      r2,|L12.48|
000026  eb021141          ADD      r1,r2,r1,LSL #5
00002a  7688              STRB     r0,[r1,#0x1a]
                  |L12.44|
;;;695        (
;;;696            if (!m_cb[p_instance->drv_inst_idx].rx_enabled)
;;;697            {
;;;698                rx_enable(p_instance);
;;;699                m_cb[p_instance->drv_inst_idx].rx_enabled = true;
;;;700            }
;;;701        )
;;;702    }
00002c  bd10              POP      {r4,pc}
;;;703    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_for_uart PROC
;;;477    
;;;478    __STATIC_INLINE ret_code_t nrf_drv_uart_rx_for_uart(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length, bool second_buffer)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;479    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4699              MOV      r9,r3
;;;480        ret_code_t err_code;
;;;481    
;;;482        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7920              LDRB     r0,[r4,#4]
00000c  492e              LDR      r1,|L13.200|
00000e  eb011540          ADD      r5,r1,r0,LSL #5
;;;483    
;;;484        if ((!p_cb->rx_enabled) && (!second_buffer))
000012  7ea8              LDRB     r0,[r5,#0x1a]
000014  b928              CBNZ     r0,|L13.34|
000016  f1b90f00          CMP      r9,#0
00001a  d102              BNE      |L13.34|
;;;485        {
;;;486            rx_enable(p_instance);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rx_enable
                  |L13.34|
;;;487        }
;;;488    
;;;489        if (p_cb->handler == NULL)
000022  6868              LDR      r0,[r5,#4]
000024  2800              CMP      r0,#0
000026  d146              BNE      |L13.182|
;;;490        {
;;;491            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
000028  f44f71a2          MOV      r1,#0x144
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       nrf_uart_event_clear
;;;492    
;;;493            bool rxrdy;
;;;494            bool rxto;
;;;495            bool error;
;;;496            do
000032  bf00              NOP      
                  |L13.52|
;;;497            {
;;;498                do
000034  bf00              NOP      
                  |L13.54|
;;;499                {
;;;500                    error = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000036  f44f7192          MOV      r1,#0x124
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       nrf_uart_event_check
000040  4680              MOV      r8,r0
;;;501                    rxrdy = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
000042  f44f7184          MOV      r1,#0x108
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       nrf_uart_event_check
00004c  4682              MOV      r10,r0
;;;502                    rxto  = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
00004e  f44f71a2          MOV      r1,#0x144
000052  6820              LDR      r0,[r4,#0]
000054  f7fffffe          BL       nrf_uart_event_check
000058  4606              MOV      r6,r0
;;;503                } while ((!rxrdy) && (!rxto) && (!error));
00005a  f1ba0f00          CMP      r10,#0
00005e  d103              BNE      |L13.104|
000060  b916              CBNZ     r6,|L13.104|
000062  f1b80f00          CMP      r8,#0
000066  d0e6              BEQ      |L13.54|
                  |L13.104|
;;;504    
;;;505                if (error || rxto)
000068  f1b80f00          CMP      r8,#0
00006c  d100              BNE      |L13.112|
00006e  b106              CBZ      r6,|L13.114|
                  |L13.112|
;;;506                {
;;;507                    break;
000070  e007              B        |L13.130|
                  |L13.114|
;;;508                }
;;;509                rx_byte(p_instance->reg.p_uart, p_cb);
000072  4629              MOV      r1,r5
000074  6820              LDR      r0,[r4,#0]
000076  f7fffffe          BL       rx_byte
;;;510            } while (p_cb->rx_buffer_length > p_cb->rx_counter);
00007a  7de8              LDRB     r0,[r5,#0x17]
00007c  7e69              LDRB     r1,[r5,#0x19]
00007e  4288              CMP      r0,r1
000080  dcd8              BGT      |L13.52|
                  |L13.130|
000082  bf00              NOP                            ;507
;;;511    
;;;512            p_cb->rx_buffer_length = 0;
000084  2000              MOVS     r0,#0
000086  75e8              STRB     r0,[r5,#0x17]
;;;513            if (error)
000088  f1b80f00          CMP      r8,#0
00008c  d003              BEQ      |L13.150|
;;;514            {
;;;515                err_code = NRF_ERROR_INTERNAL;
00008e  2703              MOVS     r7,#3
;;;516                NRF_LOG_WARNING("RX Id: %d, transfer error.", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;517                return err_code;
000090  4638              MOV      r0,r7
                  |L13.146|
;;;518            }
;;;519    
;;;520            if (rxto)
;;;521            {
;;;522                NRF_LOG_WARNING("RX Id: %d, aborted.", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;523                err_code = NRF_ERROR_FORBIDDEN;
;;;524                return err_code;
;;;525            }
;;;526    
;;;527            if (p_cb->rx_enabled)
;;;528            {
;;;529                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
;;;530            }
;;;531            else
;;;532            {
;;;533                // Skip stopping RX if driver is forced to be enabled.
;;;534                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;535            }
;;;536        }
;;;537        else
;;;538        {
;;;539            nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;540        }
;;;541        err_code = NRF_SUCCESS;
;;;542        return err_code;
;;;543    }
000092  e8bd9ff0          POP      {r4-r12,pc}
                  |L13.150|
000096  b116              CBZ      r6,|L13.158|
000098  270f              MOVS     r7,#0xf               ;523
00009a  4638              MOV      r0,r7                 ;524
00009c  e7f9              B        |L13.146|
                  |L13.158|
00009e  7ea8              LDRB     r0,[r5,#0x1a]         ;527
0000a0  b120              CBZ      r0,|L13.172|
0000a2  2100              MOVS     r1,#0                 ;529
0000a4  6820              LDR      r0,[r4,#0]            ;529
0000a6  f7fffffe          BL       nrf_uart_task_trigger
0000aa  e003              B        |L13.180|
                  |L13.172|
0000ac  2104              MOVS     r1,#4                 ;534
0000ae  6820              LDR      r0,[r4,#0]            ;534
0000b0  f7fffffe          BL       nrf_uart_task_trigger
                  |L13.180|
0000b4  e004              B        |L13.192|
                  |L13.182|
0000b6  f44f7101          MOV      r1,#0x204             ;539
0000ba  6820              LDR      r0,[r4,#0]            ;539
0000bc  f7fffffe          BL       nrf_uart_int_enable
                  |L13.192|
0000c0  2700              MOVS     r7,#0                 ;541
0000c2  4638              MOV      r0,r7                 ;542
0000c4  e7e5              B        |L13.146|
;;;544    #endif
                          ENDP

0000c6  0000              DCW      0x0000
                  |L13.200|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_for_uarte||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_for_uarte PROC
;;;546    #if defined(UARTE_IN_USE)
;;;547    __STATIC_INLINE ret_code_t nrf_drv_uart_rx_for_uarte(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length, bool second_buffer)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;548    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;549        ret_code_t err_code = NRF_SUCCESS;
00000c  f04f0a00          MOV      r10,#0
;;;550        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
000010  f44f7188          MOV      r1,#0x110
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_uarte_event_clear
;;;551        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
00001a  f44f71a2          MOV      r1,#0x144
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       nrf_uarte_event_clear
;;;552        nrf_uarte_rx_buffer_set(p_instance->reg.p_uarte, p_data, length);
000024  6820              LDR      r0,[r4,#0]
000026  f8c05534          STR      r5,[r0,#0x534]
00002a  f44f61a7          MOV      r1,#0x538
00002e  500e              STR      r6,[r1,r0]
000030  bf00              NOP      
;;;553        if (!second_buffer)
000032  f1b90f00          CMP      r9,#0
000036  d104              BNE      |L14.66|
;;;554        {
;;;555            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STARTRX);
000038  2100              MOVS     r1,#0
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       nrf_uarte_task_trigger
000040  e008              B        |L14.84|
                  |L14.66|
;;;556        }
;;;557        else
;;;558        {
;;;559            nrf_uarte_shorts_enable(p_instance->reg.p_uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
000042  2120              MOVS     r1,#0x20
000044  6820              LDR      r0,[r4,#0]
000046  f8d02200          LDR      r2,[r0,#0x200]
00004a  430a              ORRS     r2,r2,r1
00004c  f8c02200          STR      r2,[r0,#0x200]
000050  bf00              NOP      
000052  bf00              NOP      
                  |L14.84|
;;;560        }
;;;561    
;;;562        if (m_cb[p_instance->drv_inst_idx].handler == NULL)
000054  7920              LDRB     r0,[r4,#4]
000056  491b              LDR      r1,|L14.196|
000058  eb011040          ADD      r0,r1,r0,LSL #5
00005c  6840              LDR      r0,[r0,#4]
00005e  bb48              CBNZ     r0,|L14.180|
;;;563        {
;;;564            bool endrx;
;;;565            bool rxto;
;;;566            bool error;
;;;567            do {
000060  bf00              NOP      
                  |L14.98|
;;;568                endrx  = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
000062  f44f7188          MOV      r1,#0x110
000066  6820              LDR      r0,[r4,#0]
000068  f7fffffe          BL       nrf_uarte_event_check
00006c  4683              MOV      r11,r0
;;;569                rxto   = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_RXTO);
00006e  f44f71a2          MOV      r1,#0x144
000072  6820              LDR      r0,[r4,#0]
000074  f7fffffe          BL       nrf_uarte_event_check
000078  4680              MOV      r8,r0
;;;570                error  = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
00007a  f44f7192          MOV      r1,#0x124
00007e  6820              LDR      r0,[r4,#0]
000080  f7fffffe          BL       nrf_uarte_event_check
000084  4607              MOV      r7,r0
;;;571            }while ((!endrx) && (!rxto) && (!error));
000086  f1bb0f00          CMP      r11,#0
00008a  d104              BNE      |L14.150|
00008c  f1b80f00          CMP      r8,#0
000090  d101              BNE      |L14.150|
000092  2f00              CMP      r7,#0
000094  d0e5              BEQ      |L14.98|
                  |L14.150|
;;;572    
;;;573            m_cb[p_instance->drv_inst_idx].rx_buffer_length = 0;
000096  2000              MOVS     r0,#0
000098  7921              LDRB     r1,[r4,#4]
00009a  4a0a              LDR      r2,|L14.196|
00009c  eb021141          ADD      r1,r2,r1,LSL #5
0000a0  75c8              STRB     r0,[r1,#0x17]
;;;574    
;;;575            if (error)
0000a2  b10f              CBZ      r7,|L14.168|
;;;576            {
;;;577                err_code = NRF_ERROR_INTERNAL;
0000a4  f04f0a03          MOV      r10,#3
                  |L14.168|
;;;578            }
;;;579    
;;;580            if (rxto)
0000a8  f1b80f00          CMP      r8,#0
0000ac  d001              BEQ      |L14.178|
;;;581            {
;;;582                err_code = NRF_ERROR_FORBIDDEN;
0000ae  f04f0a0f          MOV      r10,#0xf
                  |L14.178|
;;;583            }
;;;584        }
0000b2  e004              B        |L14.190|
                  |L14.180|
;;;585        else
;;;586        {
;;;587            nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
0000b4  f44f7104          MOV      r1,#0x210
0000b8  6820              LDR      r0,[r4,#0]
0000ba  f7fffffe          BL       nrf_uarte_int_enable
                  |L14.190|
;;;588        }
;;;589        return err_code;
0000be  4650              MOV      r0,r10
;;;590    }
0000c0  e8bd9ff0          POP      {r4-r12,pc}
;;;591    #endif
                          ENDP

                  |L14.196|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_ready||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_ready PROC
;;;674    
;;;675    bool nrf_drv_uart_rx_ready(nrf_drv_uart_t const * p_instance)
000000  b510              PUSH     {r4,lr}
;;;676    {
000002  4604              MOV      r4,r0
;;;677        CODE_FOR_UARTE
000004  7920              LDRB     r0,[r4,#4]
000006  4908              LDR      r1,|L15.40|
000008  eb011040          ADD      r0,r1,r0,LSL #5
00000c  7f00              LDRB     r0,[r0,#0x1c]
00000e  b128              CBZ      r0,|L15.28|
000010  f44f7188          MOV      r1,#0x110
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_uarte_event_check
                  |L15.26|
;;;678        (
;;;679            return nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDRX);
;;;680        )
;;;681        CODE_FOR_UART
;;;682        (
;;;683            return nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
;;;684        )
;;;685    }
00001a  bd10              POP      {r4,pc}
                  |L15.28|
00001c  f44f7184          MOV      r1,#0x108             ;681
000020  6820              LDR      r0,[r4,#0]            ;681
000022  f7fffffe          BL       nrf_uart_event_check
000026  e7f8              B        |L15.26|
;;;686    
                          ENDP

                  |L15.40|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx PROC
;;;404    
;;;405    ret_code_t nrf_drv_uart_tx(const nrf_drv_uart_t * p_instance, uint8_t const * const p_data, uint8_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;406    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;407        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
00000a  7920              LDRB     r0,[r4,#4]
00000c  4914              LDR      r1,|L16.96|
00000e  eb011640          ADD      r6,r1,r0,LSL #5
;;;408        ASSERT(p_cb->state == NRF_DRV_STATE_INITIALIZED);
;;;409        ASSERT(length>0);
;;;410        ASSERT(p_data);
;;;411    
;;;412        ret_code_t err_code;
;;;413    
;;;414        CODE_FOR_UARTE
000012  7920              LDRB     r0,[r4,#4]
000014  eb011040          ADD      r0,r1,r0,LSL #5
000018  7f00              LDRB     r0,[r0,#0x1c]
00001a  b138              CBZ      r0,|L16.44|
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       nrf_drv_is_in_RAM
000022  b918              CBNZ     r0,|L16.44|
000024  2710              MOVS     r7,#0x10
000026  4638              MOV      r0,r7
                  |L16.40|
;;;415        (
;;;416            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;417            // signal error if the are not.
;;;418            if (!nrf_drv_is_in_RAM(p_data))
;;;419            {
;;;420                err_code = NRF_ERROR_INVALID_ADDR;
;;;421                NRF_LOG_ERROR("Id:%d, Easy-DMA buffer not in RAM: %08x",
;;;422                                               nrf_drv_get_IRQn((void *)p_instance->reg.p_reg), p_data);
;;;423                return err_code;
;;;424            }
;;;425        )
;;;426    
;;;427        if (nrf_drv_uart_tx_in_progress(p_instance))
;;;428        {
;;;429            err_code = NRF_ERROR_BUSY;
;;;430            NRF_LOG_WARNING("Id:%d busy",nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;431            return err_code;
;;;432        }
;;;433        p_cb->tx_buffer_length = length;
;;;434        p_cb->p_tx_buffer      = p_data;
;;;435        p_cb->tx_counter       = 0;
;;;436    
;;;437        NRF_LOG_INFO("TX req id:%d length: %d.", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg), p_cb->tx_buffer_length);
;;;438        NRF_LOG_DEBUG("Tx data:");
;;;439        NRF_LOG_HEXDUMP_DEBUG((uint8_t *)p_cb->p_tx_buffer, p_cb->tx_buffer_length * sizeof(p_cb->p_tx_buffer));
;;;440    
;;;441        CODE_FOR_UARTE
;;;442        (
;;;443            return nrf_drv_uart_tx_for_uarte(p_instance);
;;;444        )
;;;445        CODE_FOR_UART
;;;446        (
;;;447            return nrf_drv_uart_tx_for_uart(p_instance);
;;;448        )
;;;449    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L16.44|
00002c  4620              MOV      r0,r4                 ;427
00002e  f7fffffe          BL       nrf_drv_uart_tx_in_progress
000032  b110              CBZ      r0,|L16.58|
000034  2711              MOVS     r7,#0x11              ;429
000036  4638              MOV      r0,r7                 ;431
000038  e7f6              B        |L16.40|
                  |L16.58|
00003a  f8868016          STRB     r8,[r6,#0x16]         ;433
00003e  60b5              STR      r5,[r6,#8]            ;434
000040  2000              MOVS     r0,#0                 ;435
000042  82b0              STRH     r0,[r6,#0x14]         ;435
000044  7920              LDRB     r0,[r4,#4]            ;441
000046  4906              LDR      r1,|L16.96|
000048  eb011040          ADD      r0,r1,r0,LSL #5       ;441
00004c  7f00              LDRB     r0,[r0,#0x1c]         ;441
00004e  b118              CBZ      r0,|L16.88|
000050  4620              MOV      r0,r4                 ;441
000052  f7fffffe          BL       nrf_drv_uart_tx_for_uarte
000056  e7e7              B        |L16.40|
                  |L16.88|
000058  4620              MOV      r0,r4                 ;445
00005a  f7fffffe          BL       nrf_drv_uart_tx_for_uart
00005e  e7e3              B        |L16.40|
;;;450    
                          ENDP

                  |L16.96|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_abort||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_abort PROC
;;;758    
;;;759    void nrf_drv_uart_tx_abort(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;760    {
000002  4604              MOV      r4,r0
;;;761        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  4916              LDR      r1,|L17.96|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;762    
;;;763        CODE_FOR_UARTE
00000c  7920              LDRB     r0,[r4,#4]
00000e  eb011040          ADD      r0,r1,r0,LSL #5
000012  7f00              LDRB     r0,[r0,#0x1c]
000014  b198              CBZ      r0,|L17.62|
000016  f44f71ac          MOV      r1,#0x158
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uarte_event_clear
000020  210c              MOVS     r1,#0xc
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       nrf_uarte_task_trigger
000028  6868              LDR      r0,[r5,#4]
00002a  b9b8              CBNZ     r0,|L17.92|
00002c  bf00              NOP      
                  |L17.46|
00002e  f44f71ac          MOV      r1,#0x158
000032  6820              LDR      r0,[r4,#0]
000034  f7fffffe          BL       nrf_uarte_event_check
000038  2800              CMP      r0,#0
00003a  d0f8              BEQ      |L17.46|
00003c  e00e              B        |L17.92|
                  |L17.62|
;;;764        (
;;;765            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
;;;766            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPTX);
;;;767            if (p_cb->handler == NULL)
;;;768            {
;;;769                while (!nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED));
;;;770            }
;;;771        )
;;;772        CODE_FOR_UART
00003e  210c              MOVS     r1,#0xc
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       nrf_uart_task_trigger
000046  6868              LDR      r0,[r5,#4]
000048  b128              CBZ      r0,|L17.86|
00004a  8aa8              LDRH     r0,[r5,#0x14]
00004c  b2c1              UXTB     r1,r0
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       tx_done_event
000054  e002              B        |L17.92|
                  |L17.86|
000056  f44f7080          MOV      r0,#0x100
00005a  82a8              STRH     r0,[r5,#0x14]
                  |L17.92|
;;;773        (
;;;774            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
;;;775            if (p_cb->handler)
;;;776            {
;;;777                tx_done_event(p_cb, p_cb->tx_counter);
;;;778            }
;;;779            else
;;;780            {
;;;781                p_cb->tx_counter       = TX_COUNTER_ABORT_REQ_VALUE;
;;;782            }
;;;783        )
;;;784        NRF_LOG_INFO("TX abort Id:%d", nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;785    }
00005c  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

00005e  0000              DCW      0x0000
                  |L17.96|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_for_uart PROC
;;;331    
;;;332    __STATIC_INLINE ret_code_t nrf_drv_uart_tx_for_uart(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  4920              LDR      r1,|L18.136|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;335        ret_code_t err_code = NRF_SUCCESS;
00000c  2600              MOVS     r6,#0
;;;336    
;;;337        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY);
00000e  f44f718e          MOV      r1,#0x11c
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_event_clear
;;;338        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTTX);
000018  2108              MOVS     r1,#8
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uart_task_trigger
;;;339    
;;;340        tx_byte(p_instance->reg.p_uart, p_cb);
000020  4629              MOV      r1,r5
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       tx_byte
;;;341    
;;;342        if (p_cb->handler == NULL)
000028  6868              LDR      r0,[r5,#4]
00002a  bb58              CBNZ     r0,|L18.132|
;;;343        {
;;;344            while (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
00002c  e012              B        |L18.84|
                  |L18.46|
;;;345            {
;;;346                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY) &&
00002e  bf00              NOP      
                  |L18.48|
000030  f44f718e          MOV      r1,#0x11c
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       nrf_uart_event_check
00003a  b918              CBNZ     r0,|L18.68|
;;;347                        p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
00003c  8aa8              LDRH     r0,[r5,#0x14]
00003e  f5b07f80          CMP      r0,#0x100
000042  d1f5              BNE      |L18.48|
                  |L18.68|
;;;348                {
;;;349                }
;;;350                if (p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
000044  8aa8              LDRH     r0,[r5,#0x14]
000046  f5b07f80          CMP      r0,#0x100
00004a  d003              BEQ      |L18.84|
;;;351                {
;;;352                    tx_byte(p_instance->reg.p_uart, p_cb);
00004c  4629              MOV      r1,r5
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       tx_byte
                  |L18.84|
000054  8aa8              LDRH     r0,[r5,#0x14]         ;344
000056  7da9              LDRB     r1,[r5,#0x16]         ;344
000058  4288              CMP      r0,r1                 ;344
00005a  dbe8              BLT      |L18.46|
;;;353                }
;;;354            }
;;;355    
;;;356            if (p_cb->tx_counter == TX_COUNTER_ABORT_REQ_VALUE)
00005c  8aa8              LDRH     r0,[r5,#0x14]
00005e  f5b07f80          CMP      r0,#0x100
000062  d101              BNE      |L18.104|
;;;357            {
;;;358                err_code = NRF_ERROR_FORBIDDEN;
000064  260f              MOVS     r6,#0xf
000066  e00b              B        |L18.128|
                  |L18.104|
;;;359            }
;;;360            else
;;;361            {
;;;362                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY))
000068  bf00              NOP      
                  |L18.106|
00006a  f44f718e          MOV      r1,#0x11c
00006e  6820              LDR      r0,[r4,#0]
000070  f7fffffe          BL       nrf_uart_event_check
000074  2800              CMP      r0,#0
000076  d0f8              BEQ      |L18.106|
;;;363                {
;;;364                }
;;;365                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
000078  210c              MOVS     r1,#0xc
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       nrf_uart_task_trigger
                  |L18.128|
;;;366            }
;;;367            p_cb->tx_buffer_length = 0;
000080  2000              MOVS     r0,#0
000082  75a8              STRB     r0,[r5,#0x16]
                  |L18.132|
;;;368        }
;;;369        return err_code;
000084  4630              MOV      r0,r6
;;;370    }
000086  bd70              POP      {r4-r6,pc}
;;;371    #endif
                          ENDP

                  |L18.136|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_for_uarte||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_for_uarte PROC
;;;373    #if defined(UARTE_IN_USE)
;;;374    __STATIC_INLINE ret_code_t nrf_drv_uart_tx_for_uarte(const nrf_drv_uart_t * p_instance)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;375    {
000004  4604              MOV      r4,r0
;;;376        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000006  7920              LDRB     r0,[r4,#4]
000008  491b              LDR      r1,|L19.120|
00000a  eb011540          ADD      r5,r1,r0,LSL #5
;;;377        ret_code_t err_code = NRF_SUCCESS;
00000e  f04f0800          MOV      r8,#0
;;;378    
;;;379        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
000012  f44f7190          MOV      r1,#0x120
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       nrf_uarte_event_clear
;;;380        nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
00001c  f44f71ac          MOV      r1,#0x158
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       nrf_uarte_event_clear
;;;381        nrf_uarte_tx_buffer_set(p_instance->reg.p_uarte, p_cb->p_tx_buffer, p_cb->tx_buffer_length);
000026  6820              LDR      r0,[r4,#0]
000028  7daa              LDRB     r2,[r5,#0x16]
00002a  68a9              LDR      r1,[r5,#8]
00002c  f8c01544          STR      r1,[r0,#0x544]
000030  f44f63a9          MOV      r3,#0x548
000034  501a              STR      r2,[r3,r0]
000036  bf00              NOP      
;;;382        nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STARTTX);
000038  2108              MOVS     r1,#8
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       nrf_uarte_task_trigger
;;;383    
;;;384        if (p_cb->handler == NULL)
000040  6868              LDR      r0,[r5,#4]
000042  b9a8              CBNZ     r0,|L19.112|
;;;385        {
;;;386            bool endtx;
;;;387            bool txstopped;
;;;388            do
000044  bf00              NOP      
                  |L19.70|
;;;389            {
;;;390                endtx     = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ENDTX);
000046  f44f7190          MOV      r1,#0x120
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       nrf_uarte_event_check
000050  4607              MOV      r7,r0
;;;391                txstopped = nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
000052  f44f71ac          MOV      r1,#0x158
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       nrf_uarte_event_check
00005c  4606              MOV      r6,r0
;;;392            }
;;;393            while ((!endtx) && (!txstopped));
00005e  b90f              CBNZ     r7,|L19.100|
000060  2e00              CMP      r6,#0
000062  d0f0              BEQ      |L19.70|
                  |L19.100|
;;;394    
;;;395            if (txstopped)
000064  b10e              CBZ      r6,|L19.106|
;;;396            {
;;;397                err_code = NRF_ERROR_FORBIDDEN;
000066  f04f080f          MOV      r8,#0xf
                  |L19.106|
;;;398            }
;;;399            p_cb->tx_buffer_length = 0;
00006a  2000              MOVS     r0,#0
00006c  75a8              STRB     r0,[r5,#0x16]
;;;400        }
00006e  bf00              NOP      
                  |L19.112|
;;;401        return err_code;
000070  4640              MOV      r0,r8
;;;402    }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;403    #endif
                          ENDP

000076  0000              DCW      0x0000
                  |L19.120|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_in_progress||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_in_progress PROC
;;;450    
;;;451    bool nrf_drv_uart_tx_in_progress(const nrf_drv_uart_t * p_instance)
000000  4601              MOV      r1,r0
;;;452    {
;;;453        return (m_cb[p_instance->drv_inst_idx].tx_buffer_length != 0);
000002  7908              LDRB     r0,[r1,#4]
000004  4a04              LDR      r2,|L20.24|
000006  eb021040          ADD      r0,r2,r0,LSL #5
00000a  7d80              LDRB     r0,[r0,#0x16]
00000c  b108              CBZ      r0,|L20.18|
00000e  2001              MOVS     r0,#1
                  |L20.16|
;;;454    }
000010  4770              BX       lr
                  |L20.18|
000012  2000              MOVS     r0,#0                 ;453
000014  e7fc              B        |L20.16|
;;;455    
                          ENDP

000016  0000              DCW      0x0000
                  |L20.24|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_uninit PROC
;;;304    
;;;305    void nrf_drv_uart_uninit(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;306    {
000002  4604              MOV      r4,r0
;;;307        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  491f              LDR      r1,|L21.132|
000008  eb011540          ADD      r5,r1,r0,LSL #5
;;;308    
;;;309        uart_disable(p_instance);
00000c  bf00              NOP      
00000e  7920              LDRB     r0,[r4,#4]
000010  eb011040          ADD      r0,r1,r0,LSL #5
000014  7f00              LDRB     r0,[r0,#0x1c]
000016  b128              CBZ      r0,|L21.36|
000018  6820              LDR      r0,[r4,#0]
00001a  2100              MOVS     r1,#0
00001c  f8c01500          STR      r1,[r0,#0x500]
000020  bf00              NOP      
000022  e005              B        |L21.48|
                  |L21.36|
000024  6820              LDR      r0,[r4,#0]
000026  2100              MOVS     r1,#0
000028  f8c01500          STR      r1,[r0,#0x500]
00002c  bf00              NOP      
00002e  bf00              NOP      
                  |L21.48|
000030  bf00              NOP      
;;;310    
;;;311        if (p_cb->handler)
000032  6868              LDR      r0,[r5,#4]
000034  b1f0              CBZ      r0,|L21.116|
;;;312        {
;;;313            interrupts_disable(p_instance);
000036  bf00              NOP      
000038  7920              LDRB     r0,[r4,#4]
00003a  4912              LDR      r1,|L21.132|
00003c  eb011040          ADD      r0,r1,r0,LSL #5
000040  7f00              LDRB     r0,[r0,#0x1c]
000042  b150              CBZ      r0,|L21.90|
000044  4910              LDR      r1,|L21.136|
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       nrf_uarte_int_disable
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       nrf_drv_get_IRQn
000052  4606              MOV      r6,r0
000054  f7fffffe          BL       nrf_drv_common_irq_disable
000058  e00a              B        |L21.112|
                  |L21.90|
00005a  490b              LDR      r1,|L21.136|
00005c  398c              SUBS     r1,r1,#0x8c
00005e  6820              LDR      r0,[r4,#0]
000060  f7fffffe          BL       nrf_uart_int_disable
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       nrf_drv_get_IRQn
00006a  4606              MOV      r6,r0
00006c  f7fffffe          BL       nrf_drv_common_irq_disable
                  |L21.112|
000070  bf00              NOP      
000072  bf00              NOP      
                  |L21.116|
;;;314        }
;;;315    
;;;316        pins_to_default(p_instance);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       pins_to_default
;;;317    
;;;318        p_cb->state = NRF_DRV_STATE_UNINITIALIZED;
00007a  2000              MOVS     r0,#0
00007c  76e8              STRB     r0,[r5,#0x1b]
;;;319        p_cb->handler = NULL;
00007e  6068              STR      r0,[r5,#4]
;;;320        NRF_LOG_INFO("Uninit id: %d.",  nrf_drv_get_IRQn((void *)p_instance->reg.p_reg));
;;;321    }
000080  bd70              POP      {r4-r6,pc}
;;;322    
                          ENDP

000082  0000              DCW      0x0000
                  |L21.132|
                          DCD      m_cb
                  |L21.136|
                          DCD      0x00020310

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg PROC
;;;503    
;;;504    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;505        uint32_t             pin_number,
;;;506        nrf_gpio_pin_dir_t   dir,
;;;507        nrf_gpio_pin_input_t input,
;;;508        nrf_gpio_pin_pull_t  pull,
;;;509        nrf_gpio_pin_drive_t drive,
;;;510        nrf_gpio_pin_sense_t sense)
;;;511    {
000002  e9dd4505          LDRD     r4,r5,[sp,#0x14]
;;;512        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  bf00              NOP      
000008  f04f47a0          MOV      r7,#0x50000000
00000c  463e              MOV      r6,r7
;;;513    
;;;514        reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
00000e  ea410742          ORR      r7,r1,r2,LSL #1
000012  ea470783          ORR      r7,r7,r3,LSL #2
000016  ea472704          ORR      r7,r7,r4,LSL #8
00001a  ea474c05          ORR      r12,r7,r5,LSL #16
00001e  f50667e0          ADD      r7,r6,#0x700
000022  f847c020          STR      r12,[r7,r0,LSL #2]
;;;515                                   | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;516                                   | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
;;;517                                   | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;518                                   | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;519    }
000026  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;545    
;;;546    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;547    {
000002  4604              MOV      r4,r0
;;;548        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;549            pin_number,
;;;550            NRF_GPIO_PIN_DIR_INPUT,
;;;551            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;552            NRF_GPIO_PIN_NOPULL,
;;;553            NRF_GPIO_PIN_S0S1,
;;;554            NRF_GPIO_PIN_NOSENSE);
;;;555    }
000016  bd1c              POP      {r2-r4,pc}
;;;556    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_input||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_input PROC
;;;533    
;;;534    __STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
000000  b57c              PUSH     {r2-r6,lr}
;;;535    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;536        nrf_gpio_cfg(
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  4623              MOV      r3,r4
00000c  4602              MOV      r2,r0
00000e  4601              MOV      r1,r0
000010  9001              STR      r0,[sp,#4]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       nrf_gpio_cfg
;;;537            pin_number,
;;;538            NRF_GPIO_PIN_DIR_INPUT,
;;;539            NRF_GPIO_PIN_INPUT_CONNECT,
;;;540            pull_config,
;;;541            NRF_GPIO_PIN_S0S1,
;;;542            NRF_GPIO_PIN_NOSENSE);
;;;543    }
000018  bd7c              POP      {r2-r6,pc}
;;;544    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_output||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_output PROC
;;;521    
;;;522    __STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4611              MOV      r1,r2
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;525            pin_number,
;;;526            NRF_GPIO_PIN_DIR_OUTPUT,
;;;527            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;528            NRF_GPIO_PIN_NOPULL,
;;;529            NRF_GPIO_PIN_S0S1,
;;;530            NRF_GPIO_PIN_NOSENSE);
;;;531    }
000016  bd1c              POP      {r2-r4,pc}
;;;532    
                          ENDP


                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_set PROC
;;;621    
;;;622    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  bf00              NOP      
000002  f04f41a0          MOV      r1,#0x50000000
;;;623    {
;;;624        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;625    
;;;626        nrf_gpio_port_out_set(reg, 1UL << pin_number);
000008  2301              MOVS     r3,#1
00000a  fa03f100          LSL      r1,r3,r0
00000e  f8c21508          STR      r1,[r2,#0x508]
000012  bf00              NOP      
;;;627    }
000014  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.nrf_uart_errorsrc_get_and_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_errorsrc_get_and_clear PROC
;;;418    
;;;419    __STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
000000  4601              MOV      r1,r0
;;;420    {
;;;421        uint32_t errsrc_mask = p_reg->ERRORSRC;
000002  f8d10480          LDR      r0,[r1,#0x480]
;;;422        p_reg->ERRORSRC = errsrc_mask;
000006  f8c10480          STR      r0,[r1,#0x480]
;;;423        return errsrc_mask;
;;;424    }
00000a  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.nrf_uart_event_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_check PROC
;;;392    
;;;393    __STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  4602              MOV      r2,r0
;;;394    {
;;;395        return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
000002  5850              LDR      r0,[r2,r1]
000004  b108              CBZ      r0,|L28.10|
000006  2001              MOVS     r0,#1
                  |L28.8|
;;;396    }
000008  4770              BX       lr
                  |L28.10|
00000a  2000              MOVS     r0,#0                 ;395
00000c  e7fc              B        |L28.8|
;;;397    
                          ENDP


                          AREA ||i.nrf_uart_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_clear PROC
;;;382    #ifndef SUPPRESS_INLINE_IMPLEMENTATION
;;;383    __STATIC_INLINE void nrf_uart_event_clear(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  b508              PUSH     {r3,lr}
;;;384    {
;;;385        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
000002  2200              MOVS     r2,#0
000004  5042              STR      r2,[r0,r1]
;;;386    #if __CORTEX_M == 0x04
;;;387        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
000006  5842              LDR      r2,[r0,r1]
000008  9200              STR      r2,[sp,#0]
;;;388        (void)dummy;
00000a  bf00              NOP      
;;;389    #endif
;;;390    
;;;391    }
00000c  bd08              POP      {r3,pc}
;;;392    
                          ENDP


                          AREA ||i.nrf_uart_hwfc_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_hwfc_pins_set PROC
;;;490    
;;;491    __STATIC_INLINE void nrf_uart_hwfc_pins_set(NRF_UART_Type * p_reg, uint32_t pselrts, uint32_t pselcts)
000000  f8c01508          STR      r1,[r0,#0x508]
;;;492    {
;;;493    #if defined(UART_PSEL_RTS_CONNECT_Pos)
;;;494        p_reg->PSEL.RTS = pselrts;
;;;495    #else
;;;496        p_reg->PSELRTS = pselrts;
;;;497    #endif
;;;498    
;;;499    #if defined(UART_PSEL_RTS_CONNECT_Pos)
;;;500        p_reg->PSEL.CTS = pselcts;
;;;501    #else
;;;502        p_reg->PSELCTS = pselcts;
000004  f8c02510          STR      r2,[r0,#0x510]
;;;503    #endif
;;;504    }
000008  4770              BX       lr
;;;505    
                          ENDP


                          AREA ||i.nrf_uart_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_disable PROC
;;;413    
;;;414    __STATIC_INLINE void nrf_uart_int_disable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  f8c01308          STR      r1,[r0,#0x308]
;;;415    {
;;;416        p_reg->INTENCLR = int_mask;
;;;417    }
000004  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.nrf_uart_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable PROC
;;;403    
;;;404    __STATIC_INLINE void nrf_uart_int_enable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  f8c01304          STR      r1,[r0,#0x304]
;;;405    {
;;;406        p_reg->INTENSET = int_mask;
;;;407    }
000004  4770              BX       lr
;;;408    
                          ENDP


                          AREA ||i.nrf_uart_int_enable_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable_check PROC
;;;408    
;;;409    __STATIC_INLINE bool nrf_uart_int_enable_check(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  4602              MOV      r2,r0
;;;410    {
;;;411        return (bool)(p_reg->INTENSET & int_mask);
000002  f8d20304          LDR      r0,[r2,#0x304]
000006  4008              ANDS     r0,r0,r1
000008  b108              CBZ      r0,|L33.14|
00000a  2001              MOVS     r0,#1
                  |L33.12|
;;;412    }
00000c  4770              BX       lr
                  |L33.14|
00000e  2000              MOVS     r0,#0                 ;411
000010  e7fc              B        |L33.12|
;;;413    
                          ENDP


                          AREA ||i.nrf_uart_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_uart_task_trigger PROC
;;;520    
;;;521    __STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
000000  2201              MOVS     r2,#1
;;;522    {
;;;523        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
000002  5042              STR      r2,[r0,r1]
;;;524    }
000004  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.nrf_uart_txrx_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_txrx_pins_set PROC
;;;435    
;;;436    __STATIC_INLINE void nrf_uart_txrx_pins_set(NRF_UART_Type * p_reg, uint32_t pseltxd, uint32_t pselrxd)
000000  f8c02514          STR      r2,[r0,#0x514]
;;;437    {
;;;438    #if defined(UART_PSEL_RXD_CONNECT_Pos)
;;;439        p_reg->PSEL.RXD = pselrxd;
;;;440    #else
;;;441        p_reg->PSELRXD = pselrxd;
;;;442    #endif
;;;443    #if defined(UART_PSEL_TXD_CONNECT_Pos)
;;;444        p_reg->PSEL.TXD = pseltxd;
;;;445    #else
;;;446        p_reg->PSELTXD = pseltxd;
000004  f8c0150c          STR      r1,[r0,#0x50c]
;;;447    #endif
;;;448    }
000008  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.nrf_uarte_errorsrc_get_and_clear||, CODE, READONLY, ALIGN=1

                  nrf_uarte_errorsrc_get_and_clear PROC
;;;494    
;;;495    __STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg)
000000  4601              MOV      r1,r0
;;;496    {
;;;497        uint32_t errsrc_mask = p_reg->ERRORSRC;
000002  f8d10480          LDR      r0,[r1,#0x480]
;;;498        p_reg->ERRORSRC = errsrc_mask;
000006  f8c10480          STR      r0,[r1,#0x480]
;;;499        return errsrc_mask;
;;;500    }
00000a  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.nrf_uarte_event_check||, CODE, READONLY, ALIGN=1

                  nrf_uarte_event_check PROC
;;;458    
;;;459    __STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
000000  4602              MOV      r2,r0
;;;460    {
;;;461        return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
000002  5850              LDR      r0,[r2,r1]
000004  b108              CBZ      r0,|L37.10|
000006  2001              MOVS     r0,#1
                  |L37.8|
;;;462    }
000008  4770              BX       lr
                  |L37.10|
00000a  2000              MOVS     r0,#0                 ;461
00000c  e7fc              B        |L37.8|
;;;463    
                          ENDP


                          AREA ||i.nrf_uarte_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_uarte_event_clear PROC
;;;448    #ifndef SUPPRESS_INLINE_IMPLEMENTATION
;;;449    __STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
000000  b508              PUSH     {r3,lr}
;;;450    {
;;;451        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
000002  2200              MOVS     r2,#0
000004  5042              STR      r2,[r0,r1]
;;;452    #if __CORTEX_M == 0x04
;;;453        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
000006  5842              LDR      r2,[r0,r1]
000008  9200              STR      r2,[sp,#0]
;;;454        (void)dummy;
00000a  bf00              NOP      
;;;455    #endif
;;;456    
;;;457    }
00000c  bd08              POP      {r3,pc}
;;;458    
                          ENDP


                          AREA ||i.nrf_uarte_hwfc_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uarte_hwfc_pins_set PROC
;;;542    
;;;543    __STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg, uint32_t pselrts, uint32_t pselcts)
000000  f8c01508          STR      r1,[r0,#0x508]
;;;544    {
;;;545        p_reg->PSEL.RTS = pselrts;
;;;546        p_reg->PSEL.CTS = pselcts;
000004  f44f63a2          MOV      r3,#0x510
000008  501a              STR      r2,[r3,r0]
;;;547    }
00000a  4770              BX       lr
;;;548    
                          ENDP


                          AREA ||i.nrf_uarte_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_uarte_int_disable PROC
;;;489    
;;;490    __STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t int_mask)
000000  f8c01308          STR      r1,[r0,#0x308]
;;;491    {
;;;492        p_reg->INTENCLR = int_mask;
;;;493    }
000004  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.nrf_uarte_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_uarte_int_enable PROC
;;;479    
;;;480    __STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t int_mask)
000000  f8c01304          STR      r1,[r0,#0x304]
;;;481    {
;;;482        p_reg->INTENSET = int_mask;
;;;483    }
000004  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.nrf_uarte_rx_amount_get||, CODE, READONLY, ALIGN=1

                  nrf_uarte_rx_amount_get PROC
;;;596    
;;;597    __STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type * p_reg)
000000  4601              MOV      r1,r0
;;;598    {
;;;599        return p_reg->RXD.AMOUNT;
000002  f240503c          MOV      r0,#0x53c
000006  5840              LDR      r0,[r0,r1]
;;;600    }
000008  4770              BX       lr
;;;601    #endif //SUPPRESS_INLINE_IMPLEMENTATION
                          ENDP


                          AREA ||i.nrf_uarte_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_uarte_task_trigger PROC
;;;553    
;;;554    __STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task)
000000  2201              MOVS     r2,#1
;;;555    {
;;;556        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
000002  5042              STR      r2,[r0,r1]
;;;557    }
000004  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.nrf_uarte_txrx_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uarte_txrx_pins_set PROC
;;;511    
;;;512    __STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg, uint32_t pseltxd, uint32_t pselrxd)
000000  f240530c          MOV      r3,#0x50c
;;;513    {
;;;514        p_reg->PSEL.TXD = pseltxd;
000004  5019              STR      r1,[r3,r0]
;;;515        p_reg->PSEL.RXD = pselrxd;
000006  f2405314          MOV      r3,#0x514
00000a  501a              STR      r2,[r3,r0]
;;;516    }
00000c  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.pins_to_default||, CODE, READONLY, ALIGN=2

                  pins_to_default PROC
;;;207    
;;;208    __STATIC_INLINE void pins_to_default(const nrf_drv_uart_t * p_instance)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;209    {
000004  4604              MOV      r4,r0
;;;210        /* Reset pins to default states */
;;;211        uint32_t txd;
;;;212        uint32_t rxd;
;;;213        uint32_t rts;
;;;214        uint32_t cts;
;;;215    
;;;216        CODE_FOR_UARTE
000006  7920              LDRB     r0,[r4,#4]
000008  4931              LDR      r1,|L45.208|
00000a  eb011040          ADD      r0,r1,r0,LSL #5
00000e  7f00              LDRB     r0,[r0,#0x1c]
000010  b320              CBZ      r0,|L45.92|
000012  6820              LDR      r0,[r4,#0]
000014  f240510c          MOV      r1,#0x50c
000018  580d              LDR      r5,[r1,r0]
00001a  bf00              NOP      
00001c  6820              LDR      r0,[r4,#0]
00001e  f2405114          MOV      r1,#0x514
000022  580e              LDR      r6,[r1,r0]
000024  bf00              NOP      
000026  6820              LDR      r0,[r4,#0]
000028  f8d07508          LDR      r7,[r0,#0x508]
00002c  bf00              NOP      
00002e  6820              LDR      r0,[r4,#0]
000030  f8d08510          LDR      r8,[r0,#0x510]
000034  bf00              NOP      
000036  f8d49000          LDR      r9,[r4,#0]
00003a  f04f32ff          MOV      r2,#0xffffffff
00003e  4611              MOV      r1,r2
000040  4648              MOV      r0,r9
000042  f7fffffe          BL       nrf_uarte_txrx_pins_set
000046  bf00              NOP      
000048  f8d49000          LDR      r9,[r4,#0]
00004c  f04f32ff          MOV      r2,#0xffffffff
000050  4611              MOV      r1,r2
000052  4648              MOV      r0,r9
000054  f7fffffe          BL       nrf_uarte_hwfc_pins_set
000058  bf00              NOP      
00005a  e022              B        |L45.162|
                  |L45.92|
;;;217        (
;;;218            txd = nrf_uarte_tx_pin_get(p_instance->reg.p_uarte);
;;;219            rxd = nrf_uarte_rx_pin_get(p_instance->reg.p_uarte);
;;;220            rts = nrf_uarte_rts_pin_get(p_instance->reg.p_uarte);
;;;221            cts = nrf_uarte_cts_pin_get(p_instance->reg.p_uarte);
;;;222            nrf_uarte_txrx_pins_disconnect(p_instance->reg.p_uarte);
;;;223            nrf_uarte_hwfc_pins_disconnect(p_instance->reg.p_uarte);
;;;224        )
;;;225        CODE_FOR_UART
00005c  6820              LDR      r0,[r4,#0]
00005e  f8d0550c          LDR      r5,[r0,#0x50c]
000062  bf00              NOP      
000064  6820              LDR      r0,[r4,#0]
000066  f8d06514          LDR      r6,[r0,#0x514]
00006a  bf00              NOP      
00006c  6820              LDR      r0,[r4,#0]
00006e  f8d07508          LDR      r7,[r0,#0x508]
000072  bf00              NOP      
000074  6820              LDR      r0,[r4,#0]
000076  f8d08510          LDR      r8,[r0,#0x510]
00007a  bf00              NOP      
00007c  f8d49000          LDR      r9,[r4,#0]
000080  f04f32ff          MOV      r2,#0xffffffff
000084  4611              MOV      r1,r2
000086  4648              MOV      r0,r9
000088  f7fffffe          BL       nrf_uart_txrx_pins_set
00008c  bf00              NOP      
00008e  f8d49000          LDR      r9,[r4,#0]
000092  f04f32ff          MOV      r2,#0xffffffff
000096  4611              MOV      r1,r2
000098  4648              MOV      r0,r9
00009a  f7fffffe          BL       nrf_uart_hwfc_pins_set
00009e  bf00              NOP      
0000a0  bf00              NOP      
                  |L45.162|
;;;226        (
;;;227            txd = nrf_uart_tx_pin_get(p_instance->reg.p_uart);
;;;228            rxd = nrf_uart_rx_pin_get(p_instance->reg.p_uart);
;;;229            rts = nrf_uart_rts_pin_get(p_instance->reg.p_uart);
;;;230            cts = nrf_uart_cts_pin_get(p_instance->reg.p_uart);
;;;231            nrf_uart_txrx_pins_disconnect(p_instance->reg.p_uart);
;;;232            nrf_uart_hwfc_pins_disconnect(p_instance->reg.p_uart);
;;;233        )
;;;234    
;;;235        if (txd != NRF_UART_PSEL_DISCONNECTED)
0000a2  1c68              ADDS     r0,r5,#1
0000a4  b110              CBZ      r0,|L45.172|
;;;236        {
;;;237            nrf_gpio_cfg_default(txd);
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       nrf_gpio_cfg_default
                  |L45.172|
;;;238        }
;;;239    
;;;240        if (rxd != NRF_UART_PSEL_DISCONNECTED)
0000ac  1c70              ADDS     r0,r6,#1
0000ae  b110              CBZ      r0,|L45.182|
;;;241        {
;;;242            nrf_gpio_cfg_default(rxd);
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       nrf_gpio_cfg_default
                  |L45.182|
;;;243        }
;;;244    
;;;245        if (cts != NRF_UART_PSEL_DISCONNECTED)
0000b6  f1080001          ADD      r0,r8,#1
0000ba  b110              CBZ      r0,|L45.194|
;;;246        {
;;;247            nrf_gpio_cfg_default(cts);
0000bc  4640              MOV      r0,r8
0000be  f7fffffe          BL       nrf_gpio_cfg_default
                  |L45.194|
;;;248        }
;;;249    
;;;250        if (rts != NRF_UART_PSEL_DISCONNECTED)
0000c2  1c78              ADDS     r0,r7,#1
0000c4  b110              CBZ      r0,|L45.204|
;;;251        {
;;;252            nrf_gpio_cfg_default(rts);
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       nrf_gpio_cfg_default
                  |L45.204|
;;;253        }
;;;254    
;;;255    }
0000cc  e8bd87f0          POP      {r4-r10,pc}
;;;256    
                          ENDP

                  |L45.208|
                          DCD      m_cb

                          AREA ||i.rx_byte||, CODE, READONLY, ALIGN=1

                  rx_byte PROC
;;;463    
;;;464    __STATIC_INLINE void rx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;465    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;466        if (!p_cb->rx_buffer_length)
000006  7de0              LDRB     r0,[r4,#0x17]
000008  b940              CBNZ     r0,|L46.28|
;;;467        {
;;;468            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
00000a  f44f7184          MOV      r1,#0x108
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       nrf_uart_event_clear
;;;469            // Byte received when buffer is not set - data lost.
;;;470            (void) nrf_uart_rxd_get(p_uart);
000014  bf00              NOP      
000016  f8d50518          LDR      r0,[r5,#0x518]
                  |L46.26|
;;;471            return;
;;;472        }
;;;473        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
;;;474        p_cb->p_rx_buffer[p_cb->rx_counter] = nrf_uart_rxd_get(p_uart);
;;;475        p_cb->rx_counter++;
;;;476    }
00001a  bd70              POP      {r4-r6,pc}
                  |L46.28|
00001c  f44f7184          MOV      r1,#0x108             ;473
000020  4628              MOV      r0,r5                 ;473
000022  f7fffffe          BL       nrf_uart_event_clear
000026  bf00              NOP                            ;474
000028  f8d50518          LDR      r0,[r5,#0x518]        ;474
00002c  b2c0              UXTB     r0,r0                 ;474
00002e  7e62              LDRB     r2,[r4,#0x19]         ;474
000030  68e1              LDR      r1,[r4,#0xc]          ;474
000032  5488              STRB     r0,[r1,r2]            ;474
000034  7e60              LDRB     r0,[r4,#0x19]         ;475
000036  1c40              ADDS     r0,r0,#1              ;475
000038  7660              STRB     r0,[r4,#0x19]         ;475
00003a  bf00              NOP      
00003c  e7ed              B        |L46.26|
;;;477    
                          ENDP


                          AREA ||i.rx_done_event||, CODE, READONLY, ALIGN=1

                  rx_done_event PROC
;;;733    
;;;734    __STATIC_INLINE void rx_done_event(uart_control_block_t * p_cb, uint8_t bytes, uint8_t * p_data)
000000  b57f              PUSH     {r0-r6,lr}
;;;735    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;736        nrf_drv_uart_event_t event;
;;;737    
;;;738        event.type             = NRF_DRV_UART_EVT_RX_DONE;
000008  2001              MOVS     r0,#1
00000a  f88d0000          STRB     r0,[sp,#0]
;;;739        event.data.rxtx.bytes  = bytes;
00000e  f88d5008          STRB     r5,[sp,#8]
;;;740        event.data.rxtx.p_data = p_data;
000012  9601              STR      r6,[sp,#4]
;;;741    
;;;742        p_cb->handler(&event, p_cb->p_context);
000014  4668              MOV      r0,sp
000016  e9d41200          LDRD     r1,r2,[r4,#0]
00001a  4790              BLX      r2
;;;743    }
00001c  bd7f              POP      {r0-r6,pc}
;;;744    
                          ENDP


                          AREA ||i.rx_enable||, CODE, READONLY, ALIGN=1

                  rx_enable PROC
;;;456    #if defined(UART_IN_USE)
;;;457    __STATIC_INLINE void rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;458    {
000002  4604              MOV      r4,r0
;;;459        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000004  f44f7192          MOV      r1,#0x124
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       nrf_uart_event_clear
;;;460        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
00000e  f44f7184          MOV      r1,#0x108
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_event_clear
;;;461        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
000018  2100              MOVS     r1,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uart_task_trigger
;;;462    }
000020  bd10              POP      {r4,pc}
;;;463    
                          ENDP


                          AREA ||i.tx_byte||, CODE, READONLY, ALIGN=1

                  tx_byte PROC
;;;323    #if defined(UART_IN_USE)
;;;324    __STATIC_INLINE void tx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;326        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
000006  f44f718e          MOV      r1,#0x11c
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       nrf_uart_event_clear
;;;327        uint8_t txd = p_cb->p_tx_buffer[p_cb->tx_counter];
000010  8aa1              LDRH     r1,[r4,#0x14]
000012  68a0              LDR      r0,[r4,#8]
000014  5c46              LDRB     r6,[r0,r1]
;;;328        p_cb->tx_counter++;
000016  8aa0              LDRH     r0,[r4,#0x14]
000018  1c40              ADDS     r0,r0,#1
00001a  82a0              STRH     r0,[r4,#0x14]
;;;329        nrf_uart_txd_set(p_uart, txd);
00001c  4630              MOV      r0,r6
00001e  f8c5051c          STR      r0,[r5,#0x51c]
000022  bf00              NOP      
;;;330    }
000024  bd70              POP      {r4-r6,pc}
;;;331    
                          ENDP


                          AREA ||i.tx_done_event||, CODE, READONLY, ALIGN=1

                  tx_done_event PROC
;;;744    
;;;745    __STATIC_INLINE void tx_done_event(uart_control_block_t * p_cb, uint8_t bytes)
000000  b57f              PUSH     {r0-r6,lr}
;;;746    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;747        nrf_drv_uart_event_t event;
;;;748    
;;;749        event.type             = NRF_DRV_UART_EVT_TX_DONE;
000006  2000              MOVS     r0,#0
000008  f88d0000          STRB     r0,[sp,#0]
;;;750        event.data.rxtx.bytes  = bytes;
00000c  f88d5008          STRB     r5,[sp,#8]
;;;751        event.data.rxtx.p_data = (uint8_t *)p_cb->p_tx_buffer;
000010  68a0              LDR      r0,[r4,#8]
000012  9001              STR      r0,[sp,#4]
;;;752    
;;;753        p_cb->tx_buffer_length = 0;
000014  2000              MOVS     r0,#0
000016  75a0              STRB     r0,[r4,#0x16]
;;;754    
;;;755        NRF_LOG_INFO("TX done len:%d", bytes);
;;;756        p_cb->handler(&event, p_cb->p_context);
000018  4668              MOV      r0,sp
00001a  e9d41200          LDRD     r1,r2,[r4,#0]
00001e  4790              BLX      r2
;;;757    }
000020  bd7f              POP      {r0-r6,pc}
;;;758    
                          ENDP


                          AREA ||i.uart_irq_handler||, CODE, READONLY, ALIGN=1

                  uart_irq_handler PROC
;;;802    #if defined(UART_IN_USE)
;;;803    __STATIC_INLINE void uart_irq_handler(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;804    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;805        if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_ERROR) &&
000008  f44f7100          MOV      r1,#0x200
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       nrf_uart_int_enable_check
000012  b348              CBZ      r0,|L51.104|
;;;806            nrf_uart_event_check(p_uart, NRF_UART_EVENT_ERROR))
000014  f44f7192          MOV      r1,#0x124
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       nrf_uart_event_check
00001e  b318              CBZ      r0,|L51.104|
;;;807        {
;;;808            nrf_drv_uart_event_t event;
;;;809            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_ERROR);
000020  f44f7192          MOV      r1,#0x124
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       nrf_uart_event_clear
;;;810            nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
00002a  f44f7101          MOV      r1,#0x204
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       nrf_uart_int_disable
;;;811            if (!p_cb->rx_enabled)
000034  7ea0              LDRB     r0,[r4,#0x1a]
000036  b918              CBNZ     r0,|L51.64|
;;;812            {
;;;813                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
000038  2104              MOVS     r1,#4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       nrf_uart_task_trigger
                  |L51.64|
;;;814            }
;;;815            event.type                   = NRF_DRV_UART_EVT_ERROR;
000040  2002              MOVS     r0,#2
000042  f88d0000          STRB     r0,[sp,#0]
;;;816            event.data.error.error_mask  = nrf_uart_errorsrc_get_and_clear(p_uart);
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
00004c  9003              STR      r0,[sp,#0xc]
;;;817            event.data.error.rxtx.bytes  = p_cb->rx_buffer_length;
00004e  7de1              LDRB     r1,[r4,#0x17]
000050  f88d1008          STRB     r1,[sp,#8]
;;;818            event.data.error.rxtx.p_data = p_cb->p_rx_buffer;
000054  68e0              LDR      r0,[r4,#0xc]
000056  9001              STR      r0,[sp,#4]
;;;819    
;;;820            //abort transfer
;;;821            p_cb->rx_buffer_length = 0;
000058  2000              MOVS     r0,#0
00005a  75e0              STRB     r0,[r4,#0x17]
;;;822            p_cb->rx_secondary_buffer_length = 0;
00005c  7620              STRB     r0,[r4,#0x18]
;;;823    
;;;824            p_cb->handler(&event,p_cb->p_context);
00005e  4668              MOV      r0,sp
000060  e9d41200          LDRD     r1,r2,[r4,#0]
000064  4790              BLX      r2
;;;825        }
000066  e036              B        |L51.214|
                  |L51.104|
;;;826        else if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_RXDRDY) &&
000068  2104              MOVS     r1,#4
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       nrf_uart_int_enable_check
000070  2800              CMP      r0,#0
000072  d030              BEQ      |L51.214|
;;;827                 nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXDRDY))
000074  f44f7184          MOV      r1,#0x108
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       nrf_uart_event_check
00007e  b350              CBZ      r0,|L51.214|
;;;828        {
;;;829            rx_byte(p_uart, p_cb);
000080  4621              MOV      r1,r4
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       rx_byte
;;;830            if (p_cb->rx_buffer_length == p_cb->rx_counter)
000088  7de0              LDRB     r0,[r4,#0x17]
00008a  7e61              LDRB     r1,[r4,#0x19]
00008c  4288              CMP      r0,r1
00008e  d122              BNE      |L51.214|
;;;831            {
;;;832                if (p_cb->rx_secondary_buffer_length)
000090  7e20              LDRB     r0,[r4,#0x18]
000092  b170              CBZ      r0,|L51.178|
;;;833                {
;;;834                    uint8_t * p_data     = p_cb->p_rx_buffer;
000094  68e6              LDR      r6,[r4,#0xc]
;;;835                    uint8_t   rx_counter = p_cb->rx_counter;
000096  7e67              LDRB     r7,[r4,#0x19]
;;;836    
;;;837                    //Switch to secondary buffer.
;;;838                    p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
000098  7e20              LDRB     r0,[r4,#0x18]
00009a  75e0              STRB     r0,[r4,#0x17]
;;;839                    p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
00009c  6920              LDR      r0,[r4,#0x10]
00009e  60e0              STR      r0,[r4,#0xc]
;;;840                    p_cb->rx_secondary_buffer_length = 0;
0000a0  2000              MOVS     r0,#0
0000a2  7620              STRB     r0,[r4,#0x18]
;;;841                    p_cb->rx_counter = 0;
0000a4  7660              STRB     r0,[r4,#0x19]
;;;842                    rx_done_event(p_cb, rx_counter, p_data);
0000a6  4632              MOV      r2,r6
0000a8  4639              MOV      r1,r7
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       rx_done_event
;;;843                }
0000b0  e011              B        |L51.214|
                  |L51.178|
;;;844                else
;;;845                {
;;;846                    if (!p_cb->rx_enabled)
0000b2  7ea0              LDRB     r0,[r4,#0x1a]
0000b4  b918              CBNZ     r0,|L51.190|
;;;847                    {
;;;848                        nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
0000b6  2104              MOVS     r1,#4
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       nrf_uart_task_trigger
                  |L51.190|
;;;849                    }
;;;850                    nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
0000be  f44f7101          MOV      r1,#0x204
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       nrf_uart_int_disable
;;;851                    p_cb->rx_buffer_length = 0;
0000c8  2000              MOVS     r0,#0
0000ca  75e0              STRB     r0,[r4,#0x17]
;;;852                    rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
0000cc  7e61              LDRB     r1,[r4,#0x19]
0000ce  68e2              LDR      r2,[r4,#0xc]
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       rx_done_event
                  |L51.214|
;;;853                }
;;;854            }
;;;855        }
;;;856    
;;;857        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_TXDRDY))
0000d6  f44f718e          MOV      r1,#0x11c
0000da  4628              MOV      r0,r5
0000dc  f7fffffe          BL       nrf_uart_event_check
0000e0  b198              CBZ      r0,|L51.266|
;;;858        {
;;;859            if (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
0000e2  8aa0              LDRH     r0,[r4,#0x14]
0000e4  7da1              LDRB     r1,[r4,#0x16]
0000e6  4288              CMP      r0,r1
0000e8  da04              BGE      |L51.244|
;;;860            {
;;;861                tx_byte(p_uart, p_cb);
0000ea  4621              MOV      r1,r4
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       tx_byte
0000f2  e00a              B        |L51.266|
                  |L51.244|
;;;862            }
;;;863            else
;;;864            {
;;;865                nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
0000f4  f44f718e          MOV      r1,#0x11c
0000f8  4628              MOV      r0,r5
0000fa  f7fffffe          BL       nrf_uart_event_clear
;;;866                if (p_cb->tx_buffer_length)
0000fe  7da0              LDRB     r0,[r4,#0x16]
000100  b118              CBZ      r0,|L51.266|
;;;867                {
;;;868                    tx_done_event(p_cb, p_cb->tx_buffer_length);
000102  7da1              LDRB     r1,[r4,#0x16]
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       tx_done_event
                  |L51.266|
;;;869                }
;;;870            }
;;;871        }
;;;872    
;;;873        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXTO))
00010a  f44f71a2          MOV      r1,#0x144
00010e  4628              MOV      r0,r5
000110  f7fffffe          BL       nrf_uart_event_check
000114  b198              CBZ      r0,|L51.318|
;;;874        {
;;;875            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXTO);
000116  f44f71a2          MOV      r1,#0x144
00011a  4628              MOV      r0,r5
00011c  f7fffffe          BL       nrf_uart_event_clear
;;;876    
;;;877            // RXTO event may be triggered as a result of abort call. In th
;;;878            if (p_cb->rx_enabled)
000120  7ea0              LDRB     r0,[r4,#0x1a]
000122  b118              CBZ      r0,|L51.300|
;;;879            {
;;;880                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STARTRX);
000124  2100              MOVS     r1,#0
000126  4628              MOV      r0,r5
000128  f7fffffe          BL       nrf_uart_task_trigger
                  |L51.300|
;;;881            }
;;;882            if (p_cb->rx_buffer_length)
00012c  7de0              LDRB     r0,[r4,#0x17]
00012e  b130              CBZ      r0,|L51.318|
;;;883            {
;;;884                p_cb->rx_buffer_length = 0;
000130  2000              MOVS     r0,#0
000132  75e0              STRB     r0,[r4,#0x17]
;;;885                rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
000134  7e61              LDRB     r1,[r4,#0x19]
000136  68e2              LDR      r2,[r4,#0xc]
000138  4620              MOV      r0,r4
00013a  f7fffffe          BL       rx_done_event
                  |L51.318|
;;;886            }
;;;887        }
;;;888    }
00013e  e8bd81ff          POP      {r0-r8,pc}
;;;889    #endif
                          ENDP


                          AREA ||i.uarte_irq_handler||, CODE, READONLY, ALIGN=1

                  uarte_irq_handler PROC
;;;891    #if defined(UARTE_IN_USE)
;;;892    __STATIC_INLINE void uarte_irq_handler(NRF_UARTE_Type * p_uarte, uart_control_block_t * p_cb)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;893    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;894        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ERROR))
000008  f44f7192          MOV      r1,#0x124
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       nrf_uarte_event_check
000012  b1d8              CBZ      r0,|L52.76|
;;;895        {
;;;896            nrf_drv_uart_event_t event;
;;;897    
;;;898            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ERROR);
000014  f44f7192          MOV      r1,#0x124
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       nrf_uarte_event_clear
;;;899    
;;;900            event.type                   = NRF_DRV_UART_EVT_ERROR;
00001e  2002              MOVS     r0,#2
000020  f88d0000          STRB     r0,[sp,#0]
;;;901            event.data.error.error_mask  = nrf_uarte_errorsrc_get_and_clear(p_uarte);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       nrf_uarte_errorsrc_get_and_clear
00002a  9003              STR      r0,[sp,#0xc]
;;;902            event.data.error.rxtx.bytes  = nrf_uarte_rx_amount_get(p_uarte);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       nrf_uarte_rx_amount_get
000032  b2c1              UXTB     r1,r0
000034  f88d1008          STRB     r1,[sp,#8]
;;;903            event.data.error.rxtx.p_data = p_cb->p_rx_buffer;
000038  68e0              LDR      r0,[r4,#0xc]
00003a  9001              STR      r0,[sp,#4]
;;;904    
;;;905            //abort transfer
;;;906            p_cb->rx_buffer_length = 0;
00003c  2000              MOVS     r0,#0
00003e  75e0              STRB     r0,[r4,#0x17]
;;;907            p_cb->rx_secondary_buffer_length = 0;
000040  7620              STRB     r0,[r4,#0x18]
;;;908    
;;;909            p_cb->handler(&event, p_cb->p_context);
000042  4668              MOV      r0,sp
000044  e9d41200          LDRD     r1,r2,[r4,#0]
000048  4790              BLX      r2
;;;910        }
00004a  e02f              B        |L52.172|
                  |L52.76|
;;;911        else if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ENDRX))
00004c  f44f7188          MOV      r1,#0x110
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       nrf_uarte_event_check
000056  b348              CBZ      r0,|L52.172|
;;;912        {
;;;913            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ENDRX);
000058  f44f7188          MOV      r1,#0x110
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       nrf_uarte_event_clear
;;;914            uint8_t amount = nrf_uarte_rx_amount_get(p_uarte);
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       nrf_uarte_rx_amount_get
000068  b2c6              UXTB     r6,r0
;;;915            // If the transfer was stopped before completion, amount of transfered bytes
;;;916            // will not be equal to the buffer length. Interrupted trunsfer is ignored.
;;;917            if (amount == p_cb->rx_buffer_length)
00006a  7de0              LDRB     r0,[r4,#0x17]
00006c  42b0              CMP      r0,r6
00006e  d11c              BNE      |L52.170|
;;;918            {
;;;919                if (p_cb->rx_secondary_buffer_length)
000070  7e20              LDRB     r0,[r4,#0x18]
000072  b198              CBZ      r0,|L52.156|
;;;920                {
;;;921                    uint8_t * p_data = p_cb->p_rx_buffer;
000074  68e7              LDR      r7,[r4,#0xc]
;;;922                    nrf_uarte_shorts_disable(p_uarte, NRF_UARTE_SHORT_ENDRX_STARTRX);
000076  2020              MOVS     r0,#0x20
000078  f8d51200          LDR      r1,[r5,#0x200]
00007c  4381              BICS     r1,r1,r0
00007e  f8c51200          STR      r1,[r5,#0x200]
000082  bf00              NOP      
;;;923                    p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
000084  7e20              LDRB     r0,[r4,#0x18]
000086  75e0              STRB     r0,[r4,#0x17]
;;;924                    p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
000088  6920              LDR      r0,[r4,#0x10]
00008a  60e0              STR      r0,[r4,#0xc]
;;;925                    p_cb->rx_secondary_buffer_length = 0;
00008c  2000              MOVS     r0,#0
00008e  7620              STRB     r0,[r4,#0x18]
;;;926                    rx_done_event(p_cb, amount, p_data);
000090  463a              MOV      r2,r7
000092  4631              MOV      r1,r6
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       rx_done_event
;;;927                }
00009a  e006              B        |L52.170|
                  |L52.156|
;;;928                else
;;;929                {
;;;930                    p_cb->rx_buffer_length = 0;
00009c  2000              MOVS     r0,#0
00009e  75e0              STRB     r0,[r4,#0x17]
;;;931                    rx_done_event(p_cb, amount, p_cb->p_rx_buffer);
0000a0  4631              MOV      r1,r6
0000a2  4620              MOV      r0,r4
0000a4  68e2              LDR      r2,[r4,#0xc]
0000a6  f7fffffe          BL       rx_done_event
                  |L52.170|
;;;932                }
;;;933            }
;;;934        }
0000aa  bf00              NOP      
                  |L52.172|
;;;935    
;;;936        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_RXTO))
0000ac  f44f71a2          MOV      r1,#0x144
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       nrf_uarte_event_check
0000b6  b188              CBZ      r0,|L52.220|
;;;937        {
;;;938            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_RXTO);
0000b8  f44f71a2          MOV      r1,#0x144
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       nrf_uarte_event_clear
;;;939            if (p_cb->rx_buffer_length)
0000c2  7de0              LDRB     r0,[r4,#0x17]
0000c4  b150              CBZ      r0,|L52.220|
;;;940            {
;;;941                p_cb->rx_buffer_length = 0;
0000c6  2000              MOVS     r0,#0
0000c8  75e0              STRB     r0,[r4,#0x17]
;;;942                rx_done_event(p_cb, nrf_uarte_rx_amount_get(p_uarte), p_cb->p_rx_buffer);
0000ca  4628              MOV      r0,r5
0000cc  f7fffffe          BL       nrf_uarte_rx_amount_get
0000d0  b2c6              UXTB     r6,r0
0000d2  4631              MOV      r1,r6
0000d4  4620              MOV      r0,r4
0000d6  68e2              LDR      r2,[r4,#0xc]
0000d8  f7fffffe          BL       rx_done_event
                  |L52.220|
;;;943            }
;;;944        }
;;;945    
;;;946        if (nrf_uarte_event_check(p_uarte, NRF_UARTE_EVENT_ENDTX))
0000dc  f44f7190          MOV      r1,#0x120
0000e0  4628              MOV      r0,r5
0000e2  f7fffffe          BL       nrf_uarte_event_check
0000e6  b178              CBZ      r0,|L52.264|
;;;947        {
;;;948            nrf_uarte_event_clear(p_uarte, NRF_UARTE_EVENT_ENDTX);
0000e8  f44f7190          MOV      r1,#0x120
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       nrf_uarte_event_clear
;;;949            if (p_cb->tx_buffer_length)
0000f2  7da0              LDRB     r0,[r4,#0x16]
0000f4  b140              CBZ      r0,|L52.264|
;;;950            {
;;;951                tx_done_event(p_cb, nrf_uarte_tx_amount_get(p_uarte));
0000f6  bf00              NOP      
0000f8  f240504c          MOV      r0,#0x54c
0000fc  5940              LDR      r0,[r0,r5]
0000fe  b2c6              UXTB     r6,r0
000100  4631              MOV      r1,r6
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       tx_done_event
                  |L52.264|
;;;952            }
;;;953        }
;;;954    }
000108  e8bd81ff          POP      {r0-r8,pc}
;;;955    #endif
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        32

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=2

000000  75617274          DCB      0x75,0x61,0x72,0x74
000004  00                DCB      0x00

                          AREA log_const_data, DATA, READONLY, ALIGN=2

                  m_nrf_log_uart_logs_data_const
                  ||__tagsym$$used||
                          DCD      ||.conststrlit||
000004  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA log_dynamic_data, DATA, ALIGN=2

                  m_nrf_log_uart_logs_data_dynamic
                  |symbol_number.398|
                          %        12

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\uart\\nrf_drv_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_c9ceabb4____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_nrf_drv_uart_c_c9ceabb4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_c9ceabb4____REVSH|
#line 402
|__asm___14_nrf_drv_uart_c_c9ceabb4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_c9ceabb4____RRX|
#line 587
|__asm___14_nrf_drv_uart_c_c9ceabb4____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
