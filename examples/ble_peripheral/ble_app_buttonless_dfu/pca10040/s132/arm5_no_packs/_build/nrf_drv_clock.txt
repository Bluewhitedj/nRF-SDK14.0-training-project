; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_drv_clock.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_drv_clock.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_drv_clock.crf ..\..\..\..\..\..\components\drivers_nrf\clock\nrf_drv_clock.c]
                          THUMB

                          AREA ||i.POWER_CLOCK_IRQHandler||, CODE, READONLY, ALIGN=2

                  POWER_CLOCK_IRQHandler PROC
;;;511    #else
;;;512    void POWER_CLOCK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;513    #endif
;;;514    {
;;;515        if (nrf_clock_event_check(NRF_CLOCK_EVENT_HFCLKSTARTED))
000002  f44f7080          MOV      r0,#0x100
000006  f7fffffe          BL       nrf_clock_event_check
00000a  b160              CBZ      r0,|L1.38|
;;;516        {
;;;517            nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
00000c  f44f7080          MOV      r0,#0x100
000010  f7fffffe          BL       nrf_clock_event_clear
;;;518            NRF_LOG_DEBUG("Event: %s.", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_HFCLKSTARTED));
;;;519            nrf_clock_int_disable(NRF_CLOCK_INT_HF_STARTED_MASK);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       nrf_clock_int_disable
;;;520            m_clock_cb.hfclk_on = true;
00001a  2001              MOVS     r0,#1
00001c  490b              LDR      r1,|L1.76|
00001e  7048              STRB     r0,[r1,#1]
;;;521            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       clock_clk_started_notify
                  |L1.38|
;;;522        }
;;;523        if (nrf_clock_event_check(NRF_CLOCK_EVENT_LFCLKSTARTED))
000026  f44f7082          MOV      r0,#0x104
00002a  f7fffffe          BL       nrf_clock_event_check
00002e  b158              CBZ      r0,|L1.72|
;;;524        {
;;;525            nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000030  f44f7082          MOV      r0,#0x104
000034  f7fffffe          BL       nrf_clock_event_clear
;;;526            NRF_LOG_DEBUG("Event: %s.", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_LFCLKSTARTED));
;;;527            nrf_clock_int_disable(NRF_CLOCK_INT_LF_STARTED_MASK);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       nrf_clock_int_disable
;;;528            m_clock_cb.lfclk_on = true;
00003e  2001              MOVS     r0,#1
000040  4902              LDR      r1,|L1.76|
000042  7088              STRB     r0,[r1,#2]
;;;529            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
000044  f7fffffe          BL       clock_clk_started_notify
                  |L1.72|
;;;530        }
;;;531    #if CALIBRATION_SUPPORT
;;;532        if (nrf_clock_event_check(NRF_CLOCK_EVENT_CTTO))
;;;533        {
;;;534            nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;535            NRF_LOG_DEBUG("Event: %s.", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_CTTO));
;;;536            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;537            nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;538        }
;;;539    
;;;540        if (nrf_clock_event_check(NRF_CLOCK_EVENT_DONE))
;;;541        {
;;;542            nrf_clock_event_clear(NRF_CLOCK_EVENT_DONE);
;;;543            NRF_LOG_DEBUG("Event: %s.", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_DONE));
;;;544            nrf_clock_int_disable(NRF_CLOCK_INT_DONE_MASK);
;;;545            nrf_drv_clock_hfclk_release();
;;;546            bool aborted = (m_clock_cb.cal_state == CAL_STATE_ABORT);
;;;547            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;548            if (m_clock_cb.cal_done_handler)
;;;549            {
;;;550                m_clock_cb.cal_done_handler(aborted ?
;;;551                    NRF_DRV_CLOCK_EVT_CAL_ABORTED : NRF_DRV_CLOCK_EVT_CAL_DONE);
;;;552            }
;;;553        }
;;;554    #endif // CALIBRATION_SUPPORT
;;;555    }
000048  bd10              POP      {r4,pc}
;;;556    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      m_clock_cb

                          AREA ||i.clock_clk_started_notify||, CODE, READONLY, ALIGN=2

                  clock_clk_started_notify PROC
;;;484    
;;;485    __STATIC_INLINE void clock_clk_started_notify(nrf_drv_clock_evt_type_t evt_type)
000000  b570              PUSH     {r4-r6,lr}
;;;486    {
000002  4605              MOV      r5,r0
;;;487        nrf_drv_clock_handler_item_t **p_head;
;;;488        if (evt_type == NRF_DRV_CLOCK_EVT_HFCLK_STARTED)
000004  b90d              CBNZ     r5,|L2.10|
;;;489        {
;;;490            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head;
000006  4c09              LDR      r4,|L2.44|
000008  e001              B        |L2.14|
                  |L2.10|
;;;491        }
;;;492        else
;;;493        {
;;;494            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head;
00000a  4c08              LDR      r4,|L2.44|
00000c  3408              ADDS     r4,r4,#8
                  |L2.14|
;;;495        }
;;;496    
;;;497        while (1)
00000e  e009              B        |L2.36|
                  |L2.16|
;;;498        {
;;;499            nrf_drv_clock_handler_item_t * p_item = item_dequeue(p_head);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       item_dequeue
000016  4606              MOV      r6,r0
;;;500            if (!p_item)
000018  b906              CBNZ     r6,|L2.28|
;;;501            {
;;;502                break;
00001a  e004              B        |L2.38|
                  |L2.28|
;;;503            }
;;;504    
;;;505            p_item->event_handler(evt_type);
00001c  4628              MOV      r0,r5
00001e  6871              LDR      r1,[r6,#4]
000020  4788              BLX      r1
;;;506        }
000022  bf00              NOP      
                  |L2.36|
000024  e7f4              B        |L2.16|
                  |L2.38|
000026  bf00              NOP                            ;502
;;;507    }
000028  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      m_clock_cb+0x8

                          AREA ||i.hfclk_start||, CODE, READONLY, ALIGN=1

                  hfclk_start PROC
;;;140    
;;;141    static void hfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    #ifdef SOFTDEVICE_PRESENT
;;;144        if (nrf_sdh_is_enabled())
000002  f7fffffe          BL       nrf_sdh_is_enabled
000006  b108              CBZ      r0,|L3.12|
;;;145        {
;;;146            (void)sd_clock_hfclk_request();
000008  df3f              SVC      #0x3f
                  |L3.10|
;;;147            return;
;;;148        }
;;;149    #endif // SOFTDEVICE_PRESENT
;;;150    
;;;151        nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
;;;152        nrf_clock_int_enable(NRF_CLOCK_INT_HF_STARTED_MASK);
;;;153        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTART);
;;;154    }
00000a  bd10              POP      {r4,pc}
                  |L3.12|
00000c  f44f7080          MOV      r0,#0x100             ;151
000010  f7fffffe          BL       nrf_clock_event_clear
000014  2001              MOVS     r0,#1                 ;152
000016  f7fffffe          BL       nrf_clock_int_enable
00001a  2000              MOVS     r0,#0                 ;153
00001c  f7fffffe          BL       nrf_clock_task_trigger
000020  bf00              NOP      
000022  e7f2              B        |L3.10|
;;;155    
                          ENDP


                          AREA ||i.hfclk_stop||, CODE, READONLY, ALIGN=2

                  hfclk_stop PROC
;;;155    
;;;156    static void hfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158    #ifdef SOFTDEVICE_PRESENT
;;;159        if (nrf_sdh_is_enabled())
000002  f7fffffe          BL       nrf_sdh_is_enabled
000006  b108              CBZ      r0,|L4.12|
;;;160        {
;;;161            (void)sd_clock_hfclk_release();
000008  df40              SVC      #0x40
                  |L4.10|
;;;162            return;
;;;163        }
;;;164    #endif // SOFTDEVICE_PRESENT
;;;165    
;;;166        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTOP);
;;;167        while (nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY))
;;;168        {}
;;;169        m_clock_cb.hfclk_on = false;
;;;170    }
00000a  bd10              POP      {r4,pc}
                  |L4.12|
00000c  2004              MOVS     r0,#4                 ;166
00000e  f7fffffe          BL       nrf_clock_task_trigger
000012  bf00              NOP                            ;167
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;167
000016  f7fffffe          BL       nrf_clock_hf_is_running
00001a  2800              CMP      r0,#0                 ;167
00001c  d1fa              BNE      |L4.20|
00001e  4902              LDR      r1,|L4.40|
000020  7048              STRB     r0,[r1,#1]            ;169
000022  bf00              NOP      
000024  e7f1              B        |L4.10|
;;;171    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      m_clock_cb

                          AREA ||i.item_dequeue||, CODE, READONLY, ALIGN=1

                  item_dequeue PROC
;;;238    
;;;239    static nrf_drv_clock_handler_item_t * item_dequeue(nrf_drv_clock_handler_item_t ** p_head)
000000  4601              MOV      r1,r0
;;;240    {
;;;241        nrf_drv_clock_handler_item_t * p_item = *p_head;
000002  6808              LDR      r0,[r1,#0]
;;;242        if (p_item)
000004  b108              CBZ      r0,|L5.10|
;;;243        {
;;;244            *p_head = p_item->p_next;
000006  6802              LDR      r2,[r0,#0]
000008  600a              STR      r2,[r1,#0]
                  |L5.10|
;;;245        }
;;;246        return p_item;
;;;247    }
00000a  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.item_enqueue||, CODE, READONLY, ALIGN=1

                  item_enqueue PROC
;;;221    
;;;222    static void item_enqueue(nrf_drv_clock_handler_item_t ** p_head,
000000  6802              LDR      r2,[r0,#0]
;;;223                             nrf_drv_clock_handler_item_t * p_item)
;;;224    {
;;;225        nrf_drv_clock_handler_item_t * p_next = *p_head;
;;;226        while (p_next)
000002  e003              B        |L6.12|
                  |L6.4|
;;;227        {
;;;228            if (p_next == p_item)
000004  428a              CMP      r2,r1
000006  d100              BNE      |L6.10|
                  |L6.8|
;;;229            {
;;;230                return;
;;;231            }
;;;232            p_next = p_next->p_next;
;;;233        }
;;;234    
;;;235        p_item->p_next = (*p_head ? *p_head : NULL);
;;;236        *p_head = p_item;
;;;237    }
000008  4770              BX       lr
                  |L6.10|
00000a  6812              LDR      r2,[r2,#0]            ;232
                  |L6.12|
00000c  2a00              CMP      r2,#0                 ;226
00000e  d1f9              BNE      |L6.4|
000010  6803              LDR      r3,[r0,#0]            ;235
000012  b10b              CBZ      r3,|L6.24|
000014  6803              LDR      r3,[r0,#0]            ;235
000016  e000              B        |L6.26|
                  |L6.24|
000018  2300              MOVS     r3,#0                 ;235
                  |L6.26|
00001a  600b              STR      r3,[r1,#0]            ;235
00001c  6001              STR      r1,[r0,#0]            ;236
00001e  bf00              NOP      
000020  e7f2              B        |L6.8|
;;;238    
                          ENDP


                          AREA ||i.lfclk_start||, CODE, READONLY, ALIGN=1

                  lfclk_start PROC
;;;112     */
;;;113    static void lfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115        nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000002  f44f7082          MOV      r0,#0x104
000006  f7fffffe          BL       nrf_clock_event_clear
;;;116        nrf_clock_int_enable(NRF_CLOCK_INT_LF_STARTED_MASK);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       nrf_clock_int_enable
;;;117        nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTART);
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       nrf_clock_task_trigger
;;;118    }
000016  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.lfclk_stop||, CODE, READONLY, ALIGN=2

                  lfclk_stop PROC
;;;121     */
;;;122    static void lfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;123    {
;;;124    #if CALIBRATION_SUPPORT
;;;125        (void)nrf_drv_clock_calibration_abort();
;;;126    #endif
;;;127    
;;;128    #ifdef SOFTDEVICE_PRESENT
;;;129        // If LFCLK is requested to stop while SD is still enabled,
;;;130        // it indicates an error in the application.
;;;131        // Enabling SD should increment the LFCLK request.
;;;132        ASSERT(!nrf_sdh_is_enabled());
;;;133    #endif // SOFTDEVICE_PRESENT
;;;134    
;;;135        nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTOP);
000002  200c              MOVS     r0,#0xc
000004  f7fffffe          BL       nrf_clock_task_trigger
;;;136        while (nrf_clock_lf_is_running())
000008  bf00              NOP      
                  |L8.10|
00000a  f7fffffe          BL       nrf_clock_lf_is_running
00000e  2800              CMP      r0,#0
000010  d1fb              BNE      |L8.10|
;;;137        {}
;;;138        m_clock_cb.lfclk_on = false;
000012  4901              LDR      r1,|L8.24|
000014  7088              STRB     r0,[r1,#2]
;;;139    }
000016  bd10              POP      {r4,pc}
;;;140    
                          ENDP

                  |L8.24|
                          DCD      m_clock_cb

                          AREA ||i.nrf_clock_event_check||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_check PROC
;;;324    
;;;325    __STATIC_INLINE bool nrf_clock_event_check(nrf_clock_event_t event)
000000  4601              MOV      r1,r0
;;;326    {
;;;327        return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
000002  f04f4080          MOV      r0,#0x40000000
000006  5840              LDR      r0,[r0,r1]
000008  b108              CBZ      r0,|L9.14|
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;328    }
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0                 ;327
000010  e7fc              B        |L9.12|
;;;329    
                          ENDP


                          AREA ||i.nrf_clock_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_clear PROC
;;;315    
;;;316    __STATIC_INLINE void nrf_clock_event_clear(nrf_clock_event_t event)
000000  b508              PUSH     {r3,lr}
;;;317    {
;;;318        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = NRF_CLOCK_EVENT_CLEAR;
000002  2200              MOVS     r2,#0
000004  f04f4180          MOV      r1,#0x40000000
000008  500a              STR      r2,[r1,r0]
;;;319    #if __CORTEX_M == 0x04
;;;320        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
00000a  5809              LDR      r1,[r1,r0]
00000c  9100              STR      r1,[sp,#0]
;;;321        (void)dummy;
00000e  bf00              NOP      
;;;322    #endif
;;;323    }
000010  bd08              POP      {r3,pc}
;;;324    
                          ENDP


                          AREA ||i.nrf_clock_hf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_hf_is_running PROC
;;;372    
;;;373    __STATIC_INLINE bool nrf_clock_hf_is_running(nrf_clock_hfclk_t clk_src)
000000  4601              MOV      r1,r0
;;;374    {
;;;375        return (NRF_CLOCK->HFCLKSTAT & (CLOCK_HFCLKSTAT_STATE_Msk | CLOCK_HFCLKSTAT_SRC_Msk)) ==
000002  4806              LDR      r0,|L11.28|
000004  6800              LDR      r0,[r0,#0]
000006  f0001001          AND      r0,r0,#0x10001
00000a  f4413280          ORR      r2,r1,#0x10000
00000e  4290              CMP      r0,r2
000010  d101              BNE      |L11.22|
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;376                (CLOCK_HFCLKSTAT_STATE_Msk | (clk_src << CLOCK_HFCLKSTAT_SRC_Pos));
;;;377    }
000014  4770              BX       lr
                  |L11.22|
000016  2000              MOVS     r0,#0                 ;375
000018  e7fc              B        |L11.20|
;;;378    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x4000040c

                          AREA ||i.nrf_clock_int_disable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_disable PROC
;;;290    
;;;291    __STATIC_INLINE void nrf_clock_int_disable(uint32_t int_mask)
000000  4901              LDR      r1,|L12.8|
;;;292    {
;;;293        NRF_CLOCK->INTENCLR = int_mask;
000002  6008              STR      r0,[r1,#0]
;;;294    }
000004  4770              BX       lr
;;;295    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40000308

                          AREA ||i.nrf_clock_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_enable PROC
;;;285    
;;;286    __STATIC_INLINE void nrf_clock_int_enable(uint32_t int_mask)
000000  4901              LDR      r1,|L13.8|
;;;287    {
;;;288        NRF_CLOCK->INTENSET = int_mask;
000002  6008              STR      r0,[r1,#0]
;;;289    }
000004  4770              BX       lr
;;;290    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40000304

                          AREA ||i.nrf_clock_lf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_lf_is_running PROC
;;;353    
;;;354    __STATIC_INLINE bool nrf_clock_lf_is_running(void)
000000  4802              LDR      r0,|L14.12|
;;;355    {
;;;356        return ((NRF_CLOCK->LFCLKSTAT &
000002  6800              LDR      r0,[r0,#0]
000004  f3c04000          UBFX     r0,r0,#16,#1
;;;357                 CLOCK_LFCLKSTAT_STATE_Msk) >> CLOCK_LFCLKSTAT_STATE_Pos);
;;;358    }
000008  4770              BX       lr
;;;359    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x40000418

                          AREA ||i.nrf_clock_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_clock_task_trigger PROC
;;;305    
;;;306    __STATIC_INLINE void nrf_clock_task_trigger(nrf_clock_task_t task)
000000  2201              MOVS     r2,#1
;;;307    {
;;;308        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
000002  0791              LSLS     r1,r2,#30
000004  500a              STR      r2,[r1,r0]
;;;309    }
000006  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_abort||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_abort PROC
;;;434    
;;;435    ret_code_t nrf_drv_clock_calibration_abort(void)
000000  2000              MOVS     r0,#0
;;;436    {
;;;437        ret_code_t err_code = NRF_SUCCESS;
;;;438    #if CALIBRATION_SUPPORT
;;;439        CRITICAL_REGION_ENTER();
;;;440        switch (m_clock_cb.cal_state)
;;;441        {
;;;442        case CAL_STATE_CT:
;;;443            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;444            nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTOP);
;;;445            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;446            if (m_clock_cb.cal_done_handler)
;;;447            {
;;;448                m_clock_cb.cal_done_handler(NRF_DRV_CLOCK_EVT_CAL_ABORTED);
;;;449            }
;;;450            break;
;;;451        case CAL_STATE_HFCLK_REQ:
;;;452            /* fall through. */
;;;453        case CAL_STATE_CAL:
;;;454            m_clock_cb.cal_state = CAL_STATE_ABORT;
;;;455            break;
;;;456        default:
;;;457            break;
;;;458        }
;;;459        CRITICAL_REGION_EXIT();
;;;460    
;;;461        NRF_LOG_INFO("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;462        return err_code;
;;;463    #else
;;;464        err_code = NRF_ERROR_FORBIDDEN;
000002  200f              MOVS     r0,#0xf
;;;465        NRF_LOG_WARNING("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;466        return err_code;
;;;467    #endif // CALIBRATION_SUPPORT
;;;468    }
000004  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_start||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_start PROC
;;;394    
;;;395    ret_code_t nrf_drv_clock_calibration_start(uint8_t interval, nrf_drv_clock_event_handler_t handler)
000000  4602              MOV      r2,r0
;;;396    {
;;;397        ret_code_t err_code = NRF_SUCCESS;
000002  2000              MOVS     r0,#0
;;;398    #if CALIBRATION_SUPPORT
;;;399        ASSERT(m_clock_cb.cal_state == CAL_STATE_IDLE);
;;;400        if (m_clock_cb.lfclk_on == false)
;;;401        {
;;;402            err_code = NRF_ERROR_INVALID_STATE;
;;;403        }
;;;404        else if (m_clock_cb.cal_state == CAL_STATE_IDLE)
;;;405        {
;;;406            m_clock_cb.cal_done_handler = handler;
;;;407            m_clock_cb.cal_hfclk_started_handler_item.event_handler = clock_calibration_hf_started;
;;;408            if (interval == 0)
;;;409            {
;;;410                m_clock_cb.cal_state = CAL_STATE_HFCLK_REQ;
;;;411                nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;412            }
;;;413            else
;;;414            {
;;;415                m_clock_cb.cal_state = CAL_STATE_CT;
;;;416                nrf_clock_cal_timer_timeout_set(interval);
;;;417                nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;418                nrf_clock_int_enable(NRF_CLOCK_INT_CTTO_MASK);
;;;419                nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTART);
;;;420            }
;;;421        }
;;;422        else
;;;423        {
;;;424            err_code = NRF_ERROR_BUSY;
;;;425        }
;;;426        NRF_LOG_WARNING("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;427        return err_code;
;;;428    #else
;;;429        err_code = NRF_ERROR_FORBIDDEN;
000004  200f              MOVS     r0,#0xf
;;;430        NRF_LOG_WARNING("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;431        return err_code;
;;;432    #endif // CALIBRATION_SUPPORT
;;;433    }
000006  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_hfclk_is_running PROC
;;;356    
;;;357    bool nrf_drv_clock_hfclk_is_running(void)
000000  b508              PUSH     {r3,lr}
;;;358    {
;;;359        ASSERT(m_clock_cb.module_initialized);
;;;360    
;;;361    #ifdef SOFTDEVICE_PRESENT
;;;362        if (nrf_sdh_is_enabled())
000002  f7fffffe          BL       nrf_sdh_is_enabled
000006  b138              CBZ      r0,|L18.24|
;;;363        {
;;;364            uint32_t is_running;
;;;365            UNUSED_VARIABLE(sd_clock_hfclk_is_running(&is_running));
000008  4668              MOV      r0,sp
00000a  df41              SVC      #0x41
;;;366            return (is_running ? true : false);
00000c  9800              LDR      r0,[sp,#0]
00000e  b108              CBZ      r0,|L18.20|
000010  2001              MOVS     r0,#1
                  |L18.18|
;;;367        }
;;;368    #endif // SOFTDEVICE_PRESENT
;;;369    
;;;370        return nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY);
;;;371    }
000012  bd08              POP      {r3,pc}
                  |L18.20|
000014  2000              MOVS     r0,#0                 ;366
000016  e7fc              B        |L18.18|
                  |L18.24|
000018  2001              MOVS     r0,#1                 ;370
00001a  f7fffffe          BL       nrf_clock_hf_is_running
00001e  e7f8              B        |L18.18|
;;;372    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_release PROC
;;;342    
;;;343    void nrf_drv_clock_hfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;344    {
;;;345        ASSERT(m_clock_cb.module_initialized);
;;;346        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;347    
;;;348        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;349        --(m_clock_cb.hfclk_requests);
00000c  4807              LDR      r0,|L19.44|
00000e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L19.44|
000014  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;350        if (m_clock_cb.hfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00001a  b908              CBNZ     r0,|L19.32|
;;;351        {
;;;352            hfclk_stop();
00001c  f7fffffe          BL       hfclk_stop
                  |L19.32|
;;;353        }
;;;354        CRITICAL_REGION_EXIT();
000020  f89d0000          LDRB     r0,[sp,#0]
000024  f7fffffe          BL       app_util_critical_region_exit
;;;355    }
000028  bd08              POP      {r3,pc}
;;;356    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_hfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_request PROC
;;;309    
;;;310    void nrf_drv_clock_hfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;311    {
000002  4604              MOV      r4,r0
;;;312        ASSERT(m_clock_cb.module_initialized);
;;;313    
;;;314        if (m_clock_cb.hfclk_on)
000004  4818              LDR      r0,|L20.104|
000006  7840              LDRB     r0,[r0,#1]  ; m_clock_cb
000008  b190              CBZ      r0,|L20.48|
;;;315        {
;;;316            if (p_handler_item)
00000a  b114              CBZ      r4,|L20.18|
;;;317            {
;;;318                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
00000c  2000              MOVS     r0,#0
00000e  6861              LDR      r1,[r4,#4]
000010  4788              BLX      r1
                  |L20.18|
;;;319            }
;;;320            CRITICAL_REGION_ENTER();
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       app_util_critical_region_enter
;;;321            ++(m_clock_cb.hfclk_requests);
00001c  4812              LDR      r0,|L20.104|
00001e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000020  1c40              ADDS     r0,r0,#1
000022  4911              LDR      r1,|L20.104|
000024  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;322            CRITICAL_REGION_EXIT();
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
00002e  e019              B        |L20.100|
                  |L20.48|
;;;323        }
;;;324        else
;;;325        {
;;;326            CRITICAL_REGION_ENTER();
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       app_util_critical_region_enter
;;;327            if (p_handler_item)
00003a  b124              CBZ      r4,|L20.70|
;;;328            {
;;;329                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head,
00003c  4621              MOV      r1,r4
00003e  480a              LDR      r0,|L20.104|
000040  3008              ADDS     r0,r0,#8
000042  f7fffffe          BL       item_enqueue
                  |L20.70|
;;;330                    p_handler_item);
;;;331            }
;;;332            if (m_clock_cb.hfclk_requests == 0)
000046  4808              LDR      r0,|L20.104|
000048  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00004a  b908              CBNZ     r0,|L20.80|
;;;333            {
;;;334                hfclk_start();
00004c  f7fffffe          BL       hfclk_start
                  |L20.80|
;;;335            }
;;;336            ++(m_clock_cb.hfclk_requests);
000050  4805              LDR      r0,|L20.104|
000052  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000054  1c40              ADDS     r0,r0,#1
000056  4904              LDR      r1,|L20.104|
000058  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;337            CRITICAL_REGION_EXIT();
00005a  f89d0000          LDRB     r0,[sp,#0]
00005e  f7fffffe          BL       app_util_critical_region_exit
000062  bf00              NOP      
                  |L20.100|
;;;338        }
;;;339    
;;;340        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;341    }
000064  bd38              POP      {r3-r5,pc}
;;;342    
                          ENDP

000066  0000              DCW      0x0000
                  |L20.104|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_init PROC
;;;176    
;;;177    ret_code_t nrf_drv_clock_init(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179        ret_code_t err_code = NRF_SUCCESS;
000002  2400              MOVS     r4,#0
;;;180        if (m_clock_cb.module_initialized)
000004  4816              LDR      r0,|L21.96|
000006  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000008  b108              CBZ      r0,|L21.14|
;;;181        {
;;;182            err_code = NRF_ERROR_MODULE_ALREADY_INITIALIZED;
00000a  2485              MOVS     r4,#0x85
00000c  e025              B        |L21.90|
                  |L21.14|
;;;183        }
;;;184        else
;;;185        {
;;;186            m_clock_cb.p_hf_head      = NULL;
00000e  2000              MOVS     r0,#0
000010  4913              LDR      r1,|L21.96|
000012  6088              STR      r0,[r1,#8]  ; m_clock_cb
;;;187            m_clock_cb.hfclk_requests = 0;
000014  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;188            m_clock_cb.p_lf_head      = NULL;
000016  6108              STR      r0,[r1,#0x10]  ; m_clock_cb
;;;189            m_clock_cb.lfclk_requests = 0;
000018  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;190            nrf_drv_common_power_clock_irq_init();
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  0941              LSRS     r1,r0,#5
000020  0089              LSLS     r1,r1,#2
000022  f10121e0          ADD      r1,r1,#0xe000e000
000026  f8d11100          LDR      r1,[r1,#0x100]
00002a  2201              MOVS     r2,#1
00002c  4082              LSLS     r2,r2,r0
00002e  4011              ANDS     r1,r1,r2
000030  b109              CBZ      r1,|L21.54|
000032  2101              MOVS     r1,#1
000034  e000              B        |L21.56|
                  |L21.54|
000036  2100              MOVS     r1,#0
                  |L21.56|
000038  b919              CBNZ     r1,|L21.66|
00003a  2107              MOVS     r1,#7
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       nrf_drv_common_irq_enable
                  |L21.66|
000042  bf00              NOP      
;;;191    #ifdef SOFTDEVICE_PRESENT
;;;192            if (!nrf_sdh_is_enabled())
000044  f7fffffe          BL       nrf_sdh_is_enabled
000048  b920              CBNZ     r0,|L21.84|
;;;193    #endif
;;;194            {
;;;195                nrf_clock_lf_src_set((nrf_clock_lfclk_t)CLOCK_CONFIG_LF_SRC);
00004a  2001              MOVS     r0,#1
00004c  4905              LDR      r1,|L21.100|
00004e  6008              STR      r0,[r1,#0]
000050  bf00              NOP      
000052  bf00              NOP      
                  |L21.84|
;;;196            }
;;;197    
;;;198    #if CALIBRATION_SUPPORT
;;;199            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;200    #endif
;;;201    
;;;202            m_clock_cb.module_initialized = true;
000054  2001              MOVS     r0,#1
000056  4902              LDR      r1,|L21.96|
000058  7008              STRB     r0,[r1,#0]
                  |L21.90|
;;;203        }
;;;204    
;;;205        NRF_LOG_INFO("Function: %s, error code: %s.",
;;;206            (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;207        return err_code;
00005a  4620              MOV      r0,r4
;;;208    }
00005c  bd10              POP      {r4,pc}
;;;209    
                          ENDP

00005e  0000              DCW      0x0000
                  |L21.96|
                          DCD      m_clock_cb
                  |L21.100|
                          DCD      0x40000518

                          AREA ||i.nrf_drv_clock_init_check||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_init_check PROC
;;;171    
;;;172    bool nrf_drv_clock_init_check(void)
000000  4801              LDR      r0,|L22.8|
;;;173    {
;;;174        return m_clock_cb.module_initialized;
000002  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
;;;175    }
000004  4770              BX       lr
;;;176    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_is_calibrating||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_is_calibrating PROC
;;;469    
;;;470    ret_code_t nrf_drv_clock_is_calibrating(bool * p_is_calibrating)
000000  4601              MOV      r1,r0
;;;471    {
;;;472        ret_code_t err_code = NRF_SUCCESS;
000002  2000              MOVS     r0,#0
;;;473    #if CALIBRATION_SUPPORT
;;;474        ASSERT(m_clock_cb.module_initialized);
;;;475        *p_is_calibrating = (m_clock_cb.cal_state != CAL_STATE_IDLE);
;;;476        NRF_LOG_INFO("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;477        return err_code;
;;;478    #else
;;;479        err_code = NRF_ERROR_FORBIDDEN;
000004  200f              MOVS     r0,#0xf
;;;480        NRF_LOG_WARNING("Function: %s, error code: %s.", (uint32_t)__func__, (uint32_t)NRF_LOG_ERROR_STRING_GET(err_code));
;;;481        return err_code;
;;;482    #endif // CALIBRATION_SUPPORT
;;;483    }
000006  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_lfclk_is_running PROC
;;;295    
;;;296    bool nrf_drv_clock_lfclk_is_running(void)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298        ASSERT(m_clock_cb.module_initialized);
;;;299    
;;;300    #ifdef SOFTDEVICE_PRESENT
;;;301        if (nrf_sdh_is_enabled())
000002  f7fffffe          BL       nrf_sdh_is_enabled
000006  b108              CBZ      r0,|L24.12|
;;;302        {
;;;303            return true;
000008  2001              MOVS     r0,#1
                  |L24.10|
;;;304        }
;;;305    #endif // SOFTDEVICE_PRESENT
;;;306    
;;;307        return nrf_clock_lf_is_running();
;;;308    }
00000a  bd10              POP      {r4,pc}
                  |L24.12|
00000c  f7fffffe          BL       nrf_clock_lf_is_running
000010  e7fb              B        |L24.10|
;;;309    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_release PROC
;;;281    
;;;282    void nrf_drv_clock_lfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;283    {
;;;284        ASSERT(m_clock_cb.module_initialized);
;;;285        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;286    
;;;287        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;288        --(m_clock_cb.lfclk_requests);
00000c  4807              LDR      r0,|L25.44|
00000e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L25.44|
000014  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;289        if (m_clock_cb.lfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00001a  b908              CBNZ     r0,|L25.32|
;;;290        {
;;;291            lfclk_stop();
00001c  f7fffffe          BL       lfclk_stop
                  |L25.32|
;;;292        }
;;;293        CRITICAL_REGION_EXIT();
000020  f89d0000          LDRB     r0,[sp,#0]
000024  f7fffffe          BL       app_util_critical_region_exit
;;;294    }
000028  bd08              POP      {r3,pc}
;;;295    
                          ENDP

00002a  0000              DCW      0x0000
                  |L25.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_lfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_request PROC
;;;248    
;;;249    void nrf_drv_clock_lfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;250    {
000002  4604              MOV      r4,r0
;;;251        ASSERT(m_clock_cb.module_initialized);
;;;252    
;;;253        if (m_clock_cb.lfclk_on)
000004  4818              LDR      r0,|L26.104|
000006  7880              LDRB     r0,[r0,#2]  ; m_clock_cb
000008  b190              CBZ      r0,|L26.48|
;;;254        {
;;;255            if (p_handler_item)
00000a  b114              CBZ      r4,|L26.18|
;;;256            {
;;;257                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
00000c  2001              MOVS     r0,#1
00000e  6861              LDR      r1,[r4,#4]
000010  4788              BLX      r1
                  |L26.18|
;;;258            }
;;;259            CRITICAL_REGION_ENTER();
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       app_util_critical_region_enter
;;;260            ++(m_clock_cb.lfclk_requests);
00001c  4812              LDR      r0,|L26.104|
00001e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000020  1c40              ADDS     r0,r0,#1
000022  4911              LDR      r1,|L26.104|
000024  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;261            CRITICAL_REGION_EXIT();
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
00002e  e019              B        |L26.100|
                  |L26.48|
;;;262        }
;;;263        else
;;;264        {
;;;265            CRITICAL_REGION_ENTER();
000030  2000              MOVS     r0,#0
000032  9000              STR      r0,[sp,#0]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       app_util_critical_region_enter
;;;266            if (p_handler_item)
00003a  b124              CBZ      r4,|L26.70|
;;;267            {
;;;268                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head,
00003c  4621              MOV      r1,r4
00003e  480a              LDR      r0,|L26.104|
000040  3010              ADDS     r0,r0,#0x10
000042  f7fffffe          BL       item_enqueue
                  |L26.70|
;;;269                    p_handler_item);
;;;270            }
;;;271            if (m_clock_cb.lfclk_requests == 0)
000046  4808              LDR      r0,|L26.104|
000048  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00004a  b908              CBNZ     r0,|L26.80|
;;;272            {
;;;273                lfclk_start();
00004c  f7fffffe          BL       lfclk_start
                  |L26.80|
;;;274            }
;;;275            ++(m_clock_cb.lfclk_requests);
000050  4805              LDR      r0,|L26.104|
000052  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000054  1c40              ADDS     r0,r0,#1
000056  4904              LDR      r1,|L26.104|
000058  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;276            CRITICAL_REGION_EXIT();
00005a  f89d0000          LDRB     r0,[sp,#0]
00005e  f7fffffe          BL       app_util_critical_region_exit
000062  bf00              NOP      
                  |L26.100|
;;;277        }
;;;278    
;;;279        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;280    }
000064  bd38              POP      {r3-r5,pc}
;;;281    
                          ENDP

000066  0000              DCW      0x0000
                  |L26.104|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_uninit PROC
;;;209    
;;;210    void nrf_drv_clock_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212        ASSERT(m_clock_cb.module_initialized);
;;;213        nrf_drv_common_clock_irq_disable();
000002  f7fffffe          BL       nrf_drv_common_clock_irq_disable
;;;214        nrf_clock_int_disable(0xFFFFFFFF);
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  f7fffffe          BL       nrf_clock_int_disable
;;;215    
;;;216        lfclk_stop();
00000e  f7fffffe          BL       lfclk_stop
;;;217        hfclk_stop();
000012  f7fffffe          BL       hfclk_stop
;;;218        m_clock_cb.module_initialized = false;
000016  2000              MOVS     r0,#0
000018  4901              LDR      r1,|L27.32|
00001a  7008              STRB     r0,[r1,#0]
;;;219        NRF_LOG_INFO("Uninitialized.");
;;;220    }
00001c  bd10              POP      {r4,pc}
;;;221    
                          ENDP

00001e  0000              DCW      0x0000
                  |L27.32|
                          DCD      m_clock_cb

                          AREA ||i.sd_state_evt_handler||, CODE, READONLY, ALIGN=2

                  sd_state_evt_handler PROC
;;;579     */
;;;580    static void sd_state_evt_handler(nrf_sdh_state_evt_t state, void * p_context)
000000  b538              PUSH     {r3-r5,lr}
;;;581    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;582        switch (state)
000006  b124              CBZ      r4,|L28.18|
000008  2c01              CMP      r4,#1
00000a  d00b              BEQ      |L28.36|
00000c  2c03              CMP      r4,#3
00000e  d126              BNE      |L28.94|
000010  e01e              B        |L28.80|
                  |L28.18|
;;;583        {
;;;584            case NRF_SDH_EVT_STATE_ENABLE_PREPARE:
;;;585                NVIC_DisableIRQ(POWER_CLOCK_IRQn);
000012  2000              MOVS     r0,#0
000014  2101              MOVS     r1,#1
000016  4081              LSLS     r1,r1,r0
000018  4a12              LDR      r2,|L28.100|
00001a  0943              LSRS     r3,r0,#5
00001c  f8421023          STR      r1,[r2,r3,LSL #2]
000020  bf00              NOP      
;;;586                break;
000022  e01d              B        |L28.96|
                  |L28.36|
;;;587    
;;;588            case NRF_SDH_EVT_STATE_ENABLED:
;;;589                CRITICAL_REGION_ENTER();
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       app_util_critical_region_enter
;;;590                /* Make sure that nrf_drv_clock module is initialized */
;;;591                if (!m_clock_cb.module_initialized)
00002e  480e              LDR      r0,|L28.104|
000030  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000032  b908              CBNZ     r0,|L28.56|
;;;592                {
;;;593                    (void)nrf_drv_clock_init();
000034  f7fffffe          BL       nrf_drv_clock_init
                  |L28.56|
;;;594                }
;;;595                /* SD is one of the LFCLK requesters, but it will enable it by itself. */
;;;596                ++(m_clock_cb.lfclk_requests);
000038  480b              LDR      r0,|L28.104|
00003a  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00003c  1c40              ADDS     r0,r0,#1
00003e  490a              LDR      r1,|L28.104|
000040  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;597                m_clock_cb.lfclk_on = true;
000042  2001              MOVS     r0,#1
000044  7088              STRB     r0,[r1,#2]
;;;598                CRITICAL_REGION_EXIT();
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  f7fffffe          BL       app_util_critical_region_exit
;;;599                break;
00004e  e007              B        |L28.96|
                  |L28.80|
;;;600    
;;;601            case NRF_SDH_EVT_STATE_DISABLED:
;;;602                /* Reinit interrupts */
;;;603                ASSERT(m_clock_cb.module_initialized);
;;;604                nrf_drv_common_irq_enable(POWER_CLOCK_IRQn, CLOCK_CONFIG_IRQ_PRIORITY);
000050  2107              MOVS     r1,#7
000052  2000              MOVS     r0,#0
000054  f7fffffe          BL       nrf_drv_common_irq_enable
;;;605    
;;;606                /* SD leaves LFCLK enabled - disable it if it is no longer required. */
;;;607                nrf_drv_clock_lfclk_release();
000058  f7fffffe          BL       nrf_drv_clock_lfclk_release
;;;608                break;
00005c  e000              B        |L28.96|
                  |L28.94|
;;;609    
;;;610            default:
;;;611                break;
00005e  bf00              NOP      
                  |L28.96|
000060  bf00              NOP                            ;586
;;;612        }
;;;613    }
000062  bd38              POP      {r3-r5,pc}
;;;614    
                          ENDP

                  |L28.100|
                          DCD      0xe000e180
                  |L28.104|
                          DCD      m_clock_cb

                          AREA ||i.soc_evt_handler||, CODE, READONLY, ALIGN=1

                  soc_evt_handler PROC
;;;563     */
;;;564    static void soc_evt_handler(uint32_t evt_id, void * p_context)
000000  b570              PUSH     {r4-r6,lr}
;;;565    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;566        if (evt_id == NRF_EVT_HFCLKSTARTED)
000006  b914              CBNZ     r4,|L29.14|
;;;567        {
;;;568            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       clock_clk_started_notify
                  |L29.14|
;;;569        }
;;;570    }
00000e  bd70              POP      {r4-r6,pc}
;;;571    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_clock_cb
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000004  6472765f          DCB      0x64,0x72,0x76,0x5f
000008  636c6f63          DCB      0x63,0x6c,0x6f,0x63
00000c  6b5f696e          DCB      0x6b,0x5f,0x69,0x6e
000010  697400            DCB      0x69,0x74,0x00
                  |symbol_number.86|
000013  6e                DCB      0x6e
000014  72665f64          DCB      0x72,0x66,0x5f,0x64
000018  72765f63          DCB      0x72,0x76,0x5f,0x63
00001c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000020  5f63616c          DCB      0x5f,0x63,0x61,0x6c
000024  69627261          DCB      0x69,0x62,0x72,0x61
000028  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00002c  5f737461          DCB      0x5f,0x73,0x74,0x61
000030  727400            DCB      0x72,0x74,0x00
                  |symbol_number.87|
000033  6e                DCB      0x6e
000034  72665f64          DCB      0x72,0x66,0x5f,0x64
000038  72765f63          DCB      0x72,0x76,0x5f,0x63
00003c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000040  5f63616c          DCB      0x5f,0x63,0x61,0x6c
000044  69627261          DCB      0x69,0x62,0x72,0x61
000048  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00004c  5f61626f          DCB      0x5f,0x61,0x62,0x6f
000050  727400            DCB      0x72,0x74,0x00
                  |symbol_number.88|
000053  6e                DCB      0x6e
000054  72665f64          DCB      0x72,0x66,0x5f,0x64
000058  72765f63          DCB      0x72,0x76,0x5f,0x63
00005c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000060  5f69735f          DCB      0x5f,0x69,0x73,0x5f
000064  63616c69          DCB      0x63,0x61,0x6c,0x69
000068  62726174          DCB      0x62,0x72,0x61,0x74
00006c  696e6700          DCB      0x69,0x6e,0x67,0x00

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=2

000000  636c6f63          DCB      0x63,0x6c,0x6f,0x63
000004  6b00              DCB      0x6b,0x00

                          AREA log_const_data, DATA, READONLY, ALIGN=2

                  m_nrf_log_clock_logs_data_const
                  ||__tagsym$$used||
                          DCD      ||.conststrlit||
000004  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA log_dynamic_data, DATA, ALIGN=2

                  m_nrf_log_clock_logs_data_dynamic
                  |symbol_number.240|
                          %        12

                          AREA sdh_soc_observers0, DATA, READONLY, ALIGN=2

                  m_soc_evt_observer
                  |symbol_number.241|
                          DCD      soc_evt_handler
                          DCD      0x00000000

                          AREA sdh_state_observers0, DATA, READONLY, ALIGN=2

                  m_sd_state_observer
                  |symbol_number.243|
                          DCD      sd_state_evt_handler
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\clock\\nrf_drv_clock.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_e231564f____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_nrf_drv_clock_c_e231564f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_e231564f____REVSH|
#line 402
|__asm___15_nrf_drv_clock_c_e231564f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_e231564f____RRX|
#line 587
|__asm___15_nrf_drv_clock_c_e231564f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
