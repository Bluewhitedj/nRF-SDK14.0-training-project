; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\id_manager.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\id_manager.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\id_manager.crf ..\..\..\..\..\..\components\ble\peer_manager\id_manager.c]
                          THUMB

                          AREA ||i.addr_compare||, CODE, READONLY, ALIGN=1

                  addr_compare PROC
;;;233     */
;;;234    bool addr_compare(ble_gap_addr_t const * p_addr1, ble_gap_addr_t const * p_addr2)
000000  b570              PUSH     {r4-r6,lr}
;;;235    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;236        // @note emdi: use NRF_PM_DEBUG_CHECK ?
;;;237        if ((p_addr1 == NULL) || (p_addr2 == NULL))
000006  b105              CBZ      r5,|L1.10|
000008  b90c              CBNZ     r4,|L1.14|
                  |L1.10|
;;;238        {
;;;239            return false;
00000a  2000              MOVS     r0,#0
                  |L1.12|
;;;240        }
;;;241    
;;;242        // Check that the addr type is identical, return false if it is not
;;;243        if (p_addr1->addr_type != p_addr2->addr_type)
;;;244        {
;;;245            return false;
;;;246        }
;;;247        // Check if the addr bytes are is identical
;;;248        return (memcmp(p_addr1->addr, p_addr2->addr, BLE_GAP_ADDR_LEN) == 0);
;;;249    }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  7828              LDRB     r0,[r5,#0]            ;243
000010  0840              LSRS     r0,r0,#1              ;243
000012  7821              LDRB     r1,[r4,#0]            ;243
000014  ebb00f51          CMP      r0,r1,LSR #1          ;243
000018  d001              BEQ      |L1.30|
00001a  2000              MOVS     r0,#0                 ;245
00001c  e7f6              B        |L1.12|
                  |L1.30|
00001e  2206              MOVS     r2,#6                 ;248
000020  1c61              ADDS     r1,r4,#1              ;248
000022  1c68              ADDS     r0,r5,#1              ;248
000024  f7fffffe          BL       memcmp
000028  b908              CBNZ     r0,|L1.46|
00002a  2001              MOVS     r0,#1                 ;248
00002c  e7ee              B        |L1.12|
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;248
000030  e7ec              B        |L1.12|
;;;250    
                          ENDP


                          AREA ||i.ah||, CODE, READONLY, ALIGN=1

                  ||ah|| PROC
;;;1048    */
;;;1049   void ah(uint8_t const * p_k, uint8_t const * p_r, uint8_t * p_local_hash)
000000  b570              PUSH     {r4-r6,lr}
;;;1050   {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1051       nrf_ecb_hal_data_t ecb_hal_data;
;;;1052   
;;;1053       for (uint32_t i = 0; i < SOC_ECB_KEY_LENGTH; i++)
00000a  2000              MOVS     r0,#0
00000c  e005              B        |L2.26|
                  |L2.14|
;;;1054       {
;;;1055           ecb_hal_data.key[i] = p_k[SOC_ECB_KEY_LENGTH - 1 - i];
00000e  f1c0010f          RSB      r1,r0,#0xf
000012  5c61              LDRB     r1,[r4,r1]
000014  f80d1000          STRB     r1,[sp,r0]
000018  1c40              ADDS     r0,r0,#1              ;1053
                  |L2.26|
00001a  2810              CMP      r0,#0x10              ;1053
00001c  d3f7              BCC      |L2.14|
;;;1056       }
;;;1057   
;;;1058       memset(ecb_hal_data.cleartext, 0, SOC_ECB_KEY_LENGTH - IM_ADDR_CLEARTEXT_LENGTH);
00001e  210d              MOVS     r1,#0xd
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       __aeabi_memclr4
;;;1059   
;;;1060       for (uint32_t i = 0; i < IM_ADDR_CLEARTEXT_LENGTH; i++)
000026  2000              MOVS     r0,#0
000028  e005              B        |L2.54|
                  |L2.42|
;;;1061       {
;;;1062           ecb_hal_data.cleartext[SOC_ECB_KEY_LENGTH - 1 - i] = p_r[i];
00002a  5c2a              LDRB     r2,[r5,r0]
00002c  f1c0030f          RSB      r3,r0,#0xf
000030  a904              ADD      r1,sp,#0x10
000032  54ca              STRB     r2,[r1,r3]
000034  1c40              ADDS     r0,r0,#1              ;1060
                  |L2.54|
000036  2803              CMP      r0,#3                 ;1060
000038  d3f7              BCC      |L2.42|
;;;1063       }
;;;1064   
;;;1065       // Can only return NRF_SUCCESS.
;;;1066       (void) sd_ecb_block_encrypt(&ecb_hal_data);
00003a  4668              MOV      r0,sp
00003c  df43              SVC      #0x43
;;;1067   
;;;1068       for (uint32_t i = 0; i < IM_ADDR_CIPHERTEXT_LENGTH; i++)
00003e  2000              MOVS     r0,#0
000040  e005              B        |L2.78|
                  |L2.66|
;;;1069       {
;;;1070           p_local_hash[i] = ecb_hal_data.ciphertext[SOC_ECB_KEY_LENGTH - 1 - i];
000042  f1c0020f          RSB      r2,r0,#0xf
000046  a908              ADD      r1,sp,#0x20
000048  5c89              LDRB     r1,[r1,r2]
00004a  5431              STRB     r1,[r6,r0]
00004c  1c40              ADDS     r0,r0,#1              ;1068
                  |L2.78|
00004e  2803              CMP      r0,#3                 ;1068
000050  d3f7              BCC      |L2.66|
;;;1071       }
;;;1072   }
000052  b00c              ADD      sp,sp,#0x30
000054  bd70              POP      {r4-r6,pc}
;;;1073   
                          ENDP


                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;109     */
;;;110    static void evt_send(im_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4605              MOV      r5,r0
;;;112        for (uint32_t i = 0; i < IM_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L3.20|
                  |L3.8|
;;;113        {
;;;114            m_evt_handlers[i](p_event);
000008  4804              LDR      r0,|L3.28|
00000a  f8501024          LDR      r1,[r0,r4,LSL #2]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;112
                  |L3.20|
000014  2c02              CMP      r4,#2                 ;112
000016  d3f7              BCC      |L3.8|
;;;115        }
;;;116    }
000018  bd70              POP      {r4-r6,pc}
;;;117    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      m_evt_handlers

                          AREA ||i.get_connection_by_conn_handle||, CODE, READONLY, ALIGN=2

                  get_connection_by_conn_handle PROC
;;;149     */
;;;150    uint8_t get_connection_by_conn_handle(uint16_t conn_handle)
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  4604              MOV      r4,r0
;;;152        if (ble_conn_state_user_flag_get(conn_handle, m_conn_state_user_flag_id))
000004  480b              LDR      r0,|L4.52|
000006  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ble_conn_state_user_flag_get
00000e  b170              CBZ      r0,|L4.46|
;;;153        {
;;;154            for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000010  2100              MOVS     r1,#0
000012  e00a              B        |L4.42|
                  |L4.20|
;;;155            {
;;;156                if (m_connections[i].conn_handle == conn_handle)
000014  eb010041          ADD      r0,r1,r1,LSL #1
000018  4a07              LDR      r2,|L4.56|
00001a  eb020080          ADD      r0,r2,r0,LSL #2
00001e  8840              LDRH     r0,[r0,#2]
000020  42a0              CMP      r0,r4
000022  d101              BNE      |L4.40|
;;;157                {
;;;158                    return i;
000024  b2c8              UXTB     r0,r1
                  |L4.38|
;;;159                }
;;;160            }
;;;161        }
;;;162        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;163        return IM_NO_INVALID_CONN_HANDLES;
;;;164    }
000026  bd10              POP      {r4,pc}
                  |L4.40|
000028  1c49              ADDS     r1,r1,#1              ;154
                  |L4.42|
00002a  2914              CMP      r1,#0x14              ;154
00002c  d3f2              BCC      |L4.20|
                  |L4.46|
00002e  20ff              MOVS     r0,#0xff              ;163
000030  e7f9              B        |L4.38|
;;;165    
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      m_conn_state_user_flag_id
                  |L4.56|
                          DCD      m_connections

                          AREA ||i.get_free_connection||, CODE, READONLY, ALIGN=2

                  get_free_connection PROC
;;;126     */
;;;127    uint8_t get_free_connection()
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2400              MOVS     r4,#0
000004  e00d              B        |L5.34|
                  |L5.6|
;;;130        {
;;;131            // Query the connection state module to check if the
;;;132            // connection handle does not belong to a valid connection.
;;;133            if (!ble_conn_state_user_flag_get(m_connections[i].conn_handle, m_conn_state_user_flag_id))
000006  eb040144          ADD      r1,r4,r4,LSL #1
00000a  4a08              LDR      r2,|L5.44|
00000c  eb020181          ADD      r1,r2,r1,LSL #2
000010  8848              LDRH     r0,[r1,#2]
000012  4907              LDR      r1,|L5.48|
000014  7809              LDRB     r1,[r1,#0]  ; m_conn_state_user_flag_id
000016  f7fffffe          BL       ble_conn_state_user_flag_get
00001a  b908              CBNZ     r0,|L5.32|
;;;134            {
;;;135                return i;
00001c  b2e0              UXTB     r0,r4
                  |L5.30|
;;;136            }
;;;137        }
;;;138        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;139        return IM_NO_INVALID_CONN_HANDLES;
;;;140    }
00001e  bd10              POP      {r4,pc}
                  |L5.32|
000020  1c64              ADDS     r4,r4,#1              ;129
                  |L5.34|
000022  2c14              CMP      r4,#0x14              ;129
000024  d3ef              BCC      |L5.6|
000026  20ff              MOVS     r0,#0xff              ;139
000028  e7f9              B        |L5.30|
;;;141    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      m_connections
                  |L5.48|
                          DCD      m_conn_state_user_flag_id

                          AREA ||i.im_address_resolve||, CODE, READONLY, ALIGN=1

                  im_address_resolve PROC
;;;1074   
;;;1075   bool im_address_resolve(ble_gap_addr_t const * p_addr, ble_gap_irk_t const * p_irk)
000000  b53e              PUSH     {r1-r5,lr}
;;;1076   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1077       NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;1078   
;;;1079       uint8_t hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1080       uint8_t local_hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1081       uint8_t prand[IM_ADDR_CLEARTEXT_LENGTH];
;;;1082   
;;;1083       if (p_addr->addr_type != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE)
000006  7820              LDRB     r0,[r4,#0]
000008  2102              MOVS     r1,#2
00000a  ebb10f50          CMP      r1,r0,LSR #1
00000e  d001              BEQ      |L6.20|
;;;1084       {
;;;1085           return false;
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;1086       }
;;;1087   
;;;1088       memcpy(hash, p_addr->addr, IM_ADDR_CIPHERTEXT_LENGTH);
;;;1089       memcpy(prand, &p_addr->addr[IM_ADDR_CIPHERTEXT_LENGTH], IM_ADDR_CLEARTEXT_LENGTH);
;;;1090       ah(p_irk->irk, prand, local_hash);
;;;1091   
;;;1092       return (memcmp(hash, local_hash, IM_ADDR_CIPHERTEXT_LENGTH) == 0);
;;;1093   }
000012  bd3e              POP      {r1-r5,pc}
                  |L6.20|
000014  f8b40001          LDRH     r0,[r4,#1]            ;1088
000018  f8ad0008          STRH     r0,[sp,#8]            ;1088
00001c  78e0              LDRB     r0,[r4,#3]            ;1088
00001e  f88d000a          STRB     r0,[sp,#0xa]          ;1088
000022  88a1              LDRH     r1,[r4,#4]            ;1089
000024  f8ad1000          STRH     r1,[sp,#0]            ;1089
000028  79a0              LDRB     r0,[r4,#6]            ;1089
00002a  f88d0002          STRB     r0,[sp,#2]            ;1089
00002e  aa01              ADD      r2,sp,#4              ;1090
000030  4669              MOV      r1,sp                 ;1090
000032  4628              MOV      r0,r5                 ;1090
000034  f7fffffe          BL       ||ah||
000038  2203              MOVS     r2,#3                 ;1092
00003a  a901              ADD      r1,sp,#4              ;1092
00003c  a802              ADD      r0,sp,#8              ;1092
00003e  f7fffffe          BL       memcmp
000042  b908              CBNZ     r0,|L6.72|
000044  2001              MOVS     r0,#1                 ;1092
000046  e7e4              B        |L6.18|
                  |L6.72|
000048  2000              MOVS     r0,#0                 ;1092
00004a  e7e2              B        |L6.18|
;;;1094   #endif // NRF_MODULE_ENABLED(PEER_MANAGER)
                          ENDP


                          AREA ||i.im_ble_addr_get||, CODE, READONLY, ALIGN=2

                  im_ble_addr_get PROC
;;;467    
;;;468    ret_code_t im_ble_addr_get(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;469    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;470        uint8_t conn_index;
;;;471    
;;;472        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;473        NRF_PM_DEBUG_CHECK(p_ble_addr != NULL);
;;;474    
;;;475        conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;476    
;;;477        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d00c              BEQ      |L7.44|
;;;478        {
;;;479            *p_ble_addr = m_connections[conn_index].peer_address;
000012  eb050045          ADD      r0,r5,r5,LSL #1
000016  4906              LDR      r1,|L7.48|
000018  eb010080          ADD      r0,r1,r0,LSL #2
00001c  6841              LDR      r1,[r0,#4]
00001e  6021              STR      r1,[r4,#0]
000020  8901              LDRH     r1,[r0,#8]
000022  80a1              STRH     r1,[r4,#4]
000024  7a80              LDRB     r0,[r0,#0xa]
000026  71a0              STRB     r0,[r4,#6]
;;;480            return NRF_SUCCESS;
000028  2000              MOVS     r0,#0
                  |L7.42|
;;;481        }
;;;482    
;;;483        return NRF_ERROR_NOT_FOUND;
;;;484    }
00002a  bd70              POP      {r4-r6,pc}
                  |L7.44|
00002c  2005              MOVS     r0,#5                 ;483
00002e  e7fc              B        |L7.42|
;;;485    
                          ENDP

                  |L7.48|
                          DCD      m_connections

                          AREA ||i.im_ble_evt_handler||, CODE, READONLY, ALIGN=1

                  im_ble_evt_handler PROC
;;;251    
;;;252    void im_ble_evt_handler(ble_evt_t const * ble_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
000002  b090              SUB      sp,sp,#0x40
000004  4604              MOV      r4,r0
;;;254        ble_gap_evt_t gap_evt;
;;;255        pm_peer_id_t  bonded_matching_peer_id;
;;;256    
;;;257        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;258    
;;;259        if (ble_evt->header.evt_id != BLE_GAP_EVT_CONNECTED)
000006  8820              LDRH     r0,[r4,#0]
000008  2810              CMP      r0,#0x10
00000a  d001              BEQ      |L8.16|
                  |L8.12|
;;;260        {
;;;261            // Nothing to do.
;;;262            return;
;;;263        }
;;;264    
;;;265        gap_evt                 = ble_evt->evt.gap_evt;
;;;266        bonded_matching_peer_id = PM_PEER_ID_INVALID;
;;;267    
;;;268        if (   gap_evt.params.connected.peer_addr.addr_type
;;;269            != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;270        {
;;;271            /* Search the database for bonding data matching the one that triggered the event.
;;;272             * Public and static addresses can be matched on address alone, while resolvable
;;;273             * random addresses can be resolved agains known IRKs. Non-resolvable random addresses
;;;274             * are never matching because they are not longterm form of identification.
;;;275             */
;;;276    
;;;277            pm_peer_id_t         peer_id;
;;;278            pm_peer_data_flash_t peer_data;
;;;279    
;;;280            pds_peer_data_iterate_prepare();
;;;281    
;;;282            switch (gap_evt.params.connected.peer_addr.addr_type)
;;;283            {
;;;284                case BLE_GAP_ADDR_TYPE_PUBLIC:
;;;285                case BLE_GAP_ADDR_TYPE_RANDOM_STATIC:
;;;286                {
;;;287                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;288                    {
;;;289                        if (addr_compare(&gap_evt.params.connected.peer_addr,
;;;290                                         &peer_data.p_bonding_data->peer_ble_id.id_addr_info))
;;;291                        {
;;;292                            bonded_matching_peer_id = peer_id;
;;;293                            break;
;;;294                        }
;;;295                    }
;;;296                }
;;;297                break;
;;;298    
;;;299                case BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE:
;;;300                {
;;;301                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;302                    {
;;;303                        if (im_address_resolve(&gap_evt.params.connected.peer_addr,
;;;304                                               &peer_data.p_bonding_data->peer_ble_id.id_info))
;;;305                        {
;;;306                            bonded_matching_peer_id = peer_id;
;;;307                            break;
;;;308                        }
;;;309                    }
;;;310                }
;;;311                break;
;;;312    
;;;313                default:
;;;314                    NRF_PM_DEBUG_CHECK(false);
;;;315                    break;
;;;316            }
;;;317        }
;;;318    
;;;319        uint8_t new_index = new_connection(gap_evt.conn_handle,
;;;320                                           &gap_evt.params.connected.peer_addr);
;;;321        UNUSED_VARIABLE(new_index);
;;;322    
;;;323        if (bonded_matching_peer_id != PM_PEER_ID_INVALID)
;;;324        {
;;;325            im_new_peer_id(gap_evt.conn_handle, bonded_matching_peer_id);
;;;326    
;;;327            // Send a bonded peer event
;;;328            im_evt_t im_evt;
;;;329            im_evt.conn_handle = gap_evt.conn_handle;
;;;330            im_evt.evt_id      = IM_EVT_BONDED_PEER_CONNECTED;
;;;331            evt_send(&im_evt);
;;;332        }
;;;333    }
00000c  b010              ADD      sp,sp,#0x40
00000e  bd70              POP      {r4-r6,pc}
                  |L8.16|
000010  2234              MOVS     r2,#0x34              ;265
000012  1d21              ADDS     r1,r4,#4              ;265
000014  a803              ADD      r0,sp,#0xc            ;265
000016  f7fffffe          BL       __aeabi_memcpy4
00001a  f64f75ff          MOV      r5,#0xffff            ;266
00001e  f89d0010          LDRB     r0,[sp,#0x10]         ;268
000022  2103              MOVS     r1,#3                 ;268
000024  ebb10f50          CMP      r1,r0,LSR #1          ;268
000028  d035              BEQ      |L8.150|
00002a  f7fffffe          BL       pds_peer_data_iterate_prepare
00002e  f89d0010          LDRB     r0,[sp,#0x10]         ;282
000032  0840              LSRS     r0,r0,#1              ;282
000034  b120              CBZ      r0,|L8.64|
000036  2801              CMP      r0,#1                 ;282
000038  d003              BEQ      |L8.66|
00003a  2802              CMP      r0,#2                 ;282
00003c  d128              BNE      |L8.144|
00003e  e014              B        |L8.106|
                  |L8.64|
000040  bf00              NOP                            ;285
                  |L8.66|
000042  e009              B        |L8.88|
                  |L8.68|
000044  9801              LDR      r0,[sp,#4]            ;289
000046  f1000111          ADD      r1,r0,#0x11           ;289
00004a  a804              ADD      r0,sp,#0x10           ;289
00004c  f7fffffe          BL       addr_compare
000050  b110              CBZ      r0,|L8.88|
000052  f8bd5008          LDRH     r5,[sp,#8]            ;292
000056  e006              B        |L8.102|
                  |L8.88|
000058  466a              MOV      r2,sp                 ;287
00005a  a902              ADD      r1,sp,#8              ;287
00005c  2007              MOVS     r0,#7                 ;287
00005e  f7fffffe          BL       pds_peer_data_iterate
000062  2800              CMP      r0,#0                 ;287
000064  d1ee              BNE      |L8.68|
                  |L8.102|
000066  bf00              NOP                            ;293
000068  e013              B        |L8.146|
                  |L8.106|
00006a  e008              B        |L8.126|
                  |L8.108|
00006c  9801              LDR      r0,[sp,#4]            ;303
00006e  1c41              ADDS     r1,r0,#1              ;303
000070  a804              ADD      r0,sp,#0x10           ;303
000072  f7fffffe          BL       im_address_resolve
000076  b110              CBZ      r0,|L8.126|
000078  f8bd5008          LDRH     r5,[sp,#8]            ;306
00007c  e006              B        |L8.140|
                  |L8.126|
00007e  466a              MOV      r2,sp                 ;301
000080  a902              ADD      r1,sp,#8              ;301
000082  2007              MOVS     r0,#7                 ;301
000084  f7fffffe          BL       pds_peer_data_iterate
000088  2800              CMP      r0,#0                 ;301
00008a  d1ef              BNE      |L8.108|
                  |L8.140|
00008c  bf00              NOP                            ;307
00008e  e000              B        |L8.146|
                  |L8.144|
000090  bf00              NOP                            ;315
                  |L8.146|
000092  bf00              NOP                            ;297
000094  bf00              NOP                            ;317
                  |L8.150|
000096  f8bd000c          LDRH     r0,[sp,#0xc]          ;319
00009a  a904              ADD      r1,sp,#0x10           ;319
00009c  f7fffffe          BL       new_connection
0000a0  4606              MOV      r6,r0                 ;319
0000a2  f64f70ff          MOV      r0,#0xffff            ;323
0000a6  4285              CMP      r5,r0                 ;323
0000a8  d00f              BEQ      |L8.202|
0000aa  f8bd000c          LDRH     r0,[sp,#0xc]          ;325
0000ae  4629              MOV      r1,r5                 ;325
0000b0  f7fffffe          BL       im_new_peer_id
0000b4  f8bd000c          LDRH     r0,[sp,#0xc]          ;329
0000b8  f8ad0006          STRH     r0,[sp,#6]            ;329
0000bc  2001              MOVS     r0,#1                 ;330
0000be  f88d0004          STRB     r0,[sp,#4]            ;330
0000c2  a801              ADD      r0,sp,#4              ;331
0000c4  f7fffffe          BL       evt_send
0000c8  bf00              NOP                            ;332
                  |L8.202|
0000ca  bf00              NOP      
0000cc  e79e              B        |L8.12|
;;;334    
                          ENDP


                          AREA ||i.im_conn_handle_get||, CODE, READONLY, ALIGN=2

                  im_conn_handle_get PROC
;;;533    
;;;534    uint16_t im_conn_handle_get(pm_peer_id_t peer_id)
000000  4602              MOV      r2,r0
;;;535    {
;;;536        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;537    
;;;538        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2100              MOVS     r1,#0
000004  e00d              B        |L9.34|
                  |L9.6|
;;;539        {
;;;540            if (peer_id == m_connections[i].peer_id)
000006  eb010041          ADD      r0,r1,r1,LSL #1
00000a  4b08              LDR      r3,|L9.44|
00000c  f8330020          LDRH     r0,[r3,r0,LSL #2]
000010  4290              CMP      r0,r2
000012  d105              BNE      |L9.32|
;;;541            {
;;;542                return m_connections[i].conn_handle;
000014  eb010041          ADD      r0,r1,r1,LSL #1
000018  eb030080          ADD      r0,r3,r0,LSL #2
00001c  8840              LDRH     r0,[r0,#2]
                  |L9.30|
;;;543            }
;;;544        }
;;;545        return BLE_CONN_HANDLE_INVALID;
;;;546    }
00001e  4770              BX       lr
                  |L9.32|
000020  1c49              ADDS     r1,r1,#1              ;538
                  |L9.34|
000022  2914              CMP      r1,#0x14              ;538
000024  d3ef              BCC      |L9.6|
000026  f64f70ff          MOV      r0,#0xffff            ;545
00002a  e7f8              B        |L9.30|
;;;547    
                          ENDP

                  |L9.44|
                          DCD      m_connections

                          AREA ||i.im_device_identities_list_set||, CODE, READONLY, ALIGN=1

                  im_device_identities_list_set PROC
;;;696    
;;;697    ret_code_t im_device_identities_list_set(pm_peer_id_t const * p_peers,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;698                                             uint32_t             peer_cnt)
;;;699    {
000004  b0ce              SUB      sp,sp,#0x138
000006  4607              MOV      r7,r0
000008  460c              MOV      r4,r1
;;;700        #if (NRF_SD_BLE_API_VERSION >= 3)
;;;701    
;;;702            ret_code_t             ret;
;;;703            pm_peer_data_t         peer_data;
;;;704            pm_peer_data_bonding_t bond_data;
;;;705    
;;;706            ble_gap_id_key_t         keys[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;707            ble_gap_id_key_t const * key_ptrs[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;708    
;;;709            if ((p_peers == NULL) || (peer_cnt == 0))
00000a  b107              CBZ      r7,|L10.14|
00000c  b934              CBNZ     r4,|L10.28|
                  |L10.14|
;;;710            {
;;;711                // Clear the device identities list.
;;;712                return sd_ble_gap_device_identities_set(NULL, NULL, 0);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4610              MOV      r0,r2
000014  df6f              SVC      #0x6f
                  |L10.22|
;;;713            }
;;;714    
;;;715            peer_data.p_bonding_data = &bond_data;
;;;716            uint32_t const buf_size  = sizeof(bond_data);
;;;717    
;;;718            memset(keys, 0x00, sizeof(keys));
;;;719            for (uint32_t i = 0; i < BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT; i++)
;;;720            {
;;;721                key_ptrs[i] = &keys[i];
;;;722            }
;;;723    
;;;724            for (uint32_t i = 0; i < peer_cnt; i++)
;;;725            {
;;;726                memset(&bond_data, 0x00, sizeof(bond_data));
;;;727    
;;;728                // Read peer data from flash.
;;;729                ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
;;;730                                         &peer_data, &buf_size);
;;;731    
;;;732                if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
;;;733                {
;;;734                    // Peer data coulnd't be found in flash or peer ID is not valid.
;;;735                    return NRF_ERROR_NOT_FOUND;
;;;736                }
;;;737    
;;;738                uint8_t const addr_type = bond_data.peer_ble_id.id_addr_info.addr_type;
;;;739    
;;;740                if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;741                    (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;742                {
;;;743                    // The address shared by the peer during bonding can't be whitelisted.
;;;744                    return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;745                }
;;;746    
;;;747                // Copy data to the buffer.
;;;748                memcpy(&keys[i], &bond_data.peer_ble_id, sizeof(ble_gap_id_key_t));
;;;749            }
;;;750    
;;;751            return sd_ble_gap_device_identities_set(key_ptrs, NULL, peer_cnt);
;;;752    
;;;753        #else
;;;754    
;;;755            return NRF_ERROR_NOT_SUPPORTED;
;;;756    
;;;757        #endif
;;;758    }
000016  b04e              ADD      sp,sp,#0x138
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L10.28|
00001c  a838              ADD      r0,sp,#0xe0           ;715
00001e  904d              STR      r0,[sp,#0x134]        ;715
000020  2050              MOVS     r0,#0x50              ;716
000022  9001              STR      r0,[sp,#4]            ;716
000024  21b8              MOVS     r1,#0xb8              ;718
000026  a80a              ADD      r0,sp,#0x28           ;718
000028  f7fffffe          BL       __aeabi_memclr4
00002c  2000              MOVS     r0,#0                 ;719
00002e  e009              B        |L10.68|
                  |L10.48|
000030  ebc001c0          RSB      r1,r0,r0,LSL #3       ;721
000034  eb011100          ADD      r1,r1,r0,LSL #4       ;721
000038  aa0a              ADD      r2,sp,#0x28           ;721
00003a  4411              ADD      r1,r1,r2              ;721
00003c  aa02              ADD      r2,sp,#8              ;721
00003e  f8421020          STR      r1,[r2,r0,LSL #2]     ;721
000042  1c40              ADDS     r0,r0,#1              ;719
                  |L10.68|
000044  2808              CMP      r0,#8                 ;719
000046  d3f3              BCC      |L10.48|
000048  2600              MOVS     r6,#0                 ;724
00004a  e02a              B        |L10.162|
                  |L10.76|
00004c  2150              MOVS     r1,#0x50              ;726
00004e  a838              ADD      r0,sp,#0xe0           ;726
000050  f7fffffe          BL       __aeabi_memclr4
000054  f8370016          LDRH     r0,[r7,r6,LSL #1]     ;729
000058  ab01              ADD      r3,sp,#4              ;729
00005a  aa4c              ADD      r2,sp,#0x130          ;729
00005c  2107              MOVS     r1,#7                 ;729
00005e  f7fffffe          BL       pds_peer_data_read
000062  4605              MOV      r5,r0                 ;729
000064  2d05              CMP      r5,#5                 ;732
000066  d001              BEQ      |L10.108|
000068  2d07              CMP      r5,#7                 ;732
00006a  d101              BNE      |L10.112|
                  |L10.108|
00006c  2005              MOVS     r0,#5                 ;735
00006e  e7d2              B        |L10.22|
                  |L10.112|
000070  a838              ADD      r0,sp,#0xe0           ;738
000072  7c40              LDRB     r0,[r0,#0x11]         ;738
000074  ea4f0850          LSR      r8,r0,#1              ;738
000078  f1b80f00          CMP      r8,#0                 ;740
00007c  d005              BEQ      |L10.138|
00007e  f1b80f01          CMP      r8,#1                 ;741
000082  d002              BEQ      |L10.138|
000084  f2432002          MOV      r0,#0x3202            ;744
000088  e7c5              B        |L10.22|
                  |L10.138|
00008a  ebc601c6          RSB      r1,r6,r6,LSL #3       ;748
00008e  eb011106          ADD      r1,r1,r6,LSL #4       ;748
000092  aa0a              ADD      r2,sp,#0x28           ;748
000094  1888              ADDS     r0,r1,r2              ;748
000096  2217              MOVS     r2,#0x17              ;748
000098  f10d01e1          ADD      r1,sp,#0xe1           ;748
00009c  f7fffffe          BL       __aeabi_memcpy
0000a0  1c76              ADDS     r6,r6,#1              ;724
                  |L10.162|
0000a2  42a6              CMP      r6,r4                 ;724
0000a4  d3d2              BCC      |L10.76|
0000a6  b2e2              UXTB     r2,r4                 ;751
0000a8  2100              MOVS     r1,#0                 ;751
0000aa  a802              ADD      r0,sp,#8              ;751
0000ac  df6f              SVC      #0x6f                 ;751
0000ae  e7b2              B        |L10.22|
;;;759    
                          ENDP


                          AREA ||i.im_id_addr_get||, CODE, READONLY, ALIGN=1

                  im_id_addr_get PROC
;;;826    
;;;827    ret_code_t im_id_addr_get(ble_gap_addr_t * p_addr)
000000  b510              PUSH     {r4,lr}
;;;828    {
000002  4604              MOV      r4,r0
;;;829        NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;830    
;;;831        #if (NRF_SD_BLE_API_VERSION <= 2)
;;;832            memcpy(p_addr, &m_current_id_addr, sizeof(ble_gap_addr_t));
;;;833            return NRF_SUCCESS;
;;;834        #else
;;;835            return sd_ble_gap_addr_get(p_addr);
000004  4620              MOV      r0,r4
000006  df6d              SVC      #0x6d
;;;836        #endif
;;;837    }
000008  bd10              POP      {r4,pc}
;;;838    
                          ENDP


                          AREA ||i.im_id_addr_set||, CODE, READONLY, ALIGN=1

                  im_id_addr_set PROC
;;;785    
;;;786    ret_code_t im_id_addr_set(ble_gap_addr_t const * p_addr)
000000  b510              PUSH     {r4,lr}
;;;787    {
000002  4604              MOV      r4,r0
;;;788        #if (NRF_SD_BLE_API_VERSION <= 2)
;;;789    
;;;790            ret_code_t     ret;
;;;791            ble_gap_addr_t current_addr;
;;;792    
;;;793            NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;794    
;;;795            (void) sd_ble_gap_address_get(&current_addr);
;;;796    
;;;797            ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, (ble_gap_addr_t *)p_addr);
;;;798            if (ret != NRF_SUCCESS)
;;;799            {
;;;800                return ret;
;;;801            }
;;;802    
;;;803            if (   current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
;;;804                || current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;805            {
;;;806                // If currently using privacy, it must be re-enabled.
;;;807                // We force AUTO when privacy is enabled.
;;;808                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &current_addr);
;;;809                if (ret != NRF_SUCCESS)
;;;810                {
;;;811                    return ret;
;;;812                }
;;;813            }
;;;814    
;;;815            memcpy(&m_current_id_addr, p_addr, sizeof(ble_gap_addr_t));
;;;816    
;;;817            return NRF_SUCCESS;
;;;818    
;;;819        #else
;;;820    
;;;821            return sd_ble_gap_addr_set(p_addr);
000004  4620              MOV      r0,r4
000006  df6c              SVC      #0x6c
;;;822    
;;;823        #endif
;;;824    }
000008  bd10              POP      {r4,pc}
;;;825    
                          ENDP


                          AREA ||i.im_init||, CODE, READONLY, ALIGN=2

                  im_init PROC
;;;424    
;;;425    ret_code_t im_init(void)
000000  b510              PUSH     {r4,lr}
;;;426    {
;;;427        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;428    
;;;429        internal_state_reset();
000002  f7fffffe          BL       internal_state_reset
;;;430    
;;;431        m_conn_state_user_flag_id = ble_conn_state_user_flag_acquire();
000006  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000a  4906              LDR      r1,|L13.36|
00000c  7008              STRB     r0,[r1,#0]
;;;432        if (m_conn_state_user_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
00000e  4608              MOV      r0,r1
000010  7800              LDRB     r0,[r0,#0]  ; m_conn_state_user_flag_id
000012  2818              CMP      r0,#0x18
000014  d101              BNE      |L13.26|
;;;433        {
;;;434            return NRF_ERROR_INTERNAL;
000016  2003              MOVS     r0,#3
                  |L13.24|
;;;435        }
;;;436    
;;;437        #if (NRF_SD_BLE_API_VERSION <= 2)
;;;438            ret_code_t ret_code = sd_ble_gap_address_get(&m_current_id_addr);
;;;439            if (ret_code != NRF_SUCCESS)
;;;440            {
;;;441                return NRF_ERROR_INTERNAL;
;;;442            }
;;;443        #endif
;;;444    
;;;445        m_module_initialized = true;
;;;446    
;;;447        return NRF_SUCCESS;
;;;448    }
000018  bd10              POP      {r4,pc}
                  |L13.26|
00001a  2001              MOVS     r0,#1                 ;445
00001c  4902              LDR      r1,|L13.40|
00001e  7008              STRB     r0,[r1,#0]            ;445
000020  2000              MOVS     r0,#0                 ;447
000022  e7f9              B        |L13.24|
;;;449    
                          ENDP

                  |L13.36|
                          DCD      m_conn_state_user_flag_id
                  |L13.40|
                          DCD      m_module_initialized

                          AREA ||i.im_is_duplicate_bonding_data||, CODE, READONLY, ALIGN=1

                  im_is_duplicate_bonding_data PROC
;;;343     */
;;;344    bool im_is_duplicate_bonding_data(pm_peer_data_bonding_t const * p_bonding_data1,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;345                                      pm_peer_data_bonding_t const * p_bonding_data2)
;;;346    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;347        NRF_PM_DEBUG_CHECK(p_bonding_data1 != NULL);
;;;348        NRF_PM_DEBUG_CHECK(p_bonding_data2 != NULL);
;;;349    
;;;350        if (!is_valid_irk(&p_bonding_data1->peer_ble_id.id_info))
000008  1c60              ADDS     r0,r4,#1
00000a  f7fffffe          BL       is_valid_irk
00000e  b910              CBNZ     r0,|L14.22|
;;;351        {
;;;352            return false;
000010  2000              MOVS     r0,#0
                  |L14.18|
;;;353        }
;;;354    
;;;355        bool duplicate_irk = (memcmp(p_bonding_data1->peer_ble_id.id_info.irk,
;;;356                                     p_bonding_data2->peer_ble_id.id_info.irk,
;;;357                                     BLE_GAP_SEC_KEY_LEN) == 0);
;;;358    
;;;359        bool duplicate_addr = addr_compare(&p_bonding_data1->peer_ble_id.id_addr_info,
;;;360                                           &p_bonding_data2->peer_ble_id.id_addr_info);
;;;361    
;;;362        return duplicate_irk || duplicate_addr;
;;;363    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L14.22|
000016  2210              MOVS     r2,#0x10              ;355
000018  1c69              ADDS     r1,r5,#1              ;355
00001a  1c60              ADDS     r0,r4,#1              ;355
00001c  f7fffffe          BL       memcmp
000020  b908              CBNZ     r0,|L14.38|
000022  2001              MOVS     r0,#1                 ;355
000024  e000              B        |L14.40|
                  |L14.38|
000026  2000              MOVS     r0,#0                 ;355
                  |L14.40|
000028  4607              MOV      r7,r0                 ;355
00002a  f1050111          ADD      r1,r5,#0x11           ;359
00002e  f1040011          ADD      r0,r4,#0x11           ;359
000032  f7fffffe          BL       addr_compare
000036  4606              MOV      r6,r0                 ;359
000038  b907              CBNZ     r7,|L14.60|
00003a  b10e              CBZ      r6,|L14.64|
                  |L14.60|
00003c  2001              MOVS     r0,#1                 ;362
00003e  e7e8              B        |L14.18|
                  |L14.64|
000040  2000              MOVS     r0,#0                 ;362
000042  e7e6              B        |L14.18|
;;;364    
                          ENDP


                          AREA ||i.im_master_id_is_valid||, CODE, READONLY, ALIGN=1

                  im_master_id_is_valid PROC
;;;548    
;;;549    bool im_master_id_is_valid(ble_gap_master_id_t const * p_master_id)
000000  4602              MOV      r2,r0
;;;550    {
;;;551        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;552    
;;;553        if (p_master_id->ediv != 0)
000002  8810              LDRH     r0,[r2,#0]
000004  b108              CBZ      r0,|L15.10|
;;;554        {
;;;555            return true;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;556        }
;;;557    
;;;558        for (uint32_t i = 0; i < BLE_GAP_SEC_RAND_LEN; i++)
;;;559        {
;;;560            if (p_master_id->rand[i] != 0)
;;;561            {
;;;562                return true;
;;;563            }
;;;564        }
;;;565        return false;
;;;566    }
000008  4770              BX       lr
                  |L15.10|
00000a  2100              MOVS     r1,#0                 ;558
00000c  e005              B        |L15.26|
                  |L15.14|
00000e  1c90              ADDS     r0,r2,#2              ;560
000010  5c40              LDRB     r0,[r0,r1]            ;560
000012  b108              CBZ      r0,|L15.24|
000014  2001              MOVS     r0,#1                 ;562
000016  e7f7              B        |L15.8|
                  |L15.24|
000018  1c49              ADDS     r1,r1,#1              ;558
                  |L15.26|
00001a  2908              CMP      r1,#8                 ;558
00001c  d3f7              BCC      |L15.14|
00001e  2000              MOVS     r0,#0                 ;565
000020  e7f2              B        |L15.8|
;;;567    
                          ENDP


                          AREA ||i.im_master_ids_compare||, CODE, READONLY, ALIGN=1

                  im_master_ids_compare PROC
;;;486    
;;;487    bool im_master_ids_compare(ble_gap_master_id_t const * p_master_id1,
000000  b570              PUSH     {r4-r6,lr}
;;;488                               ble_gap_master_id_t const * p_master_id2)
;;;489    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;490        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;491        NRF_PM_DEBUG_CHECK(p_master_id1 != NULL);
;;;492        NRF_PM_DEBUG_CHECK(p_master_id2 != NULL);
;;;493    
;;;494        if (!im_master_id_is_valid(p_master_id1))
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       im_master_id_is_valid
00000c  b908              CBNZ     r0,|L16.18|
;;;495        {
;;;496            return false;
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;497        }
;;;498    
;;;499        if (p_master_id1->ediv != p_master_id2->ediv)
;;;500        {
;;;501            return false;
;;;502        }
;;;503    
;;;504        return (memcmp(p_master_id1->rand, p_master_id2->rand, BLE_GAP_SEC_RAND_LEN) == 0);
;;;505    }
000010  bd70              POP      {r4-r6,pc}
                  |L16.18|
000012  8828              LDRH     r0,[r5,#0]            ;499
000014  8821              LDRH     r1,[r4,#0]            ;499
000016  4288              CMP      r0,r1                 ;499
000018  d001              BEQ      |L16.30|
00001a  2000              MOVS     r0,#0                 ;501
00001c  e7f8              B        |L16.16|
                  |L16.30|
00001e  2208              MOVS     r2,#8                 ;504
000020  1ca1              ADDS     r1,r4,#2              ;504
000022  1ca8              ADDS     r0,r5,#2              ;504
000024  f7fffffe          BL       memcmp
000028  b908              CBNZ     r0,|L16.46|
00002a  2001              MOVS     r0,#1                 ;504
00002c  e7f0              B        |L16.16|
                  |L16.46|
00002e  2000              MOVS     r0,#0                 ;504
000030  e7ee              B        |L16.16|
;;;506    
                          ENDP


                          AREA ||i.im_new_peer_id||, CODE, READONLY, ALIGN=1

                  im_new_peer_id PROC
;;;583    
;;;584    void im_new_peer_id(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;585    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;586        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;587    
;;;588        peer_id_set(conn_handle, peer_id);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       peer_id_set
;;;589    }
00000e  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP


                          AREA ||i.im_pdb_evt_handler||, CODE, READONLY, ALIGN=1

                  im_pdb_evt_handler PROC
;;;370     */
;;;371    void im_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b530              PUSH     {r4,r5,lr}
;;;372    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;373        ret_code_t           ret;
;;;374        pm_peer_id_t         peer_id;
;;;375        pm_peer_data_flash_t peer_data;
;;;376        pm_peer_data_flash_t peer_data_duplicate;
;;;377    
;;;378        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;379        NRF_PM_DEBUG_CHECK(p_event != NULL);
;;;380    
;;;381        if ((p_event->evt_id  != PDB_EVT_WRITE_BUF_STORED) ||
000006  7820              LDRB     r0,[r4,#0]
000008  b910              CBNZ     r0,|L18.16|
;;;382            (p_event->data_id != PM_PEER_DATA_ID_BONDING))
00000a  7920              LDRB     r0,[r4,#4]
00000c  2807              CMP      r0,#7
00000e  d001              BEQ      |L18.20|
                  |L18.16|
;;;383        {
;;;384            return;
;;;385        }
;;;386    
;;;387        // If new data about peer id has been stored it is compared to other peers peer ids in
;;;388        // search of duplicates.
;;;389    
;;;390        ret = pdb_peer_data_ptr_get(p_event->peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
;;;391    
;;;392        if (ret != NRF_SUCCESS)
;;;393        {
;;;394            // @note emdi: this shouldn't happen, since the data was just stored, right?
;;;395            NRF_PM_DEBUG_CHECK(false);
;;;396            return;
;;;397        }
;;;398    
;;;399        pds_peer_data_iterate_prepare();
;;;400    
;;;401        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data_duplicate))
;;;402        {
;;;403            if (p_event->peer_id == peer_id)
;;;404            {
;;;405                // Skip the iteration if the bonding data retrieved is for a peer
;;;406                // with the same ID as the one contained in the event.
;;;407                continue;
;;;408            }
;;;409    
;;;410            if (im_is_duplicate_bonding_data(peer_data.p_bonding_data,
;;;411                                             peer_data_duplicate.p_bonding_data))
;;;412            {
;;;413                im_evt_t im_evt;
;;;414                im_evt.conn_handle                   = im_conn_handle_get(p_event->peer_id);
;;;415                im_evt.evt_id                        = IM_EVT_DUPLICATE_ID;
;;;416                im_evt.params.duplicate_id.peer_id_1 = p_event->peer_id;
;;;417                im_evt.params.duplicate_id.peer_id_2 = peer_id;
;;;418                evt_send(&im_evt);
;;;419                break;
;;;420            }
;;;421        }
;;;422    }
000010  b007              ADD      sp,sp,#0x1c
000012  bd30              POP      {r4,r5,pc}
                  |L18.20|
000014  8860              LDRH     r0,[r4,#2]            ;390
000016  aa04              ADD      r2,sp,#0x10           ;390
000018  2107              MOVS     r1,#7                 ;390
00001a  f7fffffe          BL       pdb_peer_data_ptr_get
00001e  4605              MOV      r5,r0                 ;390
000020  b105              CBZ      r5,|L18.36|
000022  e7f5              B        |L18.16|
                  |L18.36|
000024  f7fffffe          BL       pds_peer_data_iterate_prepare
000028  e01e              B        |L18.104|
                  |L18.42|
00002a  8860              LDRH     r0,[r4,#2]            ;403
00002c  f8bd1018          LDRH     r1,[sp,#0x18]         ;403
000030  4288              CMP      r0,r1                 ;403
000032  d100              BNE      |L18.54|
000034  e018              B        |L18.104|
                  |L18.54|
000036  9903              LDR      r1,[sp,#0xc]          ;410
000038  9805              LDR      r0,[sp,#0x14]         ;410
00003a  f7fffffe          BL       im_is_duplicate_bonding_data
00003e  b190              CBZ      r0,|L18.102|
000040  8860              LDRH     r0,[r4,#2]            ;414
000042  f7fffffe          BL       im_conn_handle_get
000046  f8ad0002          STRH     r0,[sp,#2]            ;414
00004a  2000              MOVS     r0,#0                 ;415
00004c  f88d0000          STRB     r0,[sp,#0]            ;415
000050  8860              LDRH     r0,[r4,#2]            ;416
000052  f8ad0004          STRH     r0,[sp,#4]            ;416
000056  f8bd1018          LDRH     r1,[sp,#0x18]         ;417
00005a  f8ad1006          STRH     r1,[sp,#6]            ;417
00005e  4668              MOV      r0,sp                 ;418
000060  f7fffffe          BL       evt_send
000064  e007              B        |L18.118|
                  |L18.102|
000066  bf00              NOP                            ;407
                  |L18.104|
000068  aa02              ADD      r2,sp,#8              ;401
00006a  a906              ADD      r1,sp,#0x18           ;401
00006c  2007              MOVS     r0,#7                 ;401
00006e  f7fffffe          BL       pds_peer_data_iterate
000072  2800              CMP      r0,#0                 ;401
000074  d1d9              BNE      |L18.42|
                  |L18.118|
000076  bf00              NOP                            ;419
000078  bf00              NOP      
00007a  e7c9              B        |L18.16|
;;;423    
                          ENDP


                          AREA ||i.im_peer_free||, CODE, READONLY, ALIGN=1

                  im_peer_free PROC
;;;591    
;;;592    ret_code_t im_peer_free(pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;593    {
000002  4606              MOV      r6,r0
;;;594        uint16_t   conn_handle;
;;;595        ret_code_t ret;
;;;596    
;;;597        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;598    
;;;599        conn_handle = im_conn_handle_get(peer_id);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       im_conn_handle_get
00000a  4604              MOV      r4,r0
;;;600        ret         = pdb_peer_free(peer_id);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       pdb_peer_free
000012  4605              MOV      r5,r0
;;;601    
;;;602        if ((conn_handle != BLE_CONN_HANDLE_INVALID) && (ret == NRF_SUCCESS))
000014  f64f70ff          MOV      r0,#0xffff
000018  4284              CMP      r4,r0
00001a  d004              BEQ      |L19.38|
00001c  b91d              CBNZ     r5,|L19.38|
;;;603        {
;;;604            peer_id_set(conn_handle, PM_PEER_ID_INVALID);
00001e  4601              MOV      r1,r0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       peer_id_set
                  |L19.38|
;;;605        }
;;;606        return ret;
000026  4628              MOV      r0,r5
;;;607    }
000028  bd70              POP      {r4-r6,pc}
;;;608    
                          ENDP


                          AREA ||i.im_peer_id_get_by_conn_handle||, CODE, READONLY, ALIGN=2

                  im_peer_id_get_by_conn_handle PROC
;;;450    
;;;451    pm_peer_id_t im_peer_id_get_by_conn_handle(uint16_t conn_handle)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4605              MOV      r5,r0
;;;453        uint8_t conn_index;
;;;454    
;;;455        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;456    
;;;457        conn_index = get_connection_by_conn_handle(conn_handle);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       get_connection_by_conn_handle
00000a  4604              MOV      r4,r0
;;;458    
;;;459        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000c  2cff              CMP      r4,#0xff
00000e  d005              BEQ      |L20.28|
;;;460        {
;;;461            return m_connections[conn_index].peer_id;
000010  eb040044          ADD      r0,r4,r4,LSL #1
000014  4903              LDR      r1,|L20.36|
000016  f8310020          LDRH     r0,[r1,r0,LSL #2]
                  |L20.26|
;;;462        }
;;;463    
;;;464        return PM_PEER_ID_INVALID;
;;;465    }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  f64f70ff          MOV      r0,#0xffff            ;464
000020  e7fb              B        |L20.26|
;;;466    
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      m_connections

                          AREA ||i.im_peer_id_get_by_master_id||, CODE, READONLY, ALIGN=1

                  im_peer_id_get_by_master_id PROC
;;;507    
;;;508    pm_peer_id_t im_peer_id_get_by_master_id(ble_gap_master_id_t const * p_master_id)
000000  b53e              PUSH     {r1-r5,lr}
;;;509    {
000002  4604              MOV      r4,r0
;;;510        pm_peer_id_t         peer_id;
;;;511        pm_peer_data_flash_t peer_data;
;;;512    
;;;513        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;514        NRF_PM_DEBUG_CHECK(p_master_id != NULL);
;;;515    
;;;516        pds_peer_data_iterate_prepare();
000004  f7fffffe          BL       pds_peer_data_iterate_prepare
;;;517    
;;;518        // For each stored peer, check if the master_id matches p_master_id
;;;519        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
000008  e010              B        |L21.44|
                  |L21.10|
;;;520        {
;;;521            if (im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->own_ltk.master_id) ||
00000a  9801              LDR      r0,[sp,#4]
00000c  f1000146          ADD      r1,r0,#0x46
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       im_master_ids_compare
000016  b930              CBNZ     r0,|L21.38|
;;;522                im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->peer_ltk.master_id))
000018  9801              LDR      r0,[sp,#4]
00001a  f100012a          ADD      r1,r0,#0x2a
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       im_master_ids_compare
000024  b110              CBZ      r0,|L21.44|
                  |L21.38|
;;;523            {
;;;524                // If a matching master ID is found then return the peer ID.
;;;525                return peer_id;
000026  f8bd0008          LDRH     r0,[sp,#8]
                  |L21.42|
;;;526            }
;;;527        }
;;;528    
;;;529        // If no matching master ID is found return PM_PEER_ID_INVALID.
;;;530        return PM_PEER_ID_INVALID;
;;;531    }
00002a  bd3e              POP      {r1-r5,pc}
                  |L21.44|
00002c  466a              MOV      r2,sp                 ;519
00002e  a902              ADD      r1,sp,#8              ;519
000030  2007              MOVS     r0,#7                 ;519
000032  f7fffffe          BL       pds_peer_data_iterate
000036  2800              CMP      r0,#0                 ;519
000038  d1e7              BNE      |L21.10|
00003a  f64f70ff          MOV      r0,#0xffff            ;530
00003e  e7f4              B        |L21.42|
;;;532    
                          ENDP


                          AREA ||i.im_privacy_get||, CODE, READONLY, ALIGN=1

                  im_privacy_get PROC
;;;888    
;;;889    ret_code_t im_privacy_get(pm_privacy_params_t * p_privacy_params)
000000  b510              PUSH     {r4,lr}
;;;890    {
000002  4604              MOV      r4,r0
;;;891        #if (NRF_SD_BLE_API_VERSION <= 2)
;;;892    
;;;893            ble_gap_addr_t cur_addr;
;;;894            ble_opt_t      cur_privacy_opt;
;;;895    
;;;896            NRF_PM_DEBUG_CHECK(p_privacy_params               != NULL);
;;;897            NRF_PM_DEBUG_CHECK(p_privacy_params->p_device_irk != NULL);
;;;898    
;;;899            cur_privacy_opt.gap_opt.privacy.p_irk = p_privacy_params->p_device_irk;
;;;900    
;;;901            // Can not fail.
;;;902            (void) sd_ble_gap_address_get(&cur_addr);
;;;903    
;;;904            if (   cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
;;;905                || cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;906            {
;;;907                p_privacy_params->privacy_mode      = BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY;
;;;908                p_privacy_params->private_addr_type = cur_addr.addr_type;
;;;909            }
;;;910            else
;;;911            {
;;;912                p_privacy_params->privacy_mode = BLE_GAP_PRIVACY_MODE_OFF;
;;;913            }
;;;914    
;;;915            // Can not fail.
;;;916            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &cur_privacy_opt);
;;;917    
;;;918            p_privacy_params->private_addr_cycle_s = cur_privacy_opt.gap_opt.privacy.interval_s;
;;;919    
;;;920            return NRF_SUCCESS;
;;;921    
;;;922        #else
;;;923    
;;;924            return sd_ble_gap_privacy_get(p_privacy_params);
000004  4620              MOV      r0,r4
000006  df71              SVC      #0x71
;;;925    
;;;926        #endif
;;;927    }
000008  bd10              POP      {r4,pc}
;;;928    
                          ENDP


                          AREA ||i.im_privacy_set||, CODE, READONLY, ALIGN=1

                  im_privacy_set PROC
;;;839    
;;;840    ret_code_t im_privacy_set(pm_privacy_params_t const * p_privacy_params)
000000  b510              PUSH     {r4,lr}
;;;841    {
000002  4604              MOV      r4,r0
;;;842        #if (NRF_SD_BLE_API_VERSION <= 2)
;;;843    
;;;844            ret_code_t     ret;
;;;845            ble_gap_addr_t privacy_addr;
;;;846            ble_gap_irk_t  current_irk;
;;;847            ble_opt_t      privacy_options;
;;;848            ble_opt_t      current_privacy_options;
;;;849    
;;;850            NRF_PM_DEBUG_CHECK(p_privacy_params != NULL);
;;;851    
;;;852            privacy_addr.addr_type                        = p_privacy_params->private_addr_type;
;;;853            privacy_options.gap_opt.privacy.p_irk         = p_privacy_params->p_device_irk;
;;;854            privacy_options.gap_opt.privacy.interval_s    = p_privacy_params->private_addr_cycle_s;
;;;855            current_privacy_options.gap_opt.privacy.p_irk = &current_irk;
;;;856    
;;;857            // Can not fail.
;;;858            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
;;;859            (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &privacy_options);
;;;860    
;;;861            if (p_privacy_params->privacy_mode == BLE_GAP_PRIVACY_MODE_OFF)
;;;862            {
;;;863                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, &m_current_id_addr);
;;;864            }
;;;865            else
;;;866            {
;;;867                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &privacy_addr);
;;;868            }
;;;869    
;;;870            if (ret != NRF_SUCCESS)
;;;871            {
;;;872                // Restore previous settings.
;;;873                (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
;;;874            }
;;;875    
;;;876            // NRF_ERROR_BUSY,
;;;877            // NRF_ERROR_INVALID_STATE,
;;;878            // NRF_ERROR_INVALID_PARAM, if address type is not valid.
;;;879            return ret;
;;;880    
;;;881        #else
;;;882    
;;;883            return sd_ble_gap_privacy_set(p_privacy_params);
000004  4620              MOV      r0,r4
000006  df70              SVC      #0x70
;;;884    
;;;885        #endif
;;;886    }
000008  bd10              POP      {r4,pc}
;;;887    
                          ENDP


                          AREA ||i.im_whitelist_get||, CODE, READONLY, ALIGN=2

                  im_whitelist_get PROC
;;;932     */
;;;933    ret_code_t im_whitelist_get(ble_gap_addr_t * p_addrs,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;934                                uint32_t       * p_addr_cnt,
;;;935                                ble_gap_irk_t  * p_irks,
;;;936                                uint32_t       * p_irk_cnt)
;;;937    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;938        // One of the two buffers has to be provided.
;;;939        NRF_PM_DEBUG_CHECK((p_addrs    != NULL) || (p_irks    != NULL));
;;;940        NRF_PM_DEBUG_CHECK((p_addr_cnt != NULL) || (p_irk_cnt != NULL));
;;;941    
;;;942        if (((p_addr_cnt != NULL) && (m_wlisted_peer_cnt > *p_addr_cnt)) ||
00000c  b124              CBZ      r4,|L24.24|
00000e  490c              LDR      r1,|L24.64|
000010  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d305              BCC      |L24.36|
                  |L24.24|
;;;943            ((p_irk_cnt  != NULL) && (m_wlisted_peer_cnt > *p_irk_cnt)))
000018  b13d              CBZ      r5,|L24.42|
00001a  4909              LDR      r1,|L24.64|
00001c  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
00001e  6828              LDR      r0,[r5,#0]
000020  4288              CMP      r0,r1
000022  d202              BCS      |L24.42|
                  |L24.36|
;;;944        {
;;;945            // The size of the cached list of peers is larger than the provided buffers.
;;;946            return NRF_ERROR_NO_MEM;
000024  2004              MOVS     r0,#4
                  |L24.38|
;;;947        }
;;;948    
;;;949        // NRF_SUCCESS or
;;;950        // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;951        // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;952        return peers_id_keys_get(m_wlisted_peers, m_wlisted_peer_cnt,
;;;953                                 p_addrs, p_addr_cnt,
;;;954                                 p_irks,  p_irk_cnt);
;;;955    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L24.42|
00002a  4623              MOV      r3,r4                 ;952
00002c  4632              MOV      r2,r6                 ;952
00002e  4804              LDR      r0,|L24.64|
000030  e9cd7500          STRD     r7,r5,[sp,#0]         ;952
000034  7801              LDRB     r1,[r0,#0]            ;952  ; m_wlisted_peer_cnt
000036  4803              LDR      r0,|L24.68|
000038  f7fffffe          BL       peers_id_keys_get
00003c  e7f3              B        |L24.38|
;;;956    
                          ENDP

00003e  0000              DCW      0x0000
                  |L24.64|
                          DCD      m_wlisted_peer_cnt
                  |L24.68|
                          DCD      m_wlisted_peers

                          AREA ||i.im_whitelist_set||, CODE, READONLY, ALIGN=2

                  im_whitelist_set PROC
;;;962     */
;;;963    ret_code_t im_whitelist_set(pm_peer_id_t const * p_peers,
000000  b570              PUSH     {r4-r6,lr}
;;;964                                uint32_t             peer_cnt)
;;;965    {
000002  b09a              SUB      sp,sp,#0x68
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;966        // Clear the cache of whitelisted peers.
;;;967        memset(m_wlisted_peers, 0x00, sizeof(m_wlisted_peers));
000008  2110              MOVS     r1,#0x10
00000a  481b              LDR      r0,|L25.120|
00000c  f7fffffe          BL       __aeabi_memclr
;;;968    
;;;969        if ((p_peers == NULL) || (peer_cnt == 0))
000010  b105              CBZ      r5,|L25.20|
000012  b93c              CBNZ     r4,|L25.36|
                  |L25.20|
;;;970        {
;;;971            // Clear the current whitelist.
;;;972            m_wlisted_peer_cnt = 0;
000014  2000              MOVS     r0,#0
000016  4919              LDR      r1,|L25.124|
000018  7008              STRB     r0,[r1,#0]
;;;973            #if (NRF_SD_BLE_API_VERSION >= 3)
;;;974                // NRF_SUCCESS, or
;;;975                // BLE_GAP_ERROR_WHITELIST_IN_USE
;;;976                return sd_ble_gap_whitelist_set(NULL, 0);
00001a  2100              MOVS     r1,#0
00001c  4608              MOV      r0,r1
00001e  df6e              SVC      #0x6e
                  |L25.32|
;;;977            #else
;;;978                // The cached list of whitelisted peers is already cleared; nothing to do.
;;;979                return NRF_SUCCESS;
;;;980            #endif
;;;981        }
;;;982    
;;;983        // @todo emdi: should not ever cache more than BLE_GAP_WHITELIST_ADDR_MAX_COUNT...
;;;984    
;;;985        // Copy the new whitelisted peers.
;;;986        m_wlisted_peer_cnt = peer_cnt;
;;;987        memcpy(m_wlisted_peers, p_peers, sizeof(pm_peer_id_t) * peer_cnt);
;;;988    
;;;989        #if (NRF_SD_BLE_API_VERSION >= 3)
;;;990    
;;;991            ret_code_t ret;
;;;992            uint32_t   wlist_addr_cnt = 0;
;;;993    
;;;994            ble_gap_addr_t const * addr_ptrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;995            ble_gap_addr_t         addrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;996    
;;;997            memset(addrs, 0x00, sizeof(addrs));
;;;998    
;;;999            // Fetch GAP addresses for these peers, but don't fetch IRKs.
;;;1000           ret = peers_id_keys_get(p_peers, peer_cnt, addrs, &wlist_addr_cnt, NULL, NULL);
;;;1001   
;;;1002           if (ret != NRF_SUCCESS)
;;;1003           {
;;;1004               // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;1005               // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;1006               return ret;
;;;1007           }
;;;1008   
;;;1009           for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)
;;;1010           {
;;;1011               addr_ptrs[i] = &addrs[i];
;;;1012           }
;;;1013   
;;;1014           // NRF_ERROR_DATA_SIZE,             if peer_cnt > BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
;;;1015           // BLE_ERROR_GAP_WHITELIST_IN_USE,  if a whitelist is in use.
;;;1016           return sd_ble_gap_whitelist_set(addr_ptrs, peer_cnt);
;;;1017   
;;;1018       #else
;;;1019   
;;;1020           return NRF_SUCCESS;
;;;1021   
;;;1022       #endif
;;;1023   }
000020  b01a              ADD      sp,sp,#0x68
000022  bd70              POP      {r4-r6,pc}
                  |L25.36|
000024  4915              LDR      r1,|L25.124|
000026  700c              STRB     r4,[r1,#0]            ;986
000028  0062              LSLS     r2,r4,#1              ;987
00002a  4629              MOV      r1,r5                 ;987
00002c  4812              LDR      r0,|L25.120|
00002e  f7fffffe          BL       __aeabi_memcpy
000032  2000              MOVS     r0,#0                 ;992
000034  9019              STR      r0,[sp,#0x64]         ;992
000036  2138              MOVS     r1,#0x38              ;997
000038  a803              ADD      r0,sp,#0xc            ;997
00003a  f7fffffe          BL       __aeabi_memclr4
00003e  2000              MOVS     r0,#0                 ;1000
000040  9000              STR      r0,[sp,#0]            ;1000
000042  ab19              ADD      r3,sp,#0x64           ;1000
000044  aa03              ADD      r2,sp,#0xc            ;1000
000046  4621              MOV      r1,r4                 ;1000
000048  9001              STR      r0,[sp,#4]            ;1000
00004a  4628              MOV      r0,r5                 ;1000
00004c  f7fffffe          BL       peers_id_keys_get
000050  4606              MOV      r6,r0                 ;1000
000052  b10e              CBZ      r6,|L25.88|
000054  4630              MOV      r0,r6                 ;1006
000056  e7e3              B        |L25.32|
                  |L25.88|
000058  2000              MOVS     r0,#0                 ;1009
00005a  e007              B        |L25.108|
                  |L25.92|
00005c  ebc001c0          RSB      r1,r0,r0,LSL #3       ;1011
000060  aa03              ADD      r2,sp,#0xc            ;1011
000062  4411              ADD      r1,r1,r2              ;1011
000064  aa11              ADD      r2,sp,#0x44           ;1011
000066  f8421020          STR      r1,[r2,r0,LSL #2]     ;1011
00006a  1c40              ADDS     r0,r0,#1              ;1009
                  |L25.108|
00006c  2808              CMP      r0,#8                 ;1009
00006e  d3f5              BCC      |L25.92|
000070  b2e1              UXTB     r1,r4                 ;1016
000072  a811              ADD      r0,sp,#0x44           ;1016
000074  df6e              SVC      #0x6e                 ;1016
000076  e7d3              B        |L25.32|
;;;1024   
                          ENDP

                  |L25.120|
                          DCD      m_wlisted_peers
                  |L25.124|
                          DCD      m_wlisted_peer_cnt

                          AREA ||i.internal_state_reset||, CODE, READONLY, ALIGN=2

                  internal_state_reset PROC
;;;94     
;;;95     static void internal_state_reset()
000000  2018              MOVS     r0,#0x18
;;;96     {
;;;97         m_conn_state_user_flag_id = BLE_CONN_STATE_USER_FLAG_INVALID;
000002  4908              LDR      r1,|L26.36|
000004  7008              STRB     r0,[r1,#0]
;;;98     
;;;99         for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000006  2000              MOVS     r0,#0
000008  e008              B        |L26.28|
                  |L26.10|
;;;100        {
;;;101            m_connections[i].conn_handle = BLE_CONN_HANDLE_INVALID;
00000a  f64f71ff          MOV      r1,#0xffff
00000e  eb000240          ADD      r2,r0,r0,LSL #1
000012  4b05              LDR      r3,|L26.40|
000014  eb030282          ADD      r2,r3,r2,LSL #2
000018  8051              STRH     r1,[r2,#2]
00001a  1c40              ADDS     r0,r0,#1              ;99
                  |L26.28|
00001c  2814              CMP      r0,#0x14              ;99
00001e  d3f4              BCC      |L26.10|
;;;102        }
;;;103    }
000020  4770              BX       lr
;;;104    
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      m_conn_state_user_flag_id
                  |L26.40|
                          DCD      m_connections

                          AREA ||i.is_valid_irk||, CODE, READONLY, ALIGN=1

                  is_valid_irk PROC
;;;208     */
;;;209    bool is_valid_irk(ble_gap_irk_t const * p_irk)
000000  4602              MOV      r2,r0
;;;210    {
;;;211        NRF_PM_DEBUG_CHECK(p_irk != NULL);
;;;212    
;;;213        for (uint32_t i = 0; i < BLE_GAP_SEC_KEY_LEN; i++)
000002  2100              MOVS     r1,#0
000004  e004              B        |L27.16|
                  |L27.6|
;;;214        {
;;;215            if (p_irk->irk[i] != 0)
000006  5c50              LDRB     r0,[r2,r1]
000008  b108              CBZ      r0,|L27.14|
;;;216            {
;;;217                return true;
00000a  2001              MOVS     r0,#1
                  |L27.12|
;;;218            }
;;;219        }
;;;220        return false;
;;;221    }
00000c  4770              BX       lr
                  |L27.14|
00000e  1c49              ADDS     r1,r1,#1              ;213
                  |L27.16|
000010  2910              CMP      r1,#0x10              ;213
000012  d3f8              BCC      |L27.6|
000014  2000              MOVS     r0,#0                 ;220
000016  e7f9              B        |L27.12|
;;;222    
                          ENDP


                          AREA ||i.new_connection||, CODE, READONLY, ALIGN=2

                  new_connection PROC
;;;174     */
;;;175    uint8_t new_connection(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;176    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;177        uint8_t conn_index = IM_NO_INVALID_CONN_HANDLES;
000006  24ff              MOVS     r4,#0xff
;;;178    
;;;179        if ((p_ble_addr != NULL) && (conn_handle != BLE_CONN_HANDLE_INVALID))
000008  b366              CBZ      r6,|L28.100|
00000a  f64f70ff          MOV      r0,#0xffff
00000e  4285              CMP      r5,r0
000010  d028              BEQ      |L28.100|
;;;180        {
;;;181            ble_conn_state_user_flag_set(conn_handle, m_conn_state_user_flag_id, true);
000012  2201              MOVS     r2,#1
000014  4814              LDR      r0,|L28.104|
000016  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       ble_conn_state_user_flag_set
;;;182    
;;;183            conn_index = get_connection_by_conn_handle(conn_handle);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       get_connection_by_conn_handle
000024  4604              MOV      r4,r0
;;;184            if (conn_index == IM_NO_INVALID_CONN_HANDLES)
000026  2cff              CMP      r4,#0xff
000028  d102              BNE      |L28.48|
;;;185            {
;;;186                conn_index = get_free_connection();
00002a  f7fffffe          BL       get_free_connection
00002e  4604              MOV      r4,r0
                  |L28.48|
;;;187            }
;;;188    
;;;189            if (conn_index != IM_NO_INVALID_CONN_HANDLES)
000030  2cff              CMP      r4,#0xff
000032  d017              BEQ      |L28.100|
;;;190            {
;;;191                m_connections[conn_index].conn_handle  = conn_handle;
000034  eb040044          ADD      r0,r4,r4,LSL #1
000038  490c              LDR      r1,|L28.108|
00003a  eb010080          ADD      r0,r1,r0,LSL #2
00003e  8045              STRH     r5,[r0,#2]
;;;192                m_connections[conn_index].peer_id      = PM_PEER_ID_INVALID;
000040  f64f70ff          MOV      r0,#0xffff
000044  eb040144          ADD      r1,r4,r4,LSL #1
000048  4a08              LDR      r2,|L28.108|
00004a  f8220021          STRH     r0,[r2,r1,LSL #2]
;;;193                m_connections[conn_index].peer_address = *p_ble_addr;
00004e  eb040044          ADD      r0,r4,r4,LSL #1
000052  4611              MOV      r1,r2
000054  eb010080          ADD      r0,r1,r0,LSL #2
000058  6831              LDR      r1,[r6,#0]
00005a  6041              STR      r1,[r0,#4]
00005c  88b1              LDRH     r1,[r6,#4]
00005e  8101              STRH     r1,[r0,#8]
000060  79b1              LDRB     r1,[r6,#6]
000062  7281              STRB     r1,[r0,#0xa]
                  |L28.100|
;;;194            }
;;;195        }
;;;196        return conn_index;
000064  4620              MOV      r0,r4
;;;197    }
000066  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

                  |L28.104|
                          DCD      m_conn_state_user_flag_id
                  |L28.108|
                          DCD      m_connections

                          AREA ||i.peer_id_set||, CODE, READONLY, ALIGN=2

                  peer_id_set PROC
;;;573     */
;;;574    static void peer_id_set(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;575    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;576        uint8_t conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;577        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d004              BEQ      |L29.28|
;;;578        {
;;;579            m_connections[conn_index].peer_id = peer_id;
000012  eb050045          ADD      r0,r5,r5,LSL #1
000016  4902              LDR      r1,|L29.32|
000018  f8214020          STRH     r4,[r1,r0,LSL #2]
                  |L29.28|
;;;580        }
;;;581    }
00001c  bd70              POP      {r4-r6,pc}
;;;582    
                          ENDP

00001e  0000              DCW      0x0000
                  |L29.32|
                          DCD      m_connections

                          AREA ||i.peers_id_keys_get||, CODE, READONLY, ALIGN=1

                  peers_id_keys_get PROC
;;;611     */
;;;612    static ret_code_t peers_id_keys_get(pm_peer_id_t   const * p_peers,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;613                                        uint32_t               peer_cnt,
;;;614                                        ble_gap_addr_t       * p_gap_addrs,
;;;615                                        uint32_t             * p_addr_cnt,
;;;616                                        ble_gap_irk_t        * p_gap_irks,
;;;617                                        uint32_t             * p_irk_cnt)
;;;618    {
000004  b099              SUB      sp,sp,#0x64
000006  4682              MOV      r10,r0
000008  468b              MOV      r11,r1
00000a  4690              MOV      r8,r2
00000c  461c              MOV      r4,r3
00000e  9e23              LDR      r6,[sp,#0x8c]
;;;619        ret_code_t ret;
;;;620    
;;;621        pm_peer_data_bonding_t bond_data;
;;;622        pm_peer_data_t         peer_data;
;;;623    
;;;624        uint32_t const buf_size = sizeof(bond_data);
000010  2050              MOVS     r0,#0x50
000012  9002              STR      r0,[sp,#8]
;;;625    
;;;626        bool copy_addrs = false;
000014  2000              MOVS     r0,#0
000016  9001              STR      r0,[sp,#4]
;;;627        bool copy_irks  = false;
000018  9000              STR      r0,[sp,#0]
;;;628    
;;;629        NRF_PM_DEBUG_CHECK(p_peers != NULL);
;;;630    
;;;631        // One of these two has to be provided.
;;;632        NRF_PM_DEBUG_CHECK((p_gap_addrs != NULL) || (p_gap_irks != NULL));
;;;633    
;;;634        if ((p_gap_addrs != NULL) && (p_addr_cnt != NULL))
00001a  f1b80f00          CMP      r8,#0
00001e  d004              BEQ      |L30.42|
000020  b11c              CBZ      r4,|L30.42|
;;;635        {
;;;636            NRF_PM_DEBUG_CHECK((*p_addr_cnt) >= peer_cnt);
;;;637    
;;;638            copy_addrs  = true;
000022  2001              MOVS     r0,#1
000024  9001              STR      r0,[sp,#4]
;;;639            *p_addr_cnt = 0;
000026  2000              MOVS     r0,#0
000028  6020              STR      r0,[r4,#0]
                  |L30.42|
;;;640        }
;;;641    
;;;642        if ((p_gap_irks != NULL) && (p_irk_cnt != NULL))
00002a  9822              LDR      r0,[sp,#0x88]
00002c  b120              CBZ      r0,|L30.56|
00002e  b11e              CBZ      r6,|L30.56|
;;;643        {
;;;644            NRF_PM_DEBUG_CHECK((*p_irk_cnt) >= peer_cnt);
;;;645    
;;;646            copy_irks  = true;
000030  2001              MOVS     r0,#1
000032  9000              STR      r0,[sp,#0]
;;;647            *p_irk_cnt = 0;
000034  2000              MOVS     r0,#0
000036  6030              STR      r0,[r6,#0]
                  |L30.56|
;;;648        }
;;;649    
;;;650        memset(&peer_data, 0x00, sizeof(peer_data));
000038  2000              MOVS     r0,#0
00003a  9003              STR      r0,[sp,#0xc]
00003c  9004              STR      r0,[sp,#0x10]
;;;651        peer_data.p_bonding_data = &bond_data;
00003e  a805              ADD      r0,sp,#0x14
000040  9004              STR      r0,[sp,#0x10]
;;;652    
;;;653        // Read through flash memory and look for peers ID keys.
;;;654    
;;;655        for (uint32_t i = 0; i < peer_cnt; i++)
000042  2500              MOVS     r5,#0
000044  e041              B        |L30.202|
                  |L30.70|
;;;656        {
;;;657            memset(&bond_data, 0x00, sizeof(bond_data));
000046  2150              MOVS     r1,#0x50
000048  a805              ADD      r0,sp,#0x14
00004a  f7fffffe          BL       __aeabi_memclr4
;;;658    
;;;659            // Read peer data from flash.
;;;660            ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
00004e  f83a0015          LDRH     r0,[r10,r5,LSL #1]
000052  ab02              ADD      r3,sp,#8
000054  aa03              ADD      r2,sp,#0xc
000056  2107              MOVS     r1,#7
000058  f7fffffe          BL       pds_peer_data_read
00005c  4607              MOV      r7,r0
;;;661                                     &peer_data, &buf_size);
;;;662    
;;;663            if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
00005e  2f05              CMP      r7,#5
000060  d001              BEQ      |L30.102|
000062  2f07              CMP      r7,#7
000064  d103              BNE      |L30.110|
                  |L30.102|
;;;664            {
;;;665                // Peer data coulnd't be found in flash or peer ID is not valid.
;;;666                return NRF_ERROR_NOT_FOUND;
000066  2005              MOVS     r0,#5
                  |L30.104|
;;;667            }
;;;668    
;;;669            uint8_t const addr_type = bond_data.peer_ble_id.id_addr_info.addr_type;
;;;670    
;;;671            if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;672                (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;673            {
;;;674                // The address shared by the peer during bonding can't be used for whitelisting.
;;;675                return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;676            }
;;;677    
;;;678            // Copy the GAP address.
;;;679            if (copy_addrs)
;;;680            {
;;;681                memcpy(&p_gap_addrs[i], &bond_data.peer_ble_id.id_addr_info, sizeof(ble_gap_addr_t));
;;;682                (*p_addr_cnt)++;
;;;683            }
;;;684    
;;;685            // Copy the IRK.
;;;686            if (copy_irks)
;;;687            {
;;;688                memcpy(&p_gap_irks[i], bond_data.peer_ble_id.id_info.irk, BLE_GAP_SEC_KEY_LEN);
;;;689                (*p_irk_cnt)++;
;;;690            }
;;;691        }
;;;692    
;;;693        return NRF_SUCCESS;
;;;694    }
000068  b019              ADD      sp,sp,#0x64
00006a  e8bd8ff0          POP      {r4-r11,pc}
                  |L30.110|
00006e  a805              ADD      r0,sp,#0x14           ;669
000070  7c40              LDRB     r0,[r0,#0x11]         ;669
000072  ea4f0950          LSR      r9,r0,#1              ;669
000076  f1b90f00          CMP      r9,#0                 ;671
00007a  d005              BEQ      |L30.136|
00007c  f1b90f01          CMP      r9,#1                 ;672
000080  d002              BEQ      |L30.136|
000082  f2432002          MOV      r0,#0x3202            ;675
000086  e7ef              B        |L30.104|
                  |L30.136|
000088  9801              LDR      r0,[sp,#4]            ;679
00008a  b180              CBZ      r0,|L30.174|
00008c  ebc500c5          RSB      r0,r5,r5,LSL #3       ;681
000090  eb000108          ADD      r1,r0,r8              ;681
000094  f10d0015          ADD      r0,sp,#0x15           ;681
000098  f8dd2025          LDR      r2,[sp,#0x25]         ;681
00009c  600a              STR      r2,[r1,#0]            ;681
00009e  f8bd2029          LDRH     r2,[sp,#0x29]         ;681
0000a2  808a              STRH     r2,[r1,#4]            ;681
0000a4  7d80              LDRB     r0,[r0,#0x16]         ;681
0000a6  7188              STRB     r0,[r1,#6]            ;681
0000a8  6820              LDR      r0,[r4,#0]            ;682
0000aa  1c40              ADDS     r0,r0,#1              ;682
0000ac  6020              STR      r0,[r4,#0]            ;682
                  |L30.174|
0000ae  9800              LDR      r0,[sp,#0]            ;686
0000b0  b150              CBZ      r0,|L30.200|
0000b2  9922              LDR      r1,[sp,#0x88]         ;688
0000b4  eb011005          ADD      r0,r1,r5,LSL #4       ;688
0000b8  2210              MOVS     r2,#0x10              ;688
0000ba  f10d0115          ADD      r1,sp,#0x15           ;688
0000be  f7fffffe          BL       __aeabi_memcpy
0000c2  6830              LDR      r0,[r6,#0]            ;689
0000c4  1c40              ADDS     r0,r0,#1              ;689
0000c6  6030              STR      r0,[r6,#0]            ;689
                  |L30.200|
0000c8  1c6d              ADDS     r5,r5,#1              ;655
                  |L30.202|
0000ca  455d              CMP      r5,r11                ;655
0000cc  d3bb              BCC      |L30.70|
0000ce  2000              MOVS     r0,#0                 ;693
0000d0  e7ca              B        |L30.104|
;;;695    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  m_connections
                          %        240
                  m_wlisted_peers
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      pm_im_evt_handler
                          DCD      gcm_im_evt_handler

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_conn_state_user_flag_id
000001  00                DCB      0x00
                  m_wlisted_peer_cnt
000002  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\id_manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_id_manager_c_40579113____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REVSH|
#line 402
|__asm___12_id_manager_c_40579113____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____RRX|
#line 587
|__asm___12_id_manager_c_40579113____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
