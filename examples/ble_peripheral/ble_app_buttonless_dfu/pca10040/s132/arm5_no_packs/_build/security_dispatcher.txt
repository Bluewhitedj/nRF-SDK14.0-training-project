; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\security_dispatcher.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\security_dispatcher.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\security_dispatcher.crf ..\..\..\..\..\..\components\ble\peer_manager\security_dispatcher.c]
                          THUMB

                          AREA ||i.auth_status_failure_process||, CODE, READONLY, ALIGN=1

                  auth_status_failure_process PROC
;;;460     */
;;;461    static void auth_status_failure_process(ble_gap_evt_t const * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463        link_secure_failure(p_gap_evt->conn_handle,
000004  7963              LDRB     r3,[r4,#5]
000006  f0030203          AND      r2,r3,#3
00000a  7921              LDRB     r1,[r4,#4]
00000c  8820              LDRH     r0,[r4,#0]
00000e  f7fffffe          BL       link_secure_failure
;;;464                            p_gap_evt->params.auth_status.auth_status,
;;;465                            p_gap_evt->params.auth_status.error_src);
;;;466    }
000012  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.auth_status_process||, CODE, READONLY, ALIGN=1

                  auth_status_process PROC
;;;472     */
;;;473    static void auth_status_process(ble_gap_evt_t const * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;474    {
000002  4604              MOV      r4,r0
;;;475        switch (p_gap_evt->params.auth_status.auth_status)
000004  7920              LDRB     r0,[r4,#4]
000006  b918              CBNZ     r0,|L2.16|
;;;476        {
;;;477            case BLE_GAP_SEC_STATUS_SUCCESS:
;;;478                auth_status_success_process(p_gap_evt);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       auth_status_success_process
;;;479                break;
00000e  e003              B        |L2.24|
                  |L2.16|
;;;480    
;;;481            default:
;;;482                auth_status_failure_process(p_gap_evt);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       auth_status_failure_process
;;;483                break;
000016  bf00              NOP      
                  |L2.24|
000018  bf00              NOP                            ;479
;;;484        }
;;;485    }
00001a  bd10              POP      {r4,pc}
;;;486    
                          ENDP


                          AREA ||i.auth_status_success_process||, CODE, READONLY, ALIGN=2

                  auth_status_success_process PROC
;;;271     */
;;;272    static void auth_status_success_process(ble_gap_evt_t const * p_gap_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;273    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
;;;274        ret_code_t           err_code   = NRF_SUCCESS;
000008  2500              MOVS     r5,#0
;;;275        uint8_t              role       = ble_conn_state_role(p_gap_evt->conn_handle);
00000a  8820              LDRH     r0,[r4,#0]
00000c  f7fffffe          BL       ble_conn_state_role
000010  4607              MOV      r7,r0
;;;276        pm_peer_id_t         peer_id    = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000012  8820              LDRH     r0,[r4,#0]
000014  f7fffffe          BL       im_peer_id_get_by_conn_handle
000018  4606              MOV      r6,r0
;;;277        ble_gap_sec_kdist_t  kdist_own  = p_gap_evt->params.auth_status.kdist_own;
00001a  68a0              LDR      r0,[r4,#8]
00001c  9007              STR      r0,[sp,#0x1c]
;;;278        ble_gap_sec_kdist_t  kdist_peer = p_gap_evt->params.auth_status.kdist_peer;
00001e  7a60              LDRB     r0,[r4,#9]
000020  9006              STR      r0,[sp,#0x18]
;;;279    
;;;280        ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
000022  8820              LDRH     r0,[r4,#0]
000024  2200              MOVS     r2,#0
000026  4923              LDR      r1,|L3.180|
000028  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
00002a  f7fffffe          BL       ble_conn_state_user_flag_set
;;;281    
;;;282        if (role == BLE_GAP_ROLE_INVALID)
00002e  b917              CBNZ     r7,|L3.54|
                  |L3.48|
;;;283        {
;;;284            /* Unlikely, but maybe possible? */
;;;285            return;
;;;286        }
;;;287    
;;;288        if (p_gap_evt->params.auth_status.bonded)
;;;289        {
;;;290    
;;;291            err_code = pdb_write_buf_store(peer_id, PM_PEER_DATA_ID_BONDING);
;;;292            if (err_code != NRF_SUCCESS)
;;;293            {
;;;294                /* Unexpected */
;;;295                smd_evt_t error_evt;
;;;296    
;;;297                error_evt.evt_id                            = SMD_EVT_ERROR_BONDING_INFO;
;;;298                error_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;299                error_evt.params.error_bonding_info.peer_id = peer_id;
;;;300                error_evt.params.error_bonding_info.error   = err_code;
;;;301    
;;;302                evt_send(&error_evt);
;;;303            }
;;;304    
;;;305        }
;;;306        else if (ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_new_peer))
;;;307        {
;;;308            ret_code_t err_code_free = im_peer_free(peer_id);
;;;309            UNUSED_VARIABLE(err_code_free); // Errors can be safely ignored.
;;;310        }
;;;311    
;;;312        smd_evt_t pairing_success_evt;
;;;313    
;;;314        pairing_success_evt.evt_id                            = SMD_EVT_PAIRING_SUCCESS;
;;;315        pairing_success_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;316        pairing_success_evt.params.pairing_success.bonded     = p_gap_evt->params.auth_status.bonded;
;;;317        pairing_success_evt.params.pairing_success.mitm       = p_gap_evt->params.auth_status.sm1_levels.lv3;
;;;318        pairing_success_evt.params.pairing_success.kdist_own  = kdist_own;
;;;319        pairing_success_evt.params.pairing_success.kdist_peer = kdist_peer;
;;;320    
;;;321        evt_send(&pairing_success_evt);
;;;322        return;
;;;323    }
000030  b008              ADD      sp,sp,#0x20
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L3.54|
000036  7960              LDRB     r0,[r4,#5]            ;288
000038  f3c00080          UBFX     r0,r0,#2,#1           ;288
00003c  b190              CBZ      r0,|L3.100|
00003e  2107              MOVS     r1,#7                 ;291
000040  4630              MOV      r0,r6                 ;291
000042  f7fffffe          BL       pdb_write_buf_store
000046  4605              MOV      r5,r0                 ;291
000048  b1bd              CBZ      r5,|L3.122|
00004a  2008              MOVS     r0,#8                 ;297
00004c  f88d0000          STRB     r0,[sp,#0]            ;297
000050  8820              LDRH     r0,[r4,#0]            ;298
000052  f8ad0002          STRH     r0,[sp,#2]            ;298
000056  f8ad6004          STRH     r6,[sp,#4]            ;299
00005a  9502              STR      r5,[sp,#8]            ;300
00005c  4668              MOV      r0,sp                 ;302
00005e  f7fffffe          BL       evt_send
000062  e00a              B        |L3.122|
                  |L3.100|
000064  8820              LDRH     r0,[r4,#0]            ;306
000066  4914              LDR      r1,|L3.184|
000068  7809              LDRB     r1,[r1,#0]            ;306  ; m_flag_sec_proc_new_peer
00006a  f7fffffe          BL       ble_conn_state_user_flag_get
00006e  b120              CBZ      r0,|L3.122|
000070  4630              MOV      r0,r6                 ;308
000072  f7fffffe          BL       im_peer_free
000076  4680              MOV      r8,r0                 ;308
000078  bf00              NOP                            ;310
                  |L3.122|
00007a  2003              MOVS     r0,#3                 ;314
00007c  f88d000c          STRB     r0,[sp,#0xc]          ;314
000080  8820              LDRH     r0,[r4,#0]            ;315
000082  f8ad000e          STRH     r0,[sp,#0xe]          ;315
000086  7960              LDRB     r0,[r4,#5]            ;316
000088  f3c00080          UBFX     r0,r0,#2,#1           ;316
00008c  f88d0010          STRB     r0,[sp,#0x10]         ;316
000090  79a0              LDRB     r0,[r4,#6]            ;317
000092  f3c00180          UBFX     r1,r0,#2,#1           ;317
000096  f88d1011          STRB     r1,[sp,#0x11]         ;317
00009a  f89d101c          LDRB     r1,[sp,#0x1c]         ;318
00009e  f88d1012          STRB     r1,[sp,#0x12]         ;318
0000a2  f89d1018          LDRB     r1,[sp,#0x18]         ;319
0000a6  f88d1013          STRB     r1,[sp,#0x13]         ;319
0000aa  a803              ADD      r0,sp,#0xc            ;321
0000ac  f7fffffe          BL       evt_send
0000b0  bf00              NOP                            ;322
0000b2  e7bd              B        |L3.48|
;;;324    
                          ENDP

                  |L3.180|
                          DCD      m_flag_sec_proc
                  |L3.184|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.conn_sec_update_process||, CODE, READONLY, ALIGN=2

                  conn_sec_update_process PROC
;;;491     */
;;;492    static void conn_sec_update_process(ble_gap_evt_t const * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;493    {
000002  4604              MOV      r4,r0
;;;494        if (ble_conn_state_encrypted(p_gap_evt->conn_handle))
000004  8820              LDRH     r0,[r4,#0]
000006  f7fffffe          BL       ble_conn_state_encrypted
00000a  b1d0              CBZ      r0,|L4.66|
;;;495        {
;;;496            if (!ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_pairing))
00000c  8820              LDRH     r0,[r4,#0]
00000e  4910              LDR      r1,|L4.80|
000010  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc_pairing
000012  f7fffffe          BL       ble_conn_state_user_flag_get
000016  b928              CBNZ     r0,|L4.36|
;;;497            {
;;;498                ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
000018  8820              LDRH     r0,[r4,#0]
00001a  2200              MOVS     r2,#0
00001c  490d              LDR      r1,|L4.84|
00001e  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
000020  f7fffffe          BL       ble_conn_state_user_flag_set
                  |L4.36|
;;;499            }
;;;500    
;;;501            smd_evt_t evt;
;;;502    
;;;503            evt.conn_handle = p_gap_evt->conn_handle;
000024  8820              LDRH     r0,[r4,#0]
000026  f8ad0002          STRH     r0,[sp,#2]
;;;504            evt.evt_id = SMD_EVT_LINK_ENCRYPTION_UPDATE;
00002a  2005              MOVS     r0,#5
00002c  f88d0000          STRB     r0,[sp,#0]
;;;505            evt.params.link_encryption_update.mitm_protected
000030  8820              LDRH     r0,[r4,#0]
000032  f7fffffe          BL       ble_conn_state_mitm_protected
000036  f88d0004          STRB     r0,[sp,#4]
;;;506                                    = ble_conn_state_mitm_protected(p_gap_evt->conn_handle);
;;;507            evt_send(&evt);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       evt_send
;;;508        }
000040  e005              B        |L4.78|
                  |L4.66|
;;;509        else
;;;510        {
;;;511            encryption_failure(p_gap_evt->conn_handle,
000042  8820              LDRH     r0,[r4,#0]
000044  2201              MOVS     r2,#1
000046  f2410106          MOV      r1,#0x1006
00004a  f7fffffe          BL       encryption_failure
                  |L4.78|
;;;512                               PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING,
;;;513                               BLE_GAP_SEC_STATUS_SOURCE_REMOTE);
;;;514        }
;;;515    }
00004e  bd3e              POP      {r1-r5,pc}
;;;516    
                          ENDP

                  |L4.80|
                          DCD      m_flag_sec_proc_pairing
                  |L4.84|
                          DCD      m_flag_sec_proc

                          AREA ||i.disconnect_process||, CODE, READONLY, ALIGN=1

                  disconnect_process PROC
;;;445     */
;;;446    static void disconnect_process(ble_gap_evt_t const * p_gap_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4604              MOV      r4,r0
;;;448        pm_sec_error_code_t error = (p_gap_evt->params.disconnected.reason
000004  7920              LDRB     r0,[r4,#4]
000006  283d              CMP      r0,#0x3d
000008  d102              BNE      |L5.16|
;;;449                                            == BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE)
;;;450                                    ? PM_CONN_SEC_ERROR_MIC_FAILURE : PM_CONN_SEC_ERROR_DISCONNECT;
00000a  f241003d          MOV      r0,#0x103d
00000e  e001              B        |L5.20|
                  |L5.16|
000010  f44f5088          MOV      r0,#0x1100
                  |L5.20|
000014  4605              MOV      r5,r0
;;;451    
;;;452        link_secure_failure(p_gap_evt->conn_handle, error, BLE_GAP_SEC_STATUS_SOURCE_LOCAL);
000016  8820              LDRH     r0,[r4,#0]
000018  2200              MOVS     r2,#0
00001a  4629              MOV      r1,r5
00001c  f7fffffe          BL       link_secure_failure
;;;453    }
000020  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP


                          AREA ||i.encryption_failure||, CODE, READONLY, ALIGN=2

                  encryption_failure PROC
;;;386     */
;;;387    static void encryption_failure(uint16_t            conn_handle,
000000  b5fe              PUSH     {r1-r7,lr}
;;;388                                   pm_sec_error_code_t error,
;;;389                                   uint8_t             error_src)
;;;390    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;391        smd_evt_t evt =
000008  4a09              LDR      r2,|L6.48|
00000a  ca07              LDM      r2,{r0-r2}
00000c  e88d0007          STM      sp,{r0-r2}
000010  f8ad4002          STRH     r4,[sp,#2]
000014  f8ad5004          STRH     r5,[sp,#4]
000018  f88d6006          STRB     r6,[sp,#6]
;;;392        {
;;;393            .evt_id = SMD_EVT_LINK_ENCRYPTION_FAILED,
;;;394            .conn_handle = conn_handle,
;;;395            .params =
;;;396            {
;;;397                .link_encryption_failed =
;;;398                {
;;;399                    .error     = error,
;;;400                    .error_src = error_src,
;;;401                }
;;;402            }
;;;403        };
;;;404    
;;;405        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
00001c  2200              MOVS     r2,#0
00001e  4805              LDR      r0,|L6.52|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       ble_conn_state_user_flag_set
;;;406    
;;;407        evt_send(&evt);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       evt_send
;;;408        return;
;;;409    }
00002e  bdfe              POP      {r1-r7,pc}
;;;410    
                          ENDP

                  |L6.48|
                          DCD      ||.constdata||+0x38
                  |L6.52|
                          DCD      m_flag_sec_proc

                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;77     
;;;78     static void evt_send(smd_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;79     {
000002  4605              MOV      r5,r0
;;;80         for (uint32_t i = 0; i < SMD_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L7.20|
                  |L7.8|
;;;81         {
;;;82             m_evt_handlers[i](p_event);
000008  4804              LDR      r0,|L7.28|
00000a  f8501024          LDR      r1,[r0,r4,LSL #2]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;80
                  |L7.20|
000014  2c02              CMP      r4,#2                 ;80
000016  d3f7              BCC      |L7.8|
;;;83         }
;;;84     }
000018  bd70              POP      {r4-r6,pc}
;;;85     
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      m_evt_handlers

                          AREA ||i.flag_id_init||, CODE, READONLY, ALIGN=1

                  flag_id_init PROC
;;;521     */
;;;522    static void flag_id_init(ble_conn_state_user_flag_id_t * p_flag_id)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        if (*p_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
000004  7820              LDRB     r0,[r4,#0]
000006  2818              CMP      r0,#0x18
000008  d102              BNE      |L8.16|
;;;525        {
;;;526            *p_flag_id = ble_conn_state_user_flag_acquire();
00000a  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000e  7020              STRB     r0,[r4,#0]
                  |L8.16|
;;;527        }
;;;528    }
000010  bd10              POP      {r4,pc}
;;;529    
                          ENDP


                          AREA ||i.link_secure_central||, CODE, READONLY, ALIGN=1

                  link_secure_central PROC
;;;786    
;;;787    static ret_code_t link_secure_central(uint16_t               conn_handle,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;788                                          ble_gap_sec_params_t * p_sec_params,
;;;789                                          bool                   force_repairing)
;;;790    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;791        ret_code_t           err_code;
;;;792        pm_peer_id_t         peer_id;
;;;793    
;;;794        if (p_sec_params == NULL)
00000a  b926              CBNZ     r6,|L9.22|
;;;795        {
;;;796            return sd_ble_gap_authenticate(conn_handle, NULL);
00000c  2100              MOVS     r1,#0
00000e  4638              MOV      r0,r7
000010  df7e              SVC      #0x7e
                  |L9.18|
;;;797        }
;;;798    
;;;799        pm_conn_sec_procedure_t procedure = p_sec_params->bond ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;800                                                               : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;801    
;;;802        peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;803    
;;;804        if (peer_id != PM_PEER_ID_INVALID)
;;;805        {
;;;806            // There is already data in flash for this peer.
;;;807            err_code = link_secure_central_existing_peer(conn_handle,
;;;808                                                         p_sec_params,
;;;809                                                         force_repairing,
;;;810                                                         peer_id,
;;;811                                                         &procedure);
;;;812        }
;;;813        else if (p_sec_params->bond)
;;;814        {
;;;815            // New peer is required.
;;;816            err_code = link_secure_central_new_peer(conn_handle, p_sec_params);
;;;817        }
;;;818        else
;;;819        {
;;;820            // No bonding, only pairing.
;;;821            err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
;;;822    
;;;823            sec_proc_start(conn_handle, peer_id, err_code == NRF_SUCCESS, true, false);
;;;824        }
;;;825    
;;;826        if (err_code == NRF_SUCCESS)
;;;827        {
;;;828            sec_start_send(conn_handle, procedure);
;;;829        }
;;;830    
;;;831        return err_code;
;;;832    }
000012  e8bd81fc          POP      {r2-r8,pc}
                  |L9.22|
000016  7830              LDRB     r0,[r6,#0]            ;799
000018  f0000001          AND      r0,r0,#1              ;799
00001c  b108              CBZ      r0,|L9.34|
00001e  2001              MOVS     r0,#1                 ;799
000020  e000              B        |L9.36|
                  |L9.34|
000022  2002              MOVS     r0,#2                 ;800
                  |L9.36|
000024  9001              STR      r0,[sp,#4]            ;800
000026  4638              MOV      r0,r7                 ;802
000028  f7fffffe          BL       im_peer_id_get_by_conn_handle
00002c  4605              MOV      r5,r0                 ;802
00002e  f64f70ff          MOV      r0,#0xffff            ;804
000032  4285              CMP      r5,r0                 ;804
000034  d009              BEQ      |L9.74|
000036  a801              ADD      r0,sp,#4              ;807
000038  462b              MOV      r3,r5                 ;807
00003a  4642              MOV      r2,r8                 ;807
00003c  4631              MOV      r1,r6                 ;807
00003e  9000              STR      r0,[sp,#0]            ;807
000040  4638              MOV      r0,r7                 ;807
000042  f7fffffe          BL       link_secure_central_existing_peer
000046  4604              MOV      r4,r0                 ;807
000048  e019              B        |L9.126|
                  |L9.74|
00004a  7830              LDRB     r0,[r6,#0]            ;813
00004c  f0000001          AND      r0,r0,#1              ;813
000050  b128              CBZ      r0,|L9.94|
000052  4631              MOV      r1,r6                 ;816
000054  4638              MOV      r0,r7                 ;816
000056  f7fffffe          BL       link_secure_central_new_peer
00005a  4604              MOV      r4,r0                 ;816
00005c  e00f              B        |L9.126|
                  |L9.94|
00005e  4631              MOV      r1,r6                 ;821
000060  4638              MOV      r0,r7                 ;821
000062  df7e              SVC      #0x7e                 ;821
000064  4604              MOV      r4,r0                 ;821
000066  2000              MOVS     r0,#0                 ;823
000068  9000              STR      r0,[sp,#0]            ;823
00006a  b90c              CBNZ     r4,|L9.112|
00006c  2001              MOVS     r0,#1                 ;823
00006e  e000              B        |L9.114|
                  |L9.112|
000070  2000              MOVS     r0,#0                 ;823
                  |L9.114|
000072  4602              MOV      r2,r0                 ;823
000074  2301              MOVS     r3,#1                 ;823
000076  4629              MOV      r1,r5                 ;823
000078  4638              MOV      r0,r7                 ;823
00007a  f7fffffe          BL       sec_proc_start
                  |L9.126|
00007e  b924              CBNZ     r4,|L9.138|
000080  f89d1004          LDRB     r1,[sp,#4]            ;828
000084  4638              MOV      r0,r7                 ;828
000086  f7fffffe          BL       sec_start_send
                  |L9.138|
00008a  4620              MOV      r0,r4                 ;831
00008c  e7c1              B        |L9.18|
;;;833    
                          ENDP


                          AREA ||i.link_secure_central_existing_peer||, CODE, READONLY, ALIGN=1

                  link_secure_central_existing_peer PROC
;;;664    
;;;665    static ret_code_t link_secure_central_existing_peer(uint16_t                  conn_handle,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;666                                                        ble_gap_sec_params_t    * p_sec_params,
;;;667                                                        bool                      force_repairing,
;;;668                                                        pm_peer_id_t              peer_id,
;;;669                                                        pm_conn_sec_procedure_t * procedure)
;;;670    {
000004  b085              SUB      sp,sp,#0x14
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9048          LDR      r9,[sp,#0x48]
;;;671        pm_peer_data_flash_t      peer_data;
;;;672        pm_peer_data_t            dummy_peer_data;
;;;673        ret_code_t                err_code;
;;;674        ble_gap_enc_key_t const * p_existing_key = NULL;
000010  2500              MOVS     r5,#0
;;;675        bool                      lesc = false;
000012  46aa              MOV      r10,r5
;;;676    
;;;677        err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
000014  aa03              ADD      r2,sp,#0xc
000016  2107              MOVS     r1,#7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       pdb_peer_data_ptr_get
00001e  4604              MOV      r4,r0
;;;678    
;;;679        if (err_code == NRF_SUCCESS)
000020  b96c              CBNZ     r4,|L10.62|
;;;680        {
;;;681            // Use peer's key since they are peripheral.
;;;682            p_existing_key = &(peer_data.p_bonding_data->peer_ltk);
000022  9804              LDR      r0,[sp,#0x10]
000024  f1000518          ADD      r5,r0,#0x18
;;;683    
;;;684            lesc = peer_data.p_bonding_data->own_ltk.enc_info.lesc;
000028  9804              LDR      r0,[sp,#0x10]
00002a  f8900044          LDRB     r0,[r0,#0x44]
00002e  f0000a01          AND      r10,r0,#1
;;;685            if  (lesc) // LESC was used during bonding.
000032  f1ba0f00          CMP      r10,#0
000036  d002              BEQ      |L10.62|
;;;686            {
;;;687                // For LESC, always use own key.
;;;688                p_existing_key = &(peer_data.p_bonding_data->own_ltk);
000038  9804              LDR      r0,[sp,#0x10]
00003a  f1000534          ADD      r5,r0,#0x34
                  |L10.62|
;;;689            }
;;;690        }
;;;691    
;;;692        if     (!force_repairing
00003e  f1b80f00          CMP      r8,#0
000042  d113              BNE      |L10.108|
;;;693             && (err_code == NRF_SUCCESS)
000044  b994              CBNZ     r4,|L10.108|
;;;694             && (p_existing_key != NULL)
000046  b18d              CBZ      r5,|L10.108|
;;;695             && (lesc || im_master_id_is_valid(&(p_existing_key->master_id)))) /* There is a valid LTK stored. */
000048  f1ba0f00          CMP      r10,#0
00004c  d104              BNE      |L10.88|
00004e  f1050012          ADD      r0,r5,#0x12
000052  f7fffffe          BL       im_master_id_is_valid
000056  b148              CBZ      r0,|L10.108|
                  |L10.88|
;;;696             //&& (p_existing_key->enc_info.auth >= p_sec_params->mitm)          /* The requested MITM security is at or below the existing level. */
;;;697             //&& (!p_sec_params->mitm || (lesc >= p_sec_params->lesc)))         /* The requested LESC security is at or below the existing level. We only care about LESC if MITM is required. */
;;;698        {
;;;699            err_code = sd_ble_gap_encrypt(conn_handle, &(p_existing_key->master_id), &(p_existing_key->enc_info));
000058  462a              MOV      r2,r5
00005a  f1050112          ADD      r1,r5,#0x12
00005e  9805              LDR      r0,[sp,#0x14]
000060  df85              SVC      #0x85
000062  4604              MOV      r4,r0
;;;700    
;;;701            *procedure = PM_LINK_SECURED_PROCEDURE_ENCRYPTION;
000064  2000              MOVS     r0,#0
000066  f8890000          STRB     r0,[r9,#0]
00006a  e027              B        |L10.188|
                  |L10.108|
;;;702        }
;;;703        else if ((err_code == NRF_SUCCESS) || (err_code == NRF_ERROR_NOT_FOUND))
00006c  b10c              CBZ      r4,|L10.114|
00006e  2c05              CMP      r4,#5
000070  d124              BNE      |L10.188|
                  |L10.114|
;;;704        {
;;;705            /* Re-pairing is needed, because there is no LTK available or the existing key is not
;;;706               secure enough */
;;;707            err_code = NRF_SUCCESS;
000072  2400              MOVS     r4,#0
;;;708    
;;;709            if (p_sec_params->bond)
000074  7838              LDRB     r0,[r7,#0]
000076  f0000001          AND      r0,r0,#1
00007a  b160              CBZ      r0,|L10.150|
;;;710            {
;;;711                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
00007c  ab01              ADD      r3,sp,#4
00007e  2201              MOVS     r2,#1
000080  2107              MOVS     r1,#7
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       pdb_write_buf_get
000088  4604              MOV      r4,r0
;;;712                if (err_code == NRF_SUCCESS)
00008a  b924              CBNZ     r4,|L10.150|
;;;713                {
;;;714                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
00008c  2107              MOVS     r1,#7
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       pdb_write_buf_store_prepare
000094  4604              MOV      r4,r0
                  |L10.150|
;;;715                }
;;;716            }
;;;717    
;;;718            if (err_code == NRF_SUCCESS)
000096  b91c              CBNZ     r4,|L10.160|
;;;719            {
;;;720                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000098  4639              MOV      r1,r7
00009a  9805              LDR      r0,[sp,#0x14]
00009c  df7e              SVC      #0x7e
00009e  4604              MOV      r4,r0
                  |L10.160|
;;;721            }
;;;722    
;;;723            if (err_code != NRF_SUCCESS)
0000a0  b164              CBZ      r4,|L10.188|
;;;724            {
;;;725                ret_code_t err_code_release = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
0000a2  2107              MOVS     r1,#7
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       pdb_write_buf_release
0000aa  4683              MOV      r11,r0
;;;726                if ((err_code_release != NRF_SUCCESS) && (err_code_release != NRF_ERROR_NOT_FOUND))
0000ac  f1bb0f00          CMP      r11,#0
0000b0  d003              BEQ      |L10.186|
0000b2  f1bb0f05          CMP      r11,#5
0000b6  d000              BEQ      |L10.186|
;;;727                {
;;;728                    err_code = NRF_ERROR_INTERNAL;
0000b8  2403              MOVS     r4,#3
                  |L10.186|
;;;729                }
;;;730            }
0000ba  bf00              NOP      
                  |L10.188|
;;;731        }
;;;732    
;;;733        sec_proc_start(conn_handle,
0000bc  2000              MOVS     r0,#0
0000be  9000              STR      r0,[sp,#0]
0000c0  f8990000          LDRB     r0,[r9,#0]
0000c4  b108              CBZ      r0,|L10.202|
0000c6  2001              MOVS     r0,#1
0000c8  e000              B        |L10.204|
                  |L10.202|
0000ca  2000              MOVS     r0,#0
                  |L10.204|
0000cc  4603              MOV      r3,r0
0000ce  b90c              CBNZ     r4,|L10.212|
0000d0  2001              MOVS     r0,#1
0000d2  e000              B        |L10.214|
                  |L10.212|
0000d4  2000              MOVS     r0,#0
                  |L10.214|
0000d6  4602              MOV      r2,r0
0000d8  4631              MOV      r1,r6
0000da  9805              LDR      r0,[sp,#0x14]
0000dc  f7fffffe          BL       sec_proc_start
;;;734                       peer_id,
;;;735                       err_code == NRF_SUCCESS,
;;;736                       *procedure != PM_LINK_SECURED_PROCEDURE_ENCRYPTION,
;;;737                       false);
;;;738    
;;;739        return err_code;
0000e0  4620              MOV      r0,r4
;;;740    }
0000e2  b009              ADD      sp,sp,#0x24
0000e4  e8bd8ff0          POP      {r4-r11,pc}
;;;741    
                          ENDP


                          AREA ||i.link_secure_central_new_peer||, CODE, READONLY, ALIGN=1

                  link_secure_central_new_peer PROC
;;;742    
;;;743    static ret_code_t link_secure_central_new_peer(uint16_t               conn_handle,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;744                                                   ble_gap_sec_params_t * p_sec_params)
;;;745    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;746        pm_peer_id_t    peer_id = pdb_peer_allocate();
000008  f7fffffe          BL       pdb_peer_allocate
00000c  4605              MOV      r5,r0
;;;747        pm_peer_data_t  dummy_peer_data;
;;;748        ret_code_t      err_code;
;;;749    
;;;750        if (peer_id != PM_PEER_ID_INVALID)
00000e  f64f70ff          MOV      r0,#0xffff
000012  4285              CMP      r5,r0
000014  d01c              BEQ      |L11.80|
;;;751        {
;;;752            err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
000016  ab01              ADD      r3,sp,#4
000018  2201              MOVS     r2,#1
00001a  2107              MOVS     r1,#7
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       pdb_write_buf_get
000022  4604              MOV      r4,r0
;;;753            if (err_code == NRF_SUCCESS)
000024  b924              CBNZ     r4,|L11.48|
;;;754            {
;;;755                err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
000026  2107              MOVS     r1,#7
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       pdb_write_buf_store_prepare
00002e  4604              MOV      r4,r0
                  |L11.48|
;;;756            }
;;;757    
;;;758            if (err_code == NRF_SUCCESS)
000030  b91c              CBNZ     r4,|L11.58|
;;;759            {
;;;760                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000032  4641              MOV      r1,r8
000034  4638              MOV      r0,r7
000036  df7e              SVC      #0x7e
000038  4604              MOV      r4,r0
                  |L11.58|
;;;761            }
;;;762    
;;;763            if (err_code != NRF_SUCCESS)
00003a  b154              CBZ      r4,|L11.82|
;;;764            {
;;;765                ret_code_t err_code_free = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
00003c  2107              MOVS     r1,#7
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       pdb_write_buf_release
000044  4606              MOV      r6,r0
;;;766                if ((err_code_free != NRF_SUCCESS) && (err_code_free != NRF_ERROR_NOT_FOUND))
000046  b116              CBZ      r6,|L11.78|
000048  2e05              CMP      r6,#5
00004a  d000              BEQ      |L11.78|
;;;767                {
;;;768                    err_code = NRF_ERROR_INTERNAL;
00004c  2403              MOVS     r4,#3
                  |L11.78|
;;;769                }
;;;770            }
00004e  e000              B        |L11.82|
                  |L11.80|
;;;771        }
;;;772        else
;;;773        {
;;;774            err_code = NRF_ERROR_INTERNAL;
000050  2403              MOVS     r4,#3
                  |L11.82|
;;;775        }
;;;776    
;;;777        sec_proc_start(conn_handle,
000052  f64f70ff          MOV      r0,#0xffff
000056  4285              CMP      r5,r0
000058  d001              BEQ      |L11.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L11.96|
                  |L11.94|
00005e  2000              MOVS     r0,#0
                  |L11.96|
000060  9000              STR      r0,[sp,#0]
000062  b90c              CBNZ     r4,|L11.104|
000064  2001              MOVS     r0,#1
000066  e000              B        |L11.106|
                  |L11.104|
000068  2000              MOVS     r0,#0
                  |L11.106|
00006a  4602              MOV      r2,r0
00006c  2301              MOVS     r3,#1
00006e  4629              MOV      r1,r5
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       sec_proc_start
;;;778                       peer_id,
;;;779                       err_code == NRF_SUCCESS,
;;;780                       true,
;;;781                       peer_id != PM_PEER_ID_INVALID);
;;;782    
;;;783        return err_code;
000076  4620              MOV      r0,r4
;;;784    }
000078  e8bd83fe          POP      {r1-r9,pc}
;;;785    
                          ENDP


                          AREA ||i.link_secure_failure||, CODE, READONLY, ALIGN=2

                  link_secure_failure PROC
;;;418     */
;;;419    static void link_secure_failure(uint16_t            conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;420                                    pm_sec_error_code_t error,
;;;421                                    uint8_t             error_src)
;;;422    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;423        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc))
00000a  4811              LDR      r0,|L12.80|
00000c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       ble_conn_state_user_flag_get
000014  b1d0              CBZ      r0,|L12.76|
;;;424        {
;;;425            pm_peer_id_t  peer_id = im_peer_id_get_by_conn_handle(conn_handle);
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       im_peer_id_get_by_conn_handle
00001c  4606              MOV      r6,r0
;;;426    
;;;427            if (peer_id != PM_PEER_ID_INVALID)
00001e  f64f70ff          MOV      r0,#0xffff
000022  4286              CMP      r6,r0
000024  d011              BEQ      |L12.74|
;;;428            {
;;;429                if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_pairing))
000026  480b              LDR      r0,|L12.84|
000028  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       ble_conn_state_user_flag_get
000030  b130              CBZ      r0,|L12.64|
;;;430                {
;;;431                    pairing_failure(conn_handle, peer_id, error, error_src);
000032  462b              MOV      r3,r5
000034  4622              MOV      r2,r4
000036  4631              MOV      r1,r6
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       pairing_failure
00003e  e004              B        |L12.74|
                  |L12.64|
;;;432                }
;;;433                else
;;;434                {
;;;435                    encryption_failure(conn_handle, error, error_src);
000040  462a              MOV      r2,r5
000042  4621              MOV      r1,r4
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       encryption_failure
                  |L12.74|
;;;436                }
;;;437            }
;;;438        }
00004a  bf00              NOP      
                  |L12.76|
;;;439    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;440    
                          ENDP

                  |L12.80|
                          DCD      m_flag_sec_proc
                  |L12.84|
                          DCD      m_flag_sec_proc_pairing

                          AREA ||i.link_secure_peripheral||, CODE, READONLY, ALIGN=1

                  link_secure_peripheral PROC
;;;834    
;;;835    static ret_code_t link_secure_peripheral(uint16_t conn_handle, ble_gap_sec_params_t * p_sec_params)
000000  b570              PUSH     {r4-r6,lr}
;;;836    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;837        // This should never happen for a peripheral.
;;;838        NRF_PM_DEBUG_CHECK(p_sec_params != NULL);
;;;839    
;;;840        // VERIFY_PARAM_NOT_NULL(p_sec_params);
;;;841    
;;;842        ret_code_t err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  df7e              SVC      #0x7e
00000c  4606              MOV      r6,r0
;;;843    
;;;844        return err_code;
00000e  4630              MOV      r0,r6
;;;845    }
000010  bd70              POP      {r4-r6,pc}
;;;846    
                          ENDP


                          AREA ||i.pairing_failure||, CODE, READONLY, ALIGN=2

                  pairing_failure PROC
;;;332     */
;;;333    static void pairing_failure(uint16_t            conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;334                                pm_peer_id_t        peer_id,
;;;335                                pm_sec_error_code_t error,
;;;336                                uint8_t             error_src)
;;;337    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
00000c  4698              MOV      r8,r3
;;;338        ret_code_t err_code = NRF_SUCCESS;
00000e  2500              MOVS     r5,#0
;;;339    
;;;340        smd_evt_t evt =
000010  4a19              LDR      r2,|L14.120|
000012  ca07              LDM      r2,{r0-r2}
000014  e9cd1204          STRD     r1,r2,[sp,#0x10]
000018  9003              STR      r0,[sp,#0xc]
00001a  f8ad400e          STRH     r4,[sp,#0xe]
00001e  f8ad7010          STRH     r7,[sp,#0x10]
000022  f88d8012          STRB     r8,[sp,#0x12]
;;;341        {
;;;342            .evt_id      = SMD_EVT_PAIRING_FAIL,
;;;343            .conn_handle = conn_handle,
;;;344            .params =
;;;345            {
;;;346                .pairing_failed =
;;;347                {
;;;348                    .error     = error,
;;;349                    .error_src = error_src,
;;;350                }
;;;351            }
;;;352        };
;;;353    
;;;354        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_new_peer))
000026  4815              LDR      r0,|L14.124|
000028  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       ble_conn_state_user_flag_get
000030  b120              CBZ      r0,|L14.60|
;;;355        {
;;;356            // The peer_id was created during the procedure, and should be freed, because no data is
;;;357            // stored under it.
;;;358            err_code = im_peer_free(peer_id);  // Attempt to free allocated peer.
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       im_peer_free
000038  4605              MOV      r5,r0
;;;359            UNUSED_VARIABLE(err_code);
00003a  e011              B        |L14.96|
                  |L14.60|
;;;360        }
;;;361        else
;;;362        {
;;;363            err_code = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
00003c  2107              MOVS     r1,#7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       pdb_write_buf_release
000044  4605              MOV      r5,r0
;;;364            if ((err_code != NRF_SUCCESS) && (err_code == NRF_ERROR_NOT_FOUND /* No buffer was allocated */))
000046  b15d              CBZ      r5,|L14.96|
000048  2d05              CMP      r5,#5
00004a  d109              BNE      |L14.96|
;;;365            {
;;;366                smd_evt_t error_evt;
;;;367                error_evt.evt_id = SMD_EVT_ERROR_UNEXPECTED;
00004c  2009              MOVS     r0,#9
00004e  f88d0000          STRB     r0,[sp,#0]
;;;368                error_evt.conn_handle = conn_handle;
000052  f8ad4002          STRH     r4,[sp,#2]
;;;369                error_evt.params.error_unexpected.error = err_code;
000056  9501              STR      r5,[sp,#4]
;;;370                evt_send(&error_evt);
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       evt_send
;;;371            }
00005e  bf00              NOP      
                  |L14.96|
;;;372        }
;;;373    
;;;374        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
000060  2200              MOVS     r2,#0
000062  4807              LDR      r0,|L14.128|
000064  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       ble_conn_state_user_flag_set
;;;375    
;;;376        evt_send(&evt);
00006c  a803              ADD      r0,sp,#0xc
00006e  f7fffffe          BL       evt_send
;;;377        return;
;;;378    }
000072  b006              ADD      sp,sp,#0x18
000074  e8bd81f0          POP      {r4-r8,pc}
;;;379    
                          ENDP

                  |L14.120|
                          DCD      ||.constdata||+0x2c
                  |L14.124|
                          DCD      m_flag_sec_proc_new_peer
                  |L14.128|
                          DCD      m_flag_sec_proc

                          AREA ||i.sec_info_request_process||, CODE, READONLY, ALIGN=1

                  sec_info_request_process PROC
;;;176     */
;;;177    static void sec_info_request_process(ble_gap_evt_t const * p_gap_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;178    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
;;;179        ret_code_t                 err_code;
;;;180        ble_gap_enc_info_t const * p_enc_info = NULL;
000008  f04f0800          MOV      r8,#0
;;;181        pm_peer_data_flash_t       peer_data;
;;;182    
;;;183        pm_peer_id_t peer_id = im_peer_id_get_by_master_id(&p_gap_evt->params.sec_info_request.master_id);
00000c  f104000c          ADD      r0,r4,#0xc
000010  f7fffffe          BL       im_peer_id_get_by_master_id
000014  4606              MOV      r6,r0
;;;184    
;;;185        smd_evt_t evt;
;;;186        evt.conn_handle = p_gap_evt->conn_handle;
000016  8820              LDRH     r0,[r4,#0]
000018  f8ad0006          STRH     r0,[sp,#6]
;;;187    
;;;188        if (peer_id == PM_PEER_ID_INVALID)
00001c  f64f70ff          MOV      r0,#0xffff
000020  4286              CMP      r6,r0
000022  d103              BNE      |L15.44|
;;;189        {
;;;190            peer_id = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000024  8820              LDRH     r0,[r4,#0]
000026  f7fffffe          BL       im_peer_id_get_by_conn_handle
00002a  4606              MOV      r6,r0
                  |L15.44|
;;;191        }
;;;192    
;;;193        if (peer_id != PM_PEER_ID_INVALID)
00002c  f64f70ff          MOV      r0,#0xffff
000030  4286              CMP      r6,r0
000032  d016              BEQ      |L15.98|
;;;194        {
;;;195            err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
000034  aa04              ADD      r2,sp,#0x10
000036  2107              MOVS     r1,#7
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       pdb_peer_data_ptr_get
00003e  4605              MOV      r5,r0
;;;196    
;;;197            if (err_code == NRF_SUCCESS)
000040  b97d              CBNZ     r5,|L15.98|
;;;198            {
;;;199                // There is stored bonding data for this peer.
;;;200                ble_gap_enc_key_t const * p_existing_key = &peer_data.p_bonding_data->own_ltk;
000042  9805              LDR      r0,[sp,#0x14]
000044  f1000734          ADD      r7,r0,#0x34
;;;201    
;;;202                if (   p_existing_key->enc_info.lesc
000048  7c38              LDRB     r0,[r7,#0x10]
00004a  f0000001          AND      r0,r0,#1
00004e  b930              CBNZ     r0,|L15.94|
;;;203                    || (im_master_ids_compare(&p_existing_key->master_id,
000050  f104010c          ADD      r1,r4,#0xc
000054  f1070012          ADD      r0,r7,#0x12
000058  f7fffffe          BL       im_master_ids_compare
00005c  b100              CBZ      r0,|L15.96|
                  |L15.94|
;;;204                                              &p_gap_evt->params.sec_info_request.master_id)))
;;;205                {
;;;206                    p_enc_info = &p_existing_key->enc_info;
00005e  46b8              MOV      r8,r7
                  |L15.96|
;;;207                }
;;;208            }
000060  bf00              NOP      
                  |L15.98|
;;;209        }
;;;210    
;;;211        // All return values from the following can be safely ignored.
;;;212        err_code = sd_ble_gap_sec_info_reply(p_gap_evt->conn_handle, p_enc_info, NULL, NULL);
000062  8820              LDRH     r0,[r4,#0]
000064  2300              MOVS     r3,#0
000066  461a              MOV      r2,r3
000068  4641              MOV      r1,r8
00006a  df86              SVC      #0x86
00006c  4605              MOV      r5,r0
;;;213    
;;;214        if (err_code != NRF_SUCCESS)
00006e  b13d              CBZ      r5,|L15.128|
;;;215        {
;;;216            evt.evt_id                        = SMD_EVT_ERROR_UNEXPECTED;
000070  2009              MOVS     r0,#9
000072  f88d0004          STRB     r0,[sp,#4]
;;;217            evt.params.error_unexpected.error = err_code;
000076  9502              STR      r5,[sp,#8]
;;;218    
;;;219            evt_send(&evt);
000078  a801              ADD      r0,sp,#4
00007a  f7fffffe          BL       evt_send
00007e  e028              B        |L15.210|
                  |L15.128|
;;;220        }
;;;221        else if (p_enc_info == NULL)
000080  f1b80f00          CMP      r8,#0
000084  d115              BNE      |L15.178|
;;;222        {
;;;223            evt.evt_id                                  = SMD_EVT_LINK_ENCRYPTION_FAILED;
000086  2006              MOVS     r0,#6
000088  f88d0004          STRB     r0,[sp,#4]
;;;224            evt.params.link_encryption_failed.error     = PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING;
00008c  f2410006          MOV      r0,#0x1006
000090  f8ad0008          STRH     r0,[sp,#8]
;;;225            evt.params.link_encryption_failed.error_src = BLE_GAP_SEC_STATUS_SOURCE_LOCAL;
000094  2100              MOVS     r1,#0
000096  f88d100a          STRB     r1,[sp,#0xa]
;;;226    
;;;227            evt_send(&evt);
00009a  a801              ADD      r0,sp,#4
00009c  f7fffffe          BL       evt_send
;;;228    
;;;229            sec_proc_start(p_gap_evt->conn_handle, peer_id, false, false, false);
0000a0  2000              MOVS     r0,#0
0000a2  9000              STR      r0,[sp,#0]
0000a4  8820              LDRH     r0,[r4,#0]
0000a6  2300              MOVS     r3,#0
0000a8  461a              MOV      r2,r3
0000aa  4631              MOV      r1,r6
0000ac  f7fffffe          BL       sec_proc_start
0000b0  e00f              B        |L15.210|
                  |L15.178|
;;;230        }
;;;231        else
;;;232        {
;;;233            sec_start_send(p_gap_evt->conn_handle, PM_LINK_SECURED_PROCEDURE_ENCRYPTION);
0000b2  8820              LDRH     r0,[r4,#0]
0000b4  2100              MOVS     r1,#0
0000b6  f7fffffe          BL       sec_start_send
;;;234    
;;;235            sec_proc_start(p_gap_evt->conn_handle, peer_id, err_code == NRF_SUCCESS, false, false);
0000ba  2000              MOVS     r0,#0
0000bc  9000              STR      r0,[sp,#0]
0000be  b90d              CBNZ     r5,|L15.196|
0000c0  2101              MOVS     r1,#1
0000c2  e000              B        |L15.198|
                  |L15.196|
0000c4  2100              MOVS     r1,#0
                  |L15.198|
0000c6  460a              MOV      r2,r1
0000c8  8820              LDRH     r0,[r4,#0]
0000ca  2300              MOVS     r3,#0
0000cc  4631              MOV      r1,r6
0000ce  f7fffffe          BL       sec_proc_start
                  |L15.210|
;;;236        }
;;;237    
;;;238    
;;;239        return;
;;;240    }
0000d2  b006              ADD      sp,sp,#0x18
0000d4  e8bd81f0          POP      {r4-r8,pc}
;;;241    
                          ENDP


                          AREA ||i.sec_params_request_process||, CODE, READONLY, ALIGN=1

                  sec_params_request_process PROC
;;;122     */
;;;123    static void sec_params_request_process(ble_gap_evt_t const * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125        smd_evt_t evt =
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  8820              LDRH     r0,[r4,#0]
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;126        {
;;;127            .evt_id      = SMD_EVT_PARAMS_REQ,
;;;128            .conn_handle = p_gap_evt->conn_handle
;;;129        };
;;;130        evt_send(&evt);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       evt_send
;;;131        return;
;;;132    }
000018  bd3e              POP      {r1-r5,pc}
;;;133    
                          ENDP


                          AREA ||i.sec_proc_start||, CODE, READONLY, ALIGN=2

                  sec_proc_start PROC
;;;142     */
;;;143    static void sec_proc_start(uint16_t     conn_handle,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;144                               pm_peer_id_t peer_id,
;;;145                               bool         success,
;;;146                               bool         pairing,
;;;147                               bool         new_peer_created)
;;;148    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9c08              LDR      r4,[sp,#0x20]
;;;149        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, success);
00000e  4632              MOV      r2,r6
000010  480f              LDR      r0,|L17.80|
000012  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       ble_conn_state_user_flag_set
;;;150    
;;;151        if (success)
00001a  b18e              CBZ      r6,|L17.64|
;;;152        {
;;;153            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_pairing, pairing);
00001c  463a              MOV      r2,r7
00001e  480d              LDR      r0,|L17.84|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       ble_conn_state_user_flag_set
;;;154            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_new_peer, new_peer_created);
000028  4622              MOV      r2,r4
00002a  480b              LDR      r0,|L17.88|
00002c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       ble_conn_state_user_flag_set
;;;155    
;;;156            if (new_peer_created)
000034  b154              CBZ      r4,|L17.76|
;;;157            {
;;;158                im_new_peer_id(conn_handle, peer_id);
000036  4629              MOV      r1,r5
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       im_new_peer_id
00003e  e005              B        |L17.76|
                  |L17.64|
;;;159            }
;;;160        }
;;;161        else
;;;162        {
;;;163            if (new_peer_created)
000040  b124              CBZ      r4,|L17.76|
;;;164            {
;;;165                ret_code_t err_code = im_peer_free(peer_id); // Attempt to free allocated peer.
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       im_peer_free
000048  4681              MOV      r9,r0
;;;166                UNUSED_VARIABLE(err_code);
;;;167            }
00004a  bf00              NOP      
                  |L17.76|
;;;168        }
;;;169    }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;170    
                          ENDP

                  |L17.80|
                          DCD      m_flag_sec_proc
                  |L17.84|
                          DCD      m_flag_sec_proc_pairing
                  |L17.88|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.sec_request_process||, CODE, READONLY, ALIGN=2

                  sec_request_process PROC
;;;246     */
;;;247    static void sec_request_process(ble_gap_evt_t const * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249        smd_evt_t evt =
000004  4a0a              LDR      r2,|L18.48|
000006  ca07              LDM      r2,{r0-r2}
000008  e88d0007          STM      sp,{r0-r2}
00000c  8820              LDRH     r0,[r4,#0]
00000e  f8ad0002          STRH     r0,[sp,#2]
000012  7920              LDRB     r0,[r4,#4]
000014  f0000001          AND      r0,r0,#1
000018  f88d0004          STRB     r0,[sp,#4]
00001c  7920              LDRB     r0,[r4,#4]
00001e  f3c00140          UBFX     r1,r0,#1,#1
000022  f88d1005          STRB     r1,[sp,#5]
;;;250        {
;;;251            .evt_id = SMD_EVT_SLAVE_SECURITY_REQ,
;;;252            .conn_handle = p_gap_evt->conn_handle,
;;;253            .params =
;;;254            {
;;;255                .slave_security_req =
;;;256                {
;;;257                    .bond = p_gap_evt->params.sec_request.bond,
;;;258                    .mitm = p_gap_evt->params.sec_request.mitm,
;;;259                }
;;;260            }
;;;261        };
;;;262        evt_send(&evt);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       evt_send
;;;263        return;
;;;264    }
00002c  bd3e              POP      {r1-r5,pc}
;;;265    
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      ||.constdata||+0x20

                          AREA ||i.sec_start_send||, CODE, READONLY, ALIGN=2

                  sec_start_send PROC
;;;86     
;;;87     static void sec_start_send(uint16_t conn_handle, pm_conn_sec_procedure_t procedure)
000000  b53e              PUSH     {r1-r5,lr}
;;;88     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;89         smd_evt_t evt =
000006  4a06              LDR      r2,|L19.32|
000008  ca07              LDM      r2,{r0-r2}
00000a  e88d0007          STM      sp,{r0-r2}
00000e  f8ad5002          STRH     r5,[sp,#2]
000012  f88d4004          STRB     r4,[sp,#4]
;;;90         {
;;;91             .evt_id      = SMD_EVT_SEC_PROCEDURE_START,
;;;92             .conn_handle = conn_handle,
;;;93             .params      = {.sec_procedure_start = {.procedure = procedure}}
;;;94         };
;;;95         evt_send(&evt);
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       evt_send
;;;96     }
00001c  bd3e              POP      {r1-r5,pc}
;;;97     
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      ||.constdata||+0x8

                          AREA ||i.smd_ble_evt_handler||, CODE, READONLY, ALIGN=1

                  smd_ble_evt_handler PROC
;;;869    
;;;870    void smd_ble_evt_handler(ble_evt_t const * p_ble_evt)
000000  b510              PUSH     {r4,lr}
;;;871    {
000002  4604              MOV      r4,r0
;;;872        switch (p_ble_evt->header.evt_id)
000004  8820              LDRH     r0,[r4,#0]
000006  2819              CMP      r0,#0x19
000008  d01c              BEQ      |L20.68|
00000a  dc06              BGT      |L20.26|
00000c  2811              CMP      r0,#0x11
00000e  d009              BEQ      |L20.36|
000010  2813              CMP      r0,#0x13
000012  d00b              BEQ      |L20.44|
000014  2814              CMP      r0,#0x14
000016  d11d              BNE      |L20.84|
000018  e00c              B        |L20.52|
                  |L20.26|
00001a  281a              CMP      r0,#0x1a
00001c  d016              BEQ      |L20.76|
00001e  281e              CMP      r0,#0x1e
000020  d118              BNE      |L20.84|
000022  e00b              B        |L20.60|
                  |L20.36|
;;;873        {
;;;874            case BLE_GAP_EVT_DISCONNECTED:
;;;875                disconnect_process(&(p_ble_evt->evt.gap_evt));
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       disconnect_process
;;;876                break;
00002a  e013              B        |L20.84|
                  |L20.44|
;;;877    
;;;878            case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
;;;879                sec_params_request_process(&(p_ble_evt->evt.gap_evt));
00002c  1d20              ADDS     r0,r4,#4
00002e  f7fffffe          BL       sec_params_request_process
;;;880                break;
000032  e00f              B        |L20.84|
                  |L20.52|
;;;881    
;;;882            case BLE_GAP_EVT_SEC_INFO_REQUEST:
;;;883                sec_info_request_process(&(p_ble_evt->evt.gap_evt));
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       sec_info_request_process
;;;884                break;
00003a  e00b              B        |L20.84|
                  |L20.60|
;;;885    
;;;886            case BLE_GAP_EVT_SEC_REQUEST:
;;;887                sec_request_process(&(p_ble_evt->evt.gap_evt));
00003c  1d20              ADDS     r0,r4,#4
00003e  f7fffffe          BL       sec_request_process
;;;888                break;
000042  e007              B        |L20.84|
                  |L20.68|
;;;889    
;;;890            case BLE_GAP_EVT_AUTH_STATUS:
;;;891                auth_status_process(&(p_ble_evt->evt.gap_evt));
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       auth_status_process
;;;892                break;
00004a  e003              B        |L20.84|
                  |L20.76|
;;;893    
;;;894            case BLE_GAP_EVT_CONN_SEC_UPDATE:
;;;895                conn_sec_update_process(&(p_ble_evt->evt.gap_evt));
00004c  1d20              ADDS     r0,r4,#4
00004e  f7fffffe          BL       conn_sec_update_process
;;;896                break;
000052  bf00              NOP      
                  |L20.84|
000054  bf00              NOP                            ;876
;;;897        };
;;;898    }
000056  bd10              POP      {r4,pc}
;;;899    #endif //NRF_MODULE_ENABLED(PEER_MANAGER)
                          ENDP


                          AREA ||i.smd_init||, CODE, READONLY, ALIGN=2

                  smd_init PROC
;;;530    
;;;531    ret_code_t smd_init(void)
000000  b510              PUSH     {r4,lr}
;;;532    {
;;;533        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;534    
;;;535        flag_id_init(&m_flag_sec_proc);
000002  480e              LDR      r0,|L21.60|
000004  f7fffffe          BL       flag_id_init
;;;536        flag_id_init(&m_flag_sec_proc_pairing);
000008  480d              LDR      r0,|L21.64|
00000a  f7fffffe          BL       flag_id_init
;;;537        flag_id_init(&m_flag_sec_proc_new_peer);
00000e  480d              LDR      r0,|L21.68|
000010  f7fffffe          BL       flag_id_init
;;;538    
;;;539        if ((m_flag_sec_proc          == BLE_CONN_STATE_USER_FLAG_INVALID) ||
000014  4809              LDR      r0,|L21.60|
000016  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc
000018  2818              CMP      r0,#0x18
00001a  d007              BEQ      |L21.44|
;;;540            (m_flag_sec_proc_pairing  == BLE_CONN_STATE_USER_FLAG_INVALID) ||
00001c  4808              LDR      r0,|L21.64|
00001e  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_pairing
000020  2818              CMP      r0,#0x18
000022  d003              BEQ      |L21.44|
;;;541            (m_flag_sec_proc_new_peer == BLE_CONN_STATE_USER_FLAG_INVALID))
000024  4807              LDR      r0,|L21.68|
000026  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_new_peer
000028  2818              CMP      r0,#0x18
00002a  d101              BNE      |L21.48|
                  |L21.44|
;;;542        {
;;;543            return NRF_ERROR_INTERNAL;
00002c  2003              MOVS     r0,#3
                  |L21.46|
;;;544        }
;;;545    
;;;546        m_module_initialized = true;
;;;547    
;;;548        return NRF_SUCCESS;
;;;549    }
00002e  bd10              POP      {r4,pc}
                  |L21.48|
000030  2001              MOVS     r0,#1                 ;546
000032  4905              LDR      r1,|L21.72|
000034  7008              STRB     r0,[r1,#0]            ;546
000036  2000              MOVS     r0,#0                 ;548
000038  e7f9              B        |L21.46|
;;;550    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      m_flag_sec_proc
                  |L21.64|
                          DCD      m_flag_sec_proc_pairing
                  |L21.68|
                          DCD      m_flag_sec_proc_new_peer
                  |L21.72|
                          DCD      m_module_initialized

                          AREA ||i.smd_link_secure||, CODE, READONLY, ALIGN=1

                  smd_link_secure PROC
;;;847    
;;;848    ret_code_t smd_link_secure(uint16_t               conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;849                               ble_gap_sec_params_t * p_sec_params,
;;;850                               bool                   force_repairing)
;;;851    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;852        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;853    
;;;854        uint8_t role = ble_conn_state_role(conn_handle);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       ble_conn_state_role
000010  4607              MOV      r7,r0
;;;855    
;;;856        switch (role)
000012  2f01              CMP      r7,#1
000014  d008              BEQ      |L22.40|
000016  2f02              CMP      r7,#2
000018  d10b              BNE      |L22.50|
;;;857        {
;;;858            case BLE_GAP_ROLE_CENTRAL:
;;;859                return link_secure_central(conn_handle, p_sec_params, force_repairing);
00001a  4632              MOV      r2,r6
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       link_secure_central
                  |L22.36|
;;;860    
;;;861            case BLE_GAP_ROLE_PERIPH:
;;;862                return link_secure_peripheral(conn_handle, p_sec_params);
;;;863    
;;;864            default:
;;;865                return BLE_ERROR_INVALID_CONN_HANDLE;
;;;866        }
;;;867    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L22.40|
000028  4629              MOV      r1,r5                 ;862
00002a  4620              MOV      r0,r4                 ;862
00002c  f7fffffe          BL       link_secure_peripheral
000030  e7f8              B        |L22.36|
                  |L22.50|
000032  f2430002          MOV      r0,#0x3002            ;865
000036  e7f5              B        |L22.36|
;;;868    
                          ENDP


                          AREA ||i.smd_params_reply||, CODE, READONLY, ALIGN=2

                  smd_params_reply PROC
;;;551    
;;;552    ret_code_t smd_params_reply(uint16_t                 conn_handle,
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;553                                ble_gap_sec_params_t   * p_sec_params,
;;;554                                ble_gap_lesc_p256_pk_t * p_public_key)
;;;555    {
000004  b08a              SUB      sp,sp,#0x28
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;556        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;557    
;;;558        uint8_t              role = ble_conn_state_role(conn_handle);
00000a  980a              LDR      r0,[sp,#0x28]
00000c  f7fffffe          BL       ble_conn_state_role
000010  4680              MOV      r8,r0
;;;559        pm_peer_id_t         peer_id = PM_PEER_ID_INVALID;
000012  f64f76ff          MOV      r6,#0xffff
;;;560        ret_code_t           err_code = NRF_SUCCESS;
000016  2500              MOVS     r5,#0
;;;561        uint8_t              sec_status = BLE_GAP_SEC_STATUS_SUCCESS;
000018  46a9              MOV      r9,r5
;;;562        ble_gap_sec_keyset_t sec_keyset;
;;;563        bool                 new_peer_created = false;
00001a  46aa              MOV      r10,r5
;;;564    
;;;565        memset(&sec_keyset, 0, sizeof(ble_gap_sec_keyset_t));
00001c  2120              MOVS     r1,#0x20
00001e  a802              ADD      r0,sp,#8
000020  f7fffffe          BL       __aeabi_memclr4
;;;566    
;;;567        if (role == BLE_GAP_ROLE_INVALID)
000024  f1b80f00          CMP      r8,#0
000028  d104              BNE      |L23.52|
;;;568        {
;;;569            return BLE_ERROR_INVALID_CONN_HANDLE;
00002a  f2430002          MOV      r0,#0x3002
                  |L23.46|
;;;570        }
;;;571    
;;;572        if (p_sec_params == NULL)
;;;573        {
;;;574            // NULL params means reject pairing.
;;;575            sec_status = BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP;
;;;576        }
;;;577        else if (p_sec_params->bond)
;;;578        {
;;;579            // Bonding is to be performed, prepare to receive bonding data.
;;;580            pm_peer_data_t       peer_data;
;;;581    
;;;582            peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;583    
;;;584            if (peer_id == PM_PEER_ID_INVALID)
;;;585            {
;;;586                // Peer is unknown to us, allocate a new peer ID for it.
;;;587                peer_id = pdb_peer_allocate();
;;;588                if (peer_id != PM_PEER_ID_INVALID)
;;;589                {
;;;590                    new_peer_created = true;
;;;591                }
;;;592                else
;;;593                {
;;;594                    err_code = NRF_ERROR_INTERNAL;
;;;595                }
;;;596            }
;;;597    
;;;598            if (err_code == NRF_SUCCESS)
;;;599            {
;;;600                // Peer ID is ready, acquire a memory buffer to receive bonding data into.
;;;601                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &peer_data);
;;;602                if (err_code == NRF_SUCCESS)
;;;603                {
;;;604                    memset(peer_data.p_bonding_data, 0, sizeof(pm_peer_data_bonding_t));
;;;605    
;;;606                    peer_data.p_bonding_data->own_role = role;
;;;607    
;;;608                    sec_keyset.keys_own.p_enc_key  = &peer_data.p_bonding_data->own_ltk;
;;;609                    sec_keyset.keys_own.p_pk       = p_public_key;
;;;610                    sec_keyset.keys_peer.p_enc_key = &peer_data.p_bonding_data->peer_ltk;
;;;611                    sec_keyset.keys_peer.p_id_key  = &peer_data.p_bonding_data->peer_ble_id;
;;;612                    sec_keyset.keys_peer.p_pk      = &m_peer_pk;
;;;613    
;;;614                    // Retrieve the address the peer used during connection establishment.
;;;615                    // This address will be overwritten if ID is shared. Should not fail.
;;;616                    ret_code_t err_code_addr = im_ble_addr_get(conn_handle,
;;;617                        &peer_data.p_bonding_data->peer_ble_id.id_addr_info);
;;;618                    UNUSED_VARIABLE(err_code_addr);
;;;619    
;;;620                    // Buffer is OK, reserve room in flash for the data.
;;;621                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
;;;622                }
;;;623            }
;;;624        }
;;;625        else
;;;626        {
;;;627            // Pairing, no bonding.
;;;628    
;;;629            sec_keyset.keys_own.p_pk  = p_public_key;
;;;630            sec_keyset.keys_peer.p_pk = &m_peer_pk;
;;;631        }
;;;632    
;;;633        if (err_code == NRF_SUCCESS)
;;;634        {
;;;635            // Everything OK, reply to SoftDevice. If an error happened, the user is given an
;;;636            // opportunity to change the parameters and retry the call.
;;;637            if (role == BLE_GAP_ROLE_CENTRAL)
;;;638            {
;;;639                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, NULL, &sec_keyset);
;;;640            }
;;;641            else
;;;642            {
;;;643                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, p_sec_params, &sec_keyset);
;;;644    
;;;645                if ((p_sec_params != NULL) && (err_code == NRF_SUCCESS))
;;;646                {
;;;647                    pm_conn_sec_procedure_t procedure = p_sec_params->bond
;;;648                                                   ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;649                                                   : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;650                    sec_start_send(conn_handle, procedure);
;;;651                }
;;;652            }
;;;653        }
;;;654    
;;;655        sec_proc_start(conn_handle,
;;;656                       peer_id,
;;;657                       (err_code == NRF_SUCCESS) && (sec_status != BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP),
;;;658                       true,
;;;659                       new_peer_created);
;;;660    
;;;661        return err_code;
;;;662    }
00002e  b00d              ADD      sp,sp,#0x34
000030  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.52|
000034  b914              CBNZ     r4,|L23.60|
000036  f04f0985          MOV      r9,#0x85              ;575
00003a  e044              B        |L23.198|
                  |L23.60|
00003c  7820              LDRB     r0,[r4,#0]            ;577
00003e  f0000001          AND      r0,r0,#1              ;577
000042  2800              CMP      r0,#0                 ;577
000044  d03c              BEQ      |L23.192|
000046  980a              LDR      r0,[sp,#0x28]         ;582
000048  f7fffffe          BL       im_peer_id_get_by_conn_handle
00004c  4606              MOV      r6,r0                 ;582
00004e  f64f70ff          MOV      r0,#0xffff            ;584
000052  4286              CMP      r6,r0                 ;584
000054  d10a              BNE      |L23.108|
000056  f7fffffe          BL       pdb_peer_allocate
00005a  4606              MOV      r6,r0                 ;587
00005c  f64f70ff          MOV      r0,#0xffff            ;588
000060  4286              CMP      r6,r0                 ;588
000062  d002              BEQ      |L23.106|
000064  f04f0a01          MOV      r10,#1                ;590
000068  e000              B        |L23.108|
                  |L23.106|
00006a  2503              MOVS     r5,#3                 ;594
                  |L23.108|
00006c  bb3d              CBNZ     r5,|L23.190|
00006e  466b              MOV      r3,sp                 ;601
000070  2201              MOVS     r2,#1                 ;601
000072  2107              MOVS     r1,#7                 ;601
000074  4630              MOV      r0,r6                 ;601
000076  f7fffffe          BL       pdb_write_buf_get
00007a  4605              MOV      r5,r0                 ;601
00007c  b9fd              CBNZ     r5,|L23.190|
00007e  2150              MOVS     r1,#0x50              ;604
000080  9801              LDR      r0,[sp,#4]            ;604
000082  f7fffffe          BL       __aeabi_memclr
000086  9801              LDR      r0,[sp,#4]            ;606
000088  f8808000          STRB     r8,[r0,#0]            ;606
00008c  9801              LDR      r0,[sp,#4]            ;608
00008e  3034              ADDS     r0,r0,#0x34           ;608
000090  9002              STR      r0,[sp,#8]            ;608
000092  9705              STR      r7,[sp,#0x14]         ;609
000094  9801              LDR      r0,[sp,#4]            ;610
000096  3018              ADDS     r0,r0,#0x18           ;610
000098  9006              STR      r0,[sp,#0x18]         ;610
00009a  9801              LDR      r0,[sp,#4]            ;611
00009c  1c40              ADDS     r0,r0,#1              ;611
00009e  9007              STR      r0,[sp,#0x1c]         ;611
0000a0  4921              LDR      r1,|L23.296|
0000a2  9109              STR      r1,[sp,#0x24]         ;612
0000a4  9801              LDR      r0,[sp,#4]            ;616
0000a6  f1000111          ADD      r1,r0,#0x11           ;616
0000aa  980a              LDR      r0,[sp,#0x28]         ;616
0000ac  f7fffffe          BL       im_ble_addr_get
0000b0  4683              MOV      r11,r0                ;616
0000b2  2107              MOVS     r1,#7                 ;621
0000b4  4630              MOV      r0,r6                 ;621
0000b6  f7fffffe          BL       pdb_write_buf_store_prepare
0000ba  4605              MOV      r5,r0                 ;621
0000bc  bf00              NOP                            ;622
                  |L23.190|
0000be  e002              B        |L23.198|
                  |L23.192|
0000c0  9705              STR      r7,[sp,#0x14]         ;629
0000c2  4919              LDR      r1,|L23.296|
0000c4  9109              STR      r1,[sp,#0x24]         ;630
                  |L23.198|
0000c6  b9f5              CBNZ     r5,|L23.262|
0000c8  f1b80f02          CMP      r8,#2                 ;637
0000cc  d106              BNE      |L23.220|
0000ce  ab02              ADD      r3,sp,#8              ;639
0000d0  2200              MOVS     r2,#0                 ;639
0000d2  4649              MOV      r1,r9                 ;639
0000d4  980a              LDR      r0,[sp,#0x28]         ;639
0000d6  df7f              SVC      #0x7f                 ;639
0000d8  4605              MOV      r5,r0                 ;639
0000da  e014              B        |L23.262|
                  |L23.220|
0000dc  ab02              ADD      r3,sp,#8              ;643
0000de  4622              MOV      r2,r4                 ;643
0000e0  4649              MOV      r1,r9                 ;643
0000e2  980a              LDR      r0,[sp,#0x28]         ;643
0000e4  df7f              SVC      #0x7f                 ;643
0000e6  4605              MOV      r5,r0                 ;643
0000e8  b16c              CBZ      r4,|L23.262|
0000ea  b965              CBNZ     r5,|L23.262|
0000ec  7820              LDRB     r0,[r4,#0]            ;647
0000ee  f0000001          AND      r0,r0,#1              ;647
0000f2  b108              CBZ      r0,|L23.248|
0000f4  2001              MOVS     r0,#1                 ;648
0000f6  e000              B        |L23.250|
                  |L23.248|
0000f8  2002              MOVS     r0,#2                 ;649
                  |L23.250|
0000fa  4683              MOV      r11,r0                ;649
0000fc  4659              MOV      r1,r11                ;650
0000fe  980a              LDR      r0,[sp,#0x28]         ;650
000100  f7fffffe          BL       sec_start_send
000104  bf00              NOP                            ;651
                  |L23.262|
000106  f8cda000          STR      r10,[sp,#0]           ;655
00010a  b925              CBNZ     r5,|L23.278|
00010c  f1b90f85          CMP      r9,#0x85              ;657
000110  d001              BEQ      |L23.278|
000112  2001              MOVS     r0,#1                 ;657
000114  e000              B        |L23.280|
                  |L23.278|
000116  2000              MOVS     r0,#0                 ;657
                  |L23.280|
000118  4602              MOV      r2,r0                 ;657
00011a  2301              MOVS     r3,#1                 ;657
00011c  4631              MOV      r1,r6                 ;657
00011e  980a              LDR      r0,[sp,#0x28]         ;657
000120  f7fffffe          BL       sec_proc_start
000124  4628              MOV      r0,r5                 ;661
000126  e782              B        |L23.46|
;;;663    
                          ENDP

                  |L23.296|
                          DCD      m_peer_pk

                          AREA ||i.smd_pdb_evt_handler||, CODE, READONLY, ALIGN=2

                  smd_pdb_evt_handler PROC
;;;103     */
;;;104    void smd_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b53e              PUSH     {r1-r5,lr}
;;;105    {
000002  4604              MOV      r4,r0
;;;106        if ((p_event->evt_id == PDB_EVT_WRITE_BUF_STORED) && (p_event->data_id == PM_PEER_DATA_ID_BONDING))
000004  7820              LDRB     r0,[r4,#0]
000006  b990              CBNZ     r0,|L24.46|
000008  7920              LDRB     r0,[r4,#4]
00000a  2807              CMP      r0,#7
00000c  d10f              BNE      |L24.46|
;;;107        {
;;;108            smd_evt_t evt =
00000e  4a08              LDR      r2,|L24.48|
000010  ca07              LDM      r2,{r0-r2}
000012  e88d0007          STM      sp,{r0-r2}
000016  8860              LDRH     r0,[r4,#2]
000018  f7fffffe          BL       im_conn_handle_get
00001c  f8ad0002          STRH     r0,[sp,#2]
000020  8860              LDRH     r0,[r4,#2]
000022  f8ad0004          STRH     r0,[sp,#4]
;;;109            {
;;;110                .evt_id      = SMD_EVT_BONDING_INFO_STORED,
;;;111                .conn_handle = im_conn_handle_get(p_event->peer_id),
;;;112                .params      = {.bonding_info_stored = {.peer_id = p_event->peer_id}}
;;;113            };
;;;114            evt_send(&evt);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       evt_send
;;;115        }
00002c  bf00              NOP      
                  |L24.46|
;;;116    }
00002e  bd3e              POP      {r1-r5,pc}
;;;117    
                          ENDP

                  |L24.48|
                          DCD      ||.constdata||+0x14

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  m_peer_pk
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      sm_smd_evt_handler
                          DCD      gcm_smd_evt_handler
000008  0200              DCB      0x02,0x00
00000a  0000              DCW      0x0000
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000014  0700              DCB      0x07,0x00
000016  0000              DCW      0x0000
000018  0000              DCW      0x0000
00001a  0000              DCB      0x00,0x00
                          DCD      0x00000000
000020  0100              DCB      0x01,0x00
000022  0000              DCW      0x0000
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
00002c  0400              DCB      0x04,0x00
00002e  0000              DCW      0x0000
000030  0000              DCW      0x0000
000032  0000              DCB      0x00,0x00
                          DCD      0x00000000
000038  0600              DCB      0x06,0x00
00003a  0000              DCW      0x0000
00003c  0000              DCW      0x0000
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_flag_sec_proc
000001  18                DCB      0x18
                  m_flag_sec_proc_pairing
000002  18                DCB      0x18
                  m_flag_sec_proc_new_peer
000003  18                DCB      0x18

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\security_dispatcher.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_security_dispatcher_c_15a53087____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REVSH|
#line 402
|__asm___21_security_dispatcher_c_15a53087____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____RRX|
#line 587
|__asm___21_security_dispatcher_c_15a53087____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
