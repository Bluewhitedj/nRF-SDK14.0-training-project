; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\app_timer.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\app_timer.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\app_timer.crf ..\..\..\..\..\..\components\libraries\timer\app_timer.c]
                          THUMB

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;1671    */
;;;1672   __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1673   {
;;;1674     NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L1.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1675   }
000010  4770              BX       lr
;;;1676   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0xe000e280

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_SetPendingIRQ PROC
;;;1660    */
;;;1661   __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1662   {
;;;1663     NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L3.20|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1664   }
000010  4770              BX       lr
;;;1665   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0xe000e200

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L4.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  074a              LSLS     r2,r1,#29
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L4.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L4.30|
                  |L4.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  074a              LSLS     r2,r1,#29
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L4.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L4.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L4.32|
                          DCD      0xe000ed18
                  |L4.36|
                          DCD      0xe000e400

                          AREA ||i.RTC1_IRQHandler||, CODE, READONLY, ALIGN=2

                  RTC1_IRQHandler PROC
;;;900     */
;;;901    void RTC1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;902    {
;;;903        // Clear all events (also unexpected ones)
;;;904        NRF_RTC1->EVENTS_COMPARE[0] = 0;
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L5.44|
000006  6008              STR      r0,[r1,#0]
;;;905        NRF_RTC1->EVENTS_COMPARE[1] = 0;
000008  2100              MOVS     r1,#0
00000a  4809              LDR      r0,|L5.48|
00000c  f8c01144          STR      r1,[r0,#0x144]
;;;906        NRF_RTC1->EVENTS_COMPARE[2] = 0;
000010  f8c01148          STR      r1,[r0,#0x148]
;;;907        NRF_RTC1->EVENTS_COMPARE[3] = 0;
000014  f8c0114c          STR      r1,[r0,#0x14c]
;;;908        NRF_RTC1->EVENTS_TICK       = 0;
000018  2000              MOVS     r0,#0
00001a  4905              LDR      r1,|L5.48|
00001c  f8c10100          STR      r0,[r1,#0x100]
;;;909        NRF_RTC1->EVENTS_OVRFLW     = 0;
000020  4902              LDR      r1,|L5.44|
000022  393c              SUBS     r1,r1,#0x3c
000024  6008              STR      r0,[r1,#0]
;;;910    
;;;911        // Check for expired timers
;;;912        timer_timeouts_check();
000026  f7fffffe          BL       timer_timeouts_check
;;;913    }
00002a  bd10              POP      {r4,pc}
;;;914    
                          ENDP

                  |L5.44|
                          DCD      0x40011140
                  |L5.48|
                          DCD      0x40011000

                          AREA ||i.SWI0_EGU0_IRQHandler||, CODE, READONLY, ALIGN=1

                  SWI0_EGU0_IRQHandler PROC
;;;919     */
;;;920    void SWI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;921    {
;;;922        timer_list_handler();
000002  f7fffffe          BL       timer_list_handler
;;;923    }
000006  bd10              POP      {r4,pc}
;;;924    
                          ENDP


                          AREA ||i.app_timer_cnt_diff_compute||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_diff_compute PROC
;;;1046   
;;;1047   uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
000000  b570              PUSH     {r4-r6,lr}
;;;1048                                       uint32_t   ticks_from)
;;;1049   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1050       return ticks_diff_get(ticks_to, ticks_from);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ticks_diff_get
;;;1051   }
00000e  bd70              POP      {r4-r6,pc}
;;;1052   
                          ENDP


                          AREA ||i.app_timer_cnt_get||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_get PROC
;;;1040   
;;;1041   uint32_t app_timer_cnt_get(void)
000000  b510              PUSH     {r4,lr}
;;;1042   {
;;;1043       return rtc1_counter_get();
000002  f7fffffe          BL       rtc1_counter_get
;;;1044   }
000006  bd10              POP      {r4,pc}
;;;1045   
                          ENDP


                          AREA ||i.app_timer_create||, CODE, READONLY, ALIGN=2

                  app_timer_create PROC
;;;955    
;;;956    ret_code_t app_timer_create(app_timer_id_t const *      p_timer_id,
000000  b510              PUSH     {r4,lr}
;;;957                                app_timer_mode_t            mode,
;;;958                                app_timer_timeout_handler_t timeout_handler)
;;;959    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;960        // Check state and parameters
;;;961        VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  480b              LDR      r0,|L9.56|
00000a  7880              LDRB     r0,[r0,#2]  ; m_op_queue
00000c  b908              CBNZ     r0,|L9.18|
00000e  2008              MOVS     r0,#8
                  |L9.16|
;;;962    
;;;963        if (timeout_handler == NULL)
;;;964        {
;;;965            return NRF_ERROR_INVALID_PARAM;
;;;966        }
;;;967        if (p_timer_id == NULL)
;;;968        {
;;;969            return NRF_ERROR_INVALID_PARAM;
;;;970        }
;;;971        if (((timer_node_t*)*p_timer_id)->is_running)
;;;972        {
;;;973            return NRF_ERROR_INVALID_STATE;
;;;974        }
;;;975    
;;;976        timer_node_t * p_node     = (timer_node_t *)*p_timer_id;
;;;977        p_node->is_running        = false;
;;;978        p_node->mode              = mode;
;;;979        p_node->p_timeout_handler = timeout_handler;
;;;980        return NRF_SUCCESS;
;;;981    }
000010  bd10              POP      {r4,pc}
                  |L9.18|
000012  bf00              NOP                            ;961
000014  b90a              CBNZ     r2,|L9.26|
000016  2007              MOVS     r0,#7                 ;965
000018  e7fa              B        |L9.16|
                  |L9.26|
00001a  b90b              CBNZ     r3,|L9.32|
00001c  2007              MOVS     r0,#7                 ;969
00001e  e7f7              B        |L9.16|
                  |L9.32|
000020  6818              LDR      r0,[r3,#0]            ;971
000022  7c00              LDRB     r0,[r0,#0x10]         ;971
000024  b108              CBZ      r0,|L9.42|
000026  2008              MOVS     r0,#8                 ;973
000028  e7f2              B        |L9.16|
                  |L9.42|
00002a  6819              LDR      r1,[r3,#0]            ;976
00002c  2000              MOVS     r0,#0                 ;977
00002e  7408              STRB     r0,[r1,#0x10]         ;977
000030  744c              STRB     r4,[r1,#0x11]         ;978
000032  614a              STR      r2,[r1,#0x14]         ;979
000034  bf00              NOP                            ;980
000036  e7eb              B        |L9.16|
;;;982    
                          ENDP

                  |L9.56|
                          DCD      m_op_queue

                          AREA ||i.app_timer_init||, CODE, READONLY, ALIGN=2

                  app_timer_init PROC
;;;925    
;;;926    ret_code_t app_timer_init(void)
000000  b510              PUSH     {r4,lr}
;;;927    {
;;;928        // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
;;;929        rtc1_stop();
000002  f7fffffe          BL       rtc1_stop
;;;930    
;;;931        // Initialize operation queue
;;;932        m_op_queue.first           = 0;
000006  2000              MOVS     r0,#0
000008  490f              LDR      r1,|L10.72|
00000a  7008              STRB     r0,[r1,#0]
;;;933        m_op_queue.last            = 0;
00000c  7048              STRB     r0,[r1,#1]
;;;934        m_op_queue.size            = APP_TIMER_CONFIG_OP_QUEUE_SIZE+1;
00000e  200b              MOVS     r0,#0xb
000010  7088              STRB     r0,[r1,#2]
;;;935    
;;;936        mp_timer_id_head            = NULL;
000012  2000              MOVS     r0,#0
000014  490d              LDR      r1,|L10.76|
000016  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
;;;937        m_ticks_elapsed_q_read_ind  = 0;
000018  490d              LDR      r1,|L10.80|
00001a  7008              STRB     r0,[r1,#0]
;;;938        m_ticks_elapsed_q_write_ind = 0;
00001c  490d              LDR      r1,|L10.84|
00001e  7008              STRB     r0,[r1,#0]
;;;939    
;;;940    #if APP_TIMER_WITH_PROFILER
;;;941        m_max_user_op_queue_utilization   = 0;
;;;942    #endif
;;;943    
;;;944        NVIC_ClearPendingIRQ(SWI_IRQn);
000020  2014              MOVS     r0,#0x14
000022  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;945        NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
000026  2107              MOVS     r1,#7
000028  2014              MOVS     r0,#0x14
00002a  f7fffffe          BL       NVIC_SetPriority
;;;946        NVIC_EnableIRQ(SWI_IRQn);
00002e  2014              MOVS     r0,#0x14
000030  f7fffffe          BL       NVIC_EnableIRQ
;;;947    
;;;948        rtc1_init(APP_TIMER_CONFIG_RTC_FREQUENCY);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       rtc1_init
;;;949    
;;;950        m_ticks_latest = rtc1_counter_get();
00003a  f7fffffe          BL       rtc1_counter_get
00003e  4906              LDR      r1,|L10.88|
000040  6008              STR      r0,[r1,#0]  ; m_ticks_latest
;;;951    
;;;952        return NRF_SUCCESS;
000042  2000              MOVS     r0,#0
;;;953    }
000044  bd10              POP      {r4,pc}
;;;954    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      m_op_queue
                  |L10.76|
                          DCD      mp_timer_id_head
                  |L10.80|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L10.84|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L10.88|
                          DCD      m_ticks_latest

                          AREA ||i.app_timer_pause||, CODE, READONLY, ALIGN=2

                  app_timer_pause PROC
;;;1059   
;;;1060   void app_timer_pause(void)
000000  2001              MOVS     r0,#1
;;;1061   {
;;;1062       NRF_RTC1->TASKS_STOP = 1;
000002  4901              LDR      r1,|L11.8|
000004  6048              STR      r0,[r1,#4]
;;;1063   }
000006  4770              BX       lr
;;;1064   
                          ENDP

                  |L11.8|
                          DCD      0x40011000

                          AREA ||i.app_timer_resume||, CODE, READONLY, ALIGN=2

                  app_timer_resume PROC
;;;1064   
;;;1065   void app_timer_resume(void)
000000  2001              MOVS     r0,#1
;;;1066   {
;;;1067       NRF_RTC1->TASKS_START = 1;
000002  4901              LDR      r1,|L12.8|
000004  6008              STR      r0,[r1,#0]
;;;1068   }
000006  4770              BX       lr
;;;1069   
                          ENDP

                  |L12.8|
                          DCD      0x40011000

                          AREA ||i.app_timer_start||, CODE, READONLY, ALIGN=2

                  app_timer_start PROC
;;;982    
;;;983    ret_code_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;984    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;985        uint32_t timeout_periodic;
;;;986        timer_node_t * p_node = (timer_node_t*)timer_id;
00000a  4625              MOV      r5,r4
;;;987    
;;;988        // Check state and parameters
;;;989        VERIFY_MODULE_INITIALIZED();
00000c  bf00              NOP      
00000e  4810              LDR      r0,|L13.80|
000010  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000012  b910              CBNZ     r0,|L13.26|
000014  2008              MOVS     r0,#8
                  |L13.22|
;;;990    
;;;991        if (timer_id == 0)
;;;992        {
;;;993            return NRF_ERROR_INVALID_STATE;
;;;994        }
;;;995        if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
;;;996        {
;;;997            return NRF_ERROR_INVALID_PARAM;
;;;998        }
;;;999        if (p_node->p_timeout_handler == NULL)
;;;1000       {
;;;1001           return NRF_ERROR_INVALID_STATE;
;;;1002       }
;;;1003   
;;;1004       // Schedule timer start operation
;;;1005       timeout_periodic = (p_node->mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
;;;1006   
;;;1007       return timer_start_op_schedule(p_node,
;;;1008                                      timeout_ticks,
;;;1009                                      timeout_periodic,
;;;1010                                      p_context);
;;;1011   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L13.26|
00001a  bf00              NOP                            ;989
00001c  b90c              CBNZ     r4,|L13.34|
00001e  2008              MOVS     r0,#8                 ;993
000020  e7f9              B        |L13.22|
                  |L13.34|
000022  2e05              CMP      r6,#5                 ;995
000024  d201              BCS      |L13.42|
000026  2007              MOVS     r0,#7                 ;997
000028  e7f5              B        |L13.22|
                  |L13.42|
00002a  6968              LDR      r0,[r5,#0x14]         ;999
00002c  b908              CBNZ     r0,|L13.50|
00002e  2008              MOVS     r0,#8                 ;1001
000030  e7f1              B        |L13.22|
                  |L13.50|
000032  7c68              LDRB     r0,[r5,#0x11]         ;1005
000034  2801              CMP      r0,#1                 ;1005
000036  d101              BNE      |L13.60|
000038  4630              MOV      r0,r6                 ;1005
00003a  e000              B        |L13.62|
                  |L13.60|
00003c  2000              MOVS     r0,#0                 ;1005
                  |L13.62|
00003e  4680              MOV      r8,r0                 ;1005
000040  463b              MOV      r3,r7                 ;1007
000042  4642              MOV      r2,r8                 ;1007
000044  4631              MOV      r1,r6                 ;1007
000046  4628              MOV      r0,r5                 ;1007
000048  f7fffffe          BL       timer_start_op_schedule
00004c  e7e3              B        |L13.22|
;;;1012   
                          ENDP

00004e  0000              DCW      0x0000
                  |L13.80|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop||, CODE, READONLY, ALIGN=2

                  app_timer_stop PROC
;;;1013   
;;;1014   ret_code_t app_timer_stop(app_timer_id_t timer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;1015   {
000002  4604              MOV      r4,r0
;;;1016       timer_node_t * p_node = (timer_node_t*)timer_id;
000004  4625              MOV      r5,r4
;;;1017       // Check state and parameters
;;;1018       VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  4808              LDR      r0,|L14.44|
00000a  7880              LDRB     r0,[r0,#2]  ; m_op_queue
00000c  b908              CBNZ     r0,|L14.18|
00000e  2008              MOVS     r0,#8
                  |L14.16|
;;;1019   
;;;1020       if ((timer_id == NULL) || (p_node->p_timeout_handler == NULL))
;;;1021       {
;;;1022           return NRF_ERROR_INVALID_STATE;
;;;1023       }
;;;1024   
;;;1025       p_node->is_running = false;
;;;1026   
;;;1027       // Schedule timer stop operation
;;;1028       return timer_stop_op_schedule(p_node, TIMER_USER_OP_TYPE_STOP);
;;;1029   }
000010  bd70              POP      {r4-r6,pc}
                  |L14.18|
000012  bf00              NOP                            ;1018
000014  b10c              CBZ      r4,|L14.26|
000016  6968              LDR      r0,[r5,#0x14]         ;1020
000018  b908              CBNZ     r0,|L14.30|
                  |L14.26|
00001a  2008              MOVS     r0,#8                 ;1022
00001c  e7f8              B        |L14.16|
                  |L14.30|
00001e  2000              MOVS     r0,#0                 ;1025
000020  7428              STRB     r0,[r5,#0x10]         ;1025
000022  2102              MOVS     r1,#2                 ;1028
000024  4628              MOV      r0,r5                 ;1028
000026  f7fffffe          BL       timer_stop_op_schedule
00002a  e7f1              B        |L14.16|
;;;1030   
                          ENDP

                  |L14.44|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop_all||, CODE, READONLY, ALIGN=2

                  app_timer_stop_all PROC
;;;1031   
;;;1032   ret_code_t app_timer_stop_all(void)
000000  b510              PUSH     {r4,lr}
;;;1033   {
;;;1034       // Check state
;;;1035       VERIFY_MODULE_INITIALIZED();
000002  bf00              NOP      
000004  4805              LDR      r0,|L15.28|
000006  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000008  b908              CBNZ     r0,|L15.14|
00000a  2008              MOVS     r0,#8
                  |L15.12|
;;;1036   
;;;1037       return timer_stop_op_schedule(NULL, TIMER_USER_OP_TYPE_STOP_ALL);
;;;1038   }
00000c  bd10              POP      {r4,pc}
                  |L15.14|
00000e  bf00              NOP                            ;1035
000010  2103              MOVS     r1,#3                 ;1037
000012  2000              MOVS     r0,#0                 ;1037
000014  f7fffffe          BL       timer_stop_op_schedule
000018  e7f8              B        |L15.12|
;;;1039   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      m_op_queue

                          AREA ||i.compare_reg_update||, CODE, READONLY, ALIGN=2

                  compare_reg_update PROC
;;;668     */
;;;669    static void compare_reg_update(timer_node_t * p_timer_id_head_old)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;670    {
000004  4682              MOV      r10,r0
;;;671        // Setup the timeout for timers on the head of the list
;;;672        if (mp_timer_id_head != NULL)
000006  481f              LDR      r0,|L16.132|
000008  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
00000a  2800              CMP      r0,#0
00000c  d036              BEQ      |L16.124|
;;;673        {
;;;674            uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
00000e  481d              LDR      r0,|L16.132|
000010  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000012  6805              LDR      r5,[r0,#0]
;;;675            uint32_t pre_counter_val = rtc1_counter_get();
000014  f7fffffe          BL       rtc1_counter_get
000018  4607              MOV      r7,r0
;;;676            uint32_t cc              = m_ticks_latest;
00001a  481b              LDR      r0,|L16.136|
00001c  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;677            uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       ticks_diff_get
000026  1cc6              ADDS     r6,r0,#3
;;;678    
;;;679            if (!m_rtc1_running)
000028  4818              LDR      r0,|L16.140|
00002a  7800              LDRB     r0,[r0,#0]  ; m_rtc1_running
00002c  b908              CBNZ     r0,|L16.50|
;;;680            {
;;;681                // No timers were already running, start RTC
;;;682                rtc1_start();
00002e  f7fffffe          BL       rtc1_start
                  |L16.50|
;;;683            }
;;;684    
;;;685            cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
000032  42ae              CMP      r6,r5
000034  d201              BCS      |L16.58|
000036  4628              MOV      r0,r5
000038  e000              B        |L16.60|
                  |L16.58|
00003a  4630              MOV      r0,r6
                  |L16.60|
00003c  4404              ADD      r4,r4,r0
;;;686            cc &= MAX_RTC_COUNTER_VAL;
00003e  f024447f          BIC      r4,r4,#0xff000000
;;;687    
;;;688            rtc1_compare0_set(cc);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rtc1_compare0_set
;;;689    
;;;690            uint32_t post_counter_val = rtc1_counter_get();
000048  f7fffffe          BL       rtc1_counter_get
00004c  4680              MOV      r8,r0
;;;691    
;;;692            if (
00004e  4639              MOV      r1,r7
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       ticks_diff_get
000056  f1000903          ADD      r9,r0,#3
00005a  4639              MOV      r1,r7
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       ticks_diff_get
000062  4581              CMP      r9,r0
000064  d909              BLS      |L16.122|
;;;693                (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
;;;694                >
;;;695                ticks_diff_get(cc, pre_counter_val)
;;;696               )
;;;697            {
;;;698                // When this happens the COMPARE event may not be triggered by the RTC.
;;;699                // The nRF51 Series User Specification states that if the COUNTER value is N
;;;700                // (i.e post_counter_val = N), writing N or N + 1 to a CC register may not trigger a
;;;701                // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
;;;702                // function.
;;;703                rtc1_compare0_set(rtc1_counter_get());  // this should prevent CC to fire again in the background while the code is in RTC-ISR
000066  f7fffffe          BL       rtc1_counter_get
00006a  4681              MOV      r9,r0
00006c  f7fffffe          BL       rtc1_compare0_set
;;;704                nrf_delay_us(MAX_RTC_TASKS_DELAY);
000070  202f              MOVS     r0,#0x2f
000072  f7fffffe          BL       nrf_delay_us
;;;705                timer_timeouts_check_sched();
000076  f7fffffe          BL       timer_timeouts_check_sched
                  |L16.122|
;;;706            }
;;;707        }
00007a  e001              B        |L16.128|
                  |L16.124|
;;;708        else
;;;709        {
;;;710    #if (APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;711            // No timers are running, stop RTC
;;;712            rtc1_stop();
00007c  f7fffffe          BL       rtc1_stop
                  |L16.128|
;;;713    #endif //(APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;714        }
;;;715    }
000080  e8bd87f0          POP      {r4-r10,pc}
;;;716    
                          ENDP

                  |L16.132|
                          DCD      mp_timer_id_head
                  |L16.136|
                          DCD      m_ticks_latest
                  |L16.140|
                          DCD      m_rtc1_running

                          AREA ||i.elapsed_ticks_acquire||, CODE, READONLY, ALIGN=2

                  elapsed_ticks_acquire PROC
;;;468     */
;;;469    static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
000000  4601              MOV      r1,r0
;;;470    {
;;;471        // Pick the elapsed value from queue.
;;;472        if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
000002  4814              LDR      r0,|L17.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000006  4a14              LDR      r2,|L17.88|
000008  7812              LDRB     r2,[r2,#0]  ; m_ticks_elapsed_q_write_ind
00000a  4290              CMP      r0,r2
00000c  d01d              BEQ      |L17.74|
;;;473        {
;;;474            // Dequeue elapsed value.
;;;475            m_ticks_elapsed_q_read_ind++;
00000e  4811              LDR      r0,|L17.84|
000010  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000012  1c40              ADDS     r0,r0,#1
000014  4a0f              LDR      r2,|L17.84|
000016  7010              STRB     r0,[r2,#0]
;;;476            if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
000018  4610              MOV      r0,r2
00001a  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
00001c  2802              CMP      r0,#2
00001e  d101              BNE      |L17.36|
;;;477            {
;;;478                m_ticks_elapsed_q_read_ind = 0;
000020  2000              MOVS     r0,#0
000022  7010              STRB     r0,[r2,#0]
                  |L17.36|
;;;479            }
;;;480    
;;;481            *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
000024  480d              LDR      r0,|L17.92|
000026  4a0b              LDR      r2,|L17.84|
000028  7812              LDRB     r2,[r2,#0]  ; m_ticks_elapsed_q_read_ind
00002a  f8500022          LDR      r0,[r0,r2,LSL #2]
00002e  6008              STR      r0,[r1,#0]
;;;482    
;;;483            m_ticks_latest += *p_ticks_elapsed;
000030  4a0b              LDR      r2,|L17.96|
000032  6808              LDR      r0,[r1,#0]
000034  6812              LDR      r2,[r2,#0]  ; m_ticks_latest
000036  4410              ADD      r0,r0,r2
000038  4a09              LDR      r2,|L17.96|
00003a  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;484            m_ticks_latest &= MAX_RTC_COUNTER_VAL;
00003c  4610              MOV      r0,r2
00003e  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
000040  f020407f          BIC      r0,r0,#0xff000000
000044  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;485    
;;;486            return true;
000046  2001              MOVS     r0,#1
                  |L17.72|
;;;487        }
;;;488        else
;;;489        {
;;;490            // No elapsed value in queue.
;;;491            *p_ticks_elapsed = 0;
;;;492            return false;
;;;493        }
;;;494    }
000048  4770              BX       lr
                  |L17.74|
00004a  2000              MOVS     r0,#0                 ;491
00004c  6008              STR      r0,[r1,#0]            ;491
00004e  bf00              NOP                            ;492
000050  e7fa              B        |L17.72|
;;;495    
                          ENDP

000052  0000              DCW      0x0000
                  |L17.84|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L17.88|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L17.92|
                          DCD      m_ticks_elapsed
                  |L17.96|
                          DCD      m_ticks_latest

                          AREA ||i.expired_timers_handler||, CODE, READONLY, ALIGN=2

                  expired_timers_handler PROC
;;;502     */
;;;503    static void expired_timers_handler(uint32_t         ticks_elapsed,
000000  b5f0              PUSH     {r4-r7,lr}
;;;504                                       uint32_t         ticks_previous,
;;;505                                       timer_node_t **  p_restart_list_head)
;;;506    {
000002  4603              MOV      r3,r0
;;;507        uint32_t ticks_expired = 0;
000004  2400              MOVS     r4,#0
;;;508    
;;;509        while (mp_timer_id_head != NULL)
000006  e01f              B        |L18.72|
                  |L18.8|
;;;510        {
;;;511            timer_node_t * p_timer;
;;;512            timer_node_t * p_timer_expired;
;;;513    
;;;514            // Auto variable for current timer node.
;;;515            p_timer = mp_timer_id_head;
000008  4e12              LDR      r6,|L18.84|
00000a  6830              LDR      r0,[r6,#0]  ; mp_timer_id_head
;;;516    
;;;517            // Do nothing if timer did not expire
;;;518            if (ticks_elapsed < p_timer->ticks_to_expire)
00000c  6806              LDR      r6,[r0,#0]
00000e  429e              CMP      r6,r3
000010  d903              BLS      |L18.26|
;;;519            {
;;;520                p_timer->ticks_to_expire -= ticks_elapsed;
000012  6806              LDR      r6,[r0,#0]
000014  1af6              SUBS     r6,r6,r3
000016  6006              STR      r6,[r0,#0]
;;;521                break;
000018  e01a              B        |L18.80|
                  |L18.26|
;;;522            }
;;;523    
;;;524            // Decrement ticks_elapsed and collect expired ticks.
;;;525            ticks_elapsed -= p_timer->ticks_to_expire;
00001a  6806              LDR      r6,[r0,#0]
00001c  1b9b              SUBS     r3,r3,r6
;;;526            ticks_expired += p_timer->ticks_to_expire;
00001e  6806              LDR      r6,[r0,#0]
000020  4434              ADD      r4,r4,r6
;;;527    
;;;528            // Timer expired, set ticks_to_expire zero.
;;;529            p_timer->ticks_to_expire = 0;
000022  2600              MOVS     r6,#0
000024  6006              STR      r6,[r0,#0]
;;;530    
;;;531            // Remove the expired timer from head.
;;;532            p_timer_expired  = mp_timer_id_head;
000026  4e0b              LDR      r6,|L18.84|
000028  6835              LDR      r5,[r6,#0]  ; mp_timer_id_head
;;;533            mp_timer_id_head = p_timer->next;
00002a  4f0a              LDR      r7,|L18.84|
00002c  69c6              LDR      r6,[r0,#0x1c]
00002e  603e              STR      r6,[r7,#0]  ; mp_timer_id_head
;;;534    
;;;535            // Timer will be restarted if periodic.
;;;536            if (p_timer->ticks_periodic_interval != 0)
000030  68c6              LDR      r6,[r0,#0xc]
000032  b146              CBZ      r6,|L18.70|
;;;537            {
;;;538                p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
000034  190e              ADDS     r6,r1,r4
000036  f026467f          BIC      r6,r6,#0xff000000
00003a  6046              STR      r6,[r0,#4]
;;;539                p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
00003c  68c6              LDR      r6,[r0,#0xc]
00003e  6086              STR      r6,[r0,#8]
;;;540                p_timer->next                 = *p_restart_list_head;
000040  6816              LDR      r6,[r2,#0]
000042  61c6              STR      r6,[r0,#0x1c]
;;;541                *p_restart_list_head          = p_timer_expired;
000044  6015              STR      r5,[r2,#0]
                  |L18.70|
;;;542            }
;;;543        }
000046  bf00              NOP      
                  |L18.72|
000048  4802              LDR      r0,|L18.84|
00004a  6800              LDR      r0,[r0,#0]            ;509  ; mp_timer_id_head
00004c  2800              CMP      r0,#0                 ;509
00004e  d1db              BNE      |L18.8|
                  |L18.80|
000050  bf00              NOP                            ;521
;;;544    }
000052  bdf0              POP      {r4-r7,pc}
;;;545    
                          ENDP

                  |L18.84|
                          DCD      mp_timer_id_head

                          AREA ||i.list_insertions_handler||, CODE, READONLY, ALIGN=2

                  list_insertions_handler PROC
;;;552     */
;;;553    static bool list_insertions_handler(timer_node_t * p_restart_list_head)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;554    {
000004  4606              MOV      r6,r0
;;;555        bool compare_update = false;
000006  2700              MOVS     r7,#0
;;;556    
;;;557        timer_node_t * p_timer_id_old_head;
;;;558    
;;;559        // Remember the old head, so as to decide if new compare needs to be set.
;;;560        p_timer_id_old_head = mp_timer_id_head;
000008  4847              LDR      r0,|L19.296|
00000a  f8d08000          LDR      r8,[r0,#0]  ; mp_timer_id_head
;;;561    
;;;562        // Handle insertions of timers.
;;;563        while ((p_restart_list_head != NULL) || (m_op_queue.first != m_op_queue.last))
00000e  e078              B        |L19.258|
                  |L19.16|
;;;564        {
;;;565            timer_node_t * p_timer;
;;;566    
;;;567            if (p_restart_list_head != NULL)
000010  b116              CBZ      r6,|L19.24|
;;;568            {
;;;569                p_timer           = p_restart_list_head;
000012  4634              MOV      r4,r6
;;;570                p_restart_list_head = p_timer->next;
000014  69e6              LDR      r6,[r4,#0x1c]
000016  e047              B        |L19.168|
                  |L19.24|
;;;571            }
;;;572            else
;;;573            {
;;;574                timer_user_op_t * p_user_op = &m_op_queue.user_op_queue[m_op_queue.first];
000018  4844              LDR      r0,|L19.300|
00001a  7800              LDRB     r0,[r0,#0]  ; m_op_queue
00001c  eb000140          ADD      r1,r0,r0,LSL #1
000020  4842              LDR      r0,|L19.300|
000022  1d00              ADDS     r0,r0,#4
000024  eb0005c1          ADD      r5,r0,r1,LSL #3
;;;575    
;;;576                m_op_queue.first++;
000028  1f00              SUBS     r0,r0,#4
00002a  7800              LDRB     r0,[r0,#0]  ; m_op_queue
00002c  1c40              ADDS     r0,r0,#1
00002e  493f              LDR      r1,|L19.300|
000030  7008              STRB     r0,[r1,#0]
;;;577                if (m_op_queue.first == m_op_queue.size)
000032  4608              MOV      r0,r1
000034  7800              LDRB     r0,[r0,#0]  ; m_op_queue
000036  7889              LDRB     r1,[r1,#2]  ; m_op_queue
000038  4288              CMP      r0,r1
00003a  d102              BNE      |L19.66|
;;;578                {
;;;579                    m_op_queue.first = 0;
00003c  2000              MOVS     r0,#0
00003e  493b              LDR      r1,|L19.300|
000040  7008              STRB     r0,[r1,#0]
                  |L19.66|
;;;580                }
;;;581    
;;;582                p_timer = p_user_op->p_node;
000042  686c              LDR      r4,[r5,#4]
;;;583    
;;;584                switch (p_user_op->op_type)
000044  7828              LDRB     r0,[r5,#0]
000046  2801              CMP      r0,#1
000048  d01a              BEQ      |L19.128|
00004a  2802              CMP      r0,#2
00004c  d002              BEQ      |L19.84|
00004e  2803              CMP      r0,#3
000050  d117              BNE      |L19.130|
000052  e007              B        |L19.100|
                  |L19.84|
;;;585                {
;;;586                    case TIMER_USER_OP_TYPE_STOP:
;;;587                        // Delete node if timer is running.
;;;588                        if (timer_list_remove(p_user_op->p_node))
000054  6868              LDR      r0,[r5,#4]
000056  f7fffffe          BL       timer_list_remove
00005a  b100              CBZ      r0,|L19.94|
;;;589                        {
;;;590                            compare_update = true;
00005c  2701              MOVS     r7,#1
                  |L19.94|
;;;591                        }
;;;592    
;;;593                        p_timer->is_running = false;
00005e  2000              MOVS     r0,#0
000060  7420              STRB     r0,[r4,#0x10]
;;;594                        continue;
000062  e04e              B        |L19.258|
                  |L19.100|
;;;595    
;;;596                    case TIMER_USER_OP_TYPE_STOP_ALL:
;;;597                        // Delete list of running timers, and mark all timers as not running.
;;;598                        while (mp_timer_id_head != NULL)
000064  e007              B        |L19.118|
                  |L19.102|
;;;599                        {
;;;600                            timer_node_t * p_head = mp_timer_id_head;
000066  4930              LDR      r1,|L19.296|
000068  6808              LDR      r0,[r1,#0]  ; mp_timer_id_head
;;;601    
;;;602                            p_head->is_running = false;
00006a  2100              MOVS     r1,#0
00006c  7401              STRB     r1,[r0,#0x10]
;;;603                            mp_timer_id_head    = p_head->next;
00006e  4a2e              LDR      r2,|L19.296|
000070  69c1              LDR      r1,[r0,#0x1c]
000072  6011              STR      r1,[r2,#0]  ; mp_timer_id_head
;;;604                        }
000074  bf00              NOP      
                  |L19.118|
000076  482c              LDR      r0,|L19.296|
000078  6800              LDR      r0,[r0,#0]            ;598  ; mp_timer_id_head
00007a  2800              CMP      r0,#0                 ;598
00007c  d1f3              BNE      |L19.102|
;;;605                        continue;
00007e  e040              B        |L19.258|
                  |L19.128|
;;;606                    case TIMER_USER_OP_TYPE_START:
;;;607                        break;
000080  e000              B        |L19.132|
                  |L19.130|
;;;608                    default:
;;;609                        // No implementation needed.
;;;610                        continue;
000082  e03e              B        |L19.258|
                  |L19.132|
000084  bf00              NOP                            ;607
;;;611                }
;;;612    
;;;613                if (p_timer->is_running)
000086  7c20              LDRB     r0,[r4,#0x10]
000088  b100              CBZ      r0,|L19.140|
;;;614                {
;;;615                    continue;
00008a  e03a              B        |L19.258|
                  |L19.140|
;;;616                }
;;;617    
;;;618                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
00008c  68a8              LDR      r0,[r5,#8]
00008e  6060              STR      r0,[r4,#4]
;;;619                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
000090  68e8              LDR      r0,[r5,#0xc]
000092  60a0              STR      r0,[r4,#8]
;;;620                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
000094  6928              LDR      r0,[r5,#0x10]
000096  60e0              STR      r0,[r4,#0xc]
;;;621                p_timer->p_context               = p_user_op->params.start.p_context;
000098  6968              LDR      r0,[r5,#0x14]
00009a  61a0              STR      r0,[r4,#0x18]
;;;622    
;;;623                if (m_rtc1_reset)
00009c  4824              LDR      r0,|L19.304|
00009e  7800              LDRB     r0,[r0,#0]  ; m_rtc1_reset
0000a0  b108              CBZ      r0,|L19.166|
;;;624                {
;;;625                    p_timer->ticks_at_start = 0;
0000a2  2000              MOVS     r0,#0
0000a4  6060              STR      r0,[r4,#4]
                  |L19.166|
;;;626                }
;;;627            }
0000a6  bf00              NOP      
                  |L19.168|
;;;628    
;;;629            // Prepare the node to be inserted.
;;;630            if (
0000a8  4922              LDR      r1,|L19.308|
0000aa  6860              LDR      r0,[r4,#4]
0000ac  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
0000ae  1a40              SUBS     r0,r0,r1
0000b0  f020407f          BIC      r0,r0,#0xff000000
0000b4  4920              LDR      r1,|L19.312|
0000b6  4288              CMP      r0,r1
0000b8  d208              BCS      |L19.204|
;;;631                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
;;;632                 <
;;;633                 (MAX_RTC_COUNTER_VAL / 2)
;;;634                )
;;;635            {
;;;636                p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) +
0000ba  491e              LDR      r1,|L19.308|
0000bc  6860              LDR      r0,[r4,#4]
0000be  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
0000c0  f7fffffe          BL       ticks_diff_get
0000c4  68a1              LDR      r1,[r4,#8]
0000c6  4408              ADD      r0,r0,r1
0000c8  6020              STR      r0,[r4,#0]
0000ca  e00f              B        |L19.236|
                  |L19.204|
;;;637                                           p_timer->ticks_first_interval;
;;;638            }
;;;639            else
;;;640            {
;;;641                uint32_t delta_current_start;
;;;642    
;;;643                delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
0000cc  4819              LDR      r0,|L19.308|
0000ce  6861              LDR      r1,[r4,#4]
0000d0  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
0000d2  f7fffffe          BL       ticks_diff_get
0000d6  4605              MOV      r5,r0
;;;644                if (p_timer->ticks_first_interval > delta_current_start)
0000d8  68a0              LDR      r0,[r4,#8]
0000da  42a8              CMP      r0,r5
0000dc  d903              BLS      |L19.230|
;;;645                {
;;;646                    p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
0000de  68a0              LDR      r0,[r4,#8]
0000e0  1b40              SUBS     r0,r0,r5
0000e2  6020              STR      r0,[r4,#0]
0000e4  e001              B        |L19.234|
                  |L19.230|
;;;647                }
;;;648                else
;;;649                {
;;;650                    p_timer->ticks_to_expire = 0;
0000e6  2000              MOVS     r0,#0
0000e8  6020              STR      r0,[r4,#0]
                  |L19.234|
;;;651                }
;;;652            }
0000ea  bf00              NOP      
                  |L19.236|
;;;653    
;;;654            p_timer->ticks_at_start       = 0;
0000ec  2000              MOVS     r0,#0
0000ee  6060              STR      r0,[r4,#4]
;;;655            p_timer->ticks_first_interval = 0;
0000f0  60a0              STR      r0,[r4,#8]
;;;656            p_timer->is_running           = true;
0000f2  2001              MOVS     r0,#1
0000f4  7420              STRB     r0,[r4,#0x10]
;;;657            p_timer->next                 = NULL;
0000f6  2000              MOVS     r0,#0
0000f8  61e0              STR      r0,[r4,#0x1c]
;;;658    
;;;659            // Insert into list
;;;660            timer_list_insert(p_timer);
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       timer_list_insert
000100  bf00              NOP                            ;594
                  |L19.258|
000102  2e00              CMP      r6,#0                 ;563
                  |L19.260|
000104  d184              BNE      |L19.16|
000106  4809              LDR      r0,|L19.300|
000108  7800              LDRB     r0,[r0,#0]            ;563  ; m_op_queue
00010a  4908              LDR      r1,|L19.300|
00010c  7849              LDRB     r1,[r1,#1]            ;563  ; m_op_queue
00010e  4288              CMP      r0,r1                 ;563
000110  d1f8              BNE      |L19.260|
;;;661        }
;;;662    
;;;663        return (compare_update || (mp_timer_id_head != p_timer_id_old_head));
000112  b91f              CBNZ     r7,|L19.284|
000114  4804              LDR      r0,|L19.296|
000116  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000118  4540              CMP      r0,r8
00011a  d002              BEQ      |L19.290|
                  |L19.284|
00011c  2001              MOVS     r0,#1
                  |L19.286|
;;;664    }
00011e  e8bd81f0          POP      {r4-r8,pc}
                  |L19.290|
000122  2000              MOVS     r0,#0                 ;663
000124  e7fb              B        |L19.286|
;;;665    
                          ENDP

000126  0000              DCW      0x0000
                  |L19.296|
                          DCD      mp_timer_id_head
                  |L19.300|
                          DCD      m_op_queue
                  |L19.304|
                          DCD      m_rtc1_reset
                  |L19.308|
                          DCD      m_ticks_latest
                  |L19.312|
                          DCD      0x007fffff

                          AREA ||i.nrf_delay_us||, CODE, READONLY, ALIGN=2

                  nrf_delay_us PROC
;;;83     #if defined ( __CC_ARM   )
;;;84     __STATIC_INLINE void nrf_delay_us(uint32_t number_of_us)
000000  b900              CBNZ     r0,|L20.4|
                  |L20.2|
;;;85     {
;;;86         if (!number_of_us)
;;;87             return;
;;;88     __asm
;;;89         {
;;;90     loop:
;;;91         NOP
;;;92         NOP
;;;93         NOP
;;;94         NOP
;;;95         NOP
;;;96         NOP
;;;97         NOP
;;;98         NOP
;;;99         CMP SystemCoreClock, CLOCK_FREQ_16MHz
;;;100        BEQ cond
;;;101        NOP
;;;102    #ifdef  CPU_FREQ_64MHz
;;;103        NOP
;;;104        NOP
;;;105        NOP
;;;106        NOP
;;;107        NOP
;;;108        NOP
;;;109        NOP
;;;110        NOP
;;;111        NOP
;;;112        NOP
;;;113        NOP
;;;114        NOP
;;;115        NOP
;;;116        NOP
;;;117        NOP
;;;118        NOP
;;;119        NOP
;;;120        NOP
;;;121        NOP
;;;122        NOP
;;;123        NOP
;;;124        NOP
;;;125        NOP
;;;126        NOP
;;;127        NOP
;;;128        NOP
;;;129        NOP
;;;130        NOP
;;;131        NOP
;;;132        NOP
;;;133        NOP
;;;134        NOP
;;;135        NOP
;;;136        NOP
;;;137        NOP
;;;138        NOP
;;;139        NOP
;;;140        NOP
;;;141        NOP
;;;142        NOP
;;;143        NOP
;;;144        NOP
;;;145        NOP
;;;146        NOP
;;;147        NOP
;;;148        NOP
;;;149        NOP
;;;150    #endif //CPU_FREQ_64MHz
;;;151    cond:
;;;152        SUBS number_of_us, #1
;;;153        BNE loop
;;;154        }
;;;155    }
000002  4770              BX       lr
                  |L20.4|
000004  bf00              NOP                            ;90
                  |L20.6|
000006  bf00              NOP                            ;91
000008  bf00              NOP                            ;92
00000a  bf00              NOP                            ;93
00000c  bf00              NOP                            ;94
00000e  bf00              NOP                            ;95
000010  bf00              NOP                            ;96
000012  bf00              NOP                            ;97
000014  bf00              NOP                            ;98
000016  491f              LDR      r1,|L20.148|
000018  6809              LDR      r1,[r1,#0]            ;99  ; SystemCoreClock
00001a  4a1f              LDR      r2,|L20.152|
00001c  4291              CMP      r1,r2                 ;99
00001e  d100              BNE      |L20.34|
000020  e030              B        |L20.132|
                  |L20.34|
000022  bf00              NOP                            ;101
000024  bf00              NOP                            ;103
000026  bf00              NOP                            ;104
000028  bf00              NOP                            ;105
00002a  bf00              NOP                            ;106
00002c  bf00              NOP                            ;107
00002e  bf00              NOP                            ;108
000030  bf00              NOP                            ;109
000032  bf00              NOP                            ;110
000034  bf00              NOP                            ;111
000036  bf00              NOP                            ;112
000038  bf00              NOP                            ;113
00003a  bf00              NOP                            ;114
00003c  bf00              NOP                            ;115
00003e  bf00              NOP                            ;116
000040  bf00              NOP                            ;117
000042  bf00              NOP                            ;118
000044  bf00              NOP                            ;119
000046  bf00              NOP                            ;120
000048  bf00              NOP                            ;121
00004a  bf00              NOP                            ;122
00004c  bf00              NOP                            ;123
00004e  bf00              NOP                            ;124
000050  bf00              NOP                            ;125
000052  bf00              NOP                            ;126
000054  bf00              NOP                            ;127
000056  bf00              NOP                            ;128
000058  bf00              NOP                            ;129
00005a  bf00              NOP                            ;130
00005c  bf00              NOP                            ;131
00005e  bf00              NOP                            ;132
000060  bf00              NOP                            ;133
000062  bf00              NOP                            ;134
000064  bf00              NOP                            ;135
000066  bf00              NOP                            ;136
000068  bf00              NOP                            ;137
00006a  bf00              NOP                            ;138
00006c  bf00              NOP                            ;139
00006e  bf00              NOP                            ;140
000070  bf00              NOP                            ;141
000072  bf00              NOP                            ;142
000074  bf00              NOP                            ;143
000076  bf00              NOP                            ;144
000078  bf00              NOP                            ;145
00007a  bf00              NOP                            ;146
00007c  bf00              NOP                            ;147
00007e  bf00              NOP                            ;148
000080  bf00              NOP                            ;149
000082  bf00              NOP                            ;151
                  |L20.132|
000084  4601              MOV      r1,r0                 ;152
000086  3901              SUBS     r1,#1                 ;152
000088  4608              MOV      r0,r1                 ;152
00008a  d000              BEQ      |L20.142|
00008c  e7bb              B        |L20.6|
                  |L20.142|
00008e  bf00              NOP      
000090  e7b7              B        |L20.2|
;;;156    
                          ENDP

000092  0000              DCW      0x0000
                  |L20.148|
                          DCD      SystemCoreClock
                  |L20.152|
                          DCD      0x00f42400

                          AREA ||i.rtc1_compare0_set||, CODE, READONLY, ALIGN=2

                  rtc1_compare0_set PROC
;;;226     */
;;;227    static __INLINE void rtc1_compare0_set(uint32_t value)
000000  4901              LDR      r1,|L21.8|
;;;228    {
;;;229        NRF_RTC1->CC[0] = value;
000002  6008              STR      r0,[r1,#0]
;;;230    }
000004  4770              BX       lr
;;;231    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40011540

                          AREA ||i.rtc1_counter_get||, CODE, READONLY, ALIGN=2

                  rtc1_counter_get PROC
;;;205     */
;;;206    static __INLINE uint32_t rtc1_counter_get(void)
000000  4801              LDR      r0,|L22.8|
;;;207    {
;;;208        return NRF_RTC1->COUNTER;
000002  6800              LDR      r0,[r0,#0]
;;;209    }
000004  4770              BX       lr
;;;210    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x40011504

                          AREA ||i.rtc1_init||, CODE, READONLY, ALIGN=2

                  rtc1_init PROC
;;;157     */
;;;158    static void rtc1_init(uint32_t prescaler)
000000  b510              PUSH     {r4,lr}
;;;159    {
000002  4604              MOV      r4,r0
;;;160        NRF_RTC1->PRESCALER = prescaler;
000004  4803              LDR      r0,|L23.20|
000006  6004              STR      r4,[r0,#0]
;;;161        NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
000008  2107              MOVS     r1,#7
00000a  2011              MOVS     r0,#0x11
00000c  f7fffffe          BL       NVIC_SetPriority
;;;162    }
000010  bd10              POP      {r4,pc}
;;;163    
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40011508

                          AREA ||i.rtc1_start||, CODE, READONLY, ALIGN=2

                  rtc1_start PROC
;;;166     */
;;;167    static void rtc1_start(void)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169        NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
000002  f44f3080          MOV      r0,#0x10000
000006  490a              LDR      r1,|L24.48|
000008  6008              STR      r0,[r1,#0]
;;;170        NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
00000a  490a              LDR      r1,|L24.52|
00000c  f8c10304          STR      r0,[r1,#0x304]
;;;171    
;;;172        NVIC_ClearPendingIRQ(RTC1_IRQn);
000010  2011              MOVS     r0,#0x11
000012  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;173        NVIC_EnableIRQ(RTC1_IRQn);
000016  2011              MOVS     r0,#0x11
000018  f7fffffe          BL       NVIC_EnableIRQ
;;;174    
;;;175        NRF_RTC1->TASKS_START = 1;
00001c  2001              MOVS     r0,#1
00001e  4905              LDR      r1,|L24.52|
000020  6008              STR      r0,[r1,#0]
;;;176        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000022  202f              MOVS     r0,#0x2f
000024  f7fffffe          BL       nrf_delay_us
;;;177    
;;;178        m_rtc1_running = true;
000028  2001              MOVS     r0,#1
00002a  4903              LDR      r1,|L24.56|
00002c  7008              STRB     r0,[r1,#0]
;;;179    }
00002e  bd10              POP      {r4,pc}
;;;180    
                          ENDP

                  |L24.48|
                          DCD      0x40011344
                  |L24.52|
                          DCD      0x40011000
                  |L24.56|
                          DCD      m_rtc1_running

                          AREA ||i.rtc1_stop||, CODE, READONLY, ALIGN=2

                  rtc1_stop PROC
;;;183     */
;;;184    static void rtc1_stop(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186        NVIC_DisableIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  2101              MOVS     r1,#1
000006  4081              LSLS     r1,r1,r0
000008  4a0e              LDR      r2,|L25.68|
00000a  0943              LSRS     r3,r0,#5
00000c  f8421023          STR      r1,[r2,r3,LSL #2]
000010  bf00              NOP      
;;;187    
;;;188        NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
000012  f44f3080          MOV      r0,#0x10000
000016  490c              LDR      r1,|L25.72|
000018  6008              STR      r0,[r1,#0]
;;;189        NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
00001a  490c              LDR      r1,|L25.76|
00001c  f8c10308          STR      r0,[r1,#0x308]
;;;190    
;;;191        NRF_RTC1->TASKS_STOP = 1;
000020  2001              MOVS     r0,#1
000022  6048              STR      r0,[r1,#4]
;;;192        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000024  202f              MOVS     r0,#0x2f
000026  f7fffffe          BL       nrf_delay_us
;;;193    
;;;194        NRF_RTC1->TASKS_CLEAR = 1;
00002a  2001              MOVS     r0,#1
00002c  4907              LDR      r1,|L25.76|
00002e  6088              STR      r0,[r1,#8]
;;;195        m_ticks_latest        = 0;
000030  2000              MOVS     r0,#0
000032  4907              LDR      r1,|L25.80|
000034  6008              STR      r0,[r1,#0]  ; m_ticks_latest
;;;196        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000036  202f              MOVS     r0,#0x2f
000038  f7fffffe          BL       nrf_delay_us
;;;197    
;;;198        m_rtc1_running = false;
00003c  2000              MOVS     r0,#0
00003e  4905              LDR      r1,|L25.84|
000040  7008              STRB     r0,[r1,#0]
;;;199    }
000042  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L25.68|
                          DCD      0xe000e180
                  |L25.72|
                          DCD      0x40011348
                  |L25.76|
                          DCD      0x40011000
                  |L25.80|
                          DCD      m_ticks_latest
                  |L25.84|
                          DCD      m_rtc1_running

                          AREA ||i.ticks_diff_get||, CODE, READONLY, ALIGN=1

                  ticks_diff_get PROC
;;;215     */
;;;216    static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
000000  4602              MOV      r2,r0
;;;217    {
;;;218        return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
000002  1a50              SUBS     r0,r2,r1
000004  f020407f          BIC      r0,r0,#0xff000000
;;;219    }
000008  4770              BX       lr
;;;220    
                          ENDP


                          AREA ||i.timeout_handler_exec||, CODE, READONLY, ALIGN=1

                  timeout_handler_exec PROC
;;;377     */
;;;378    static void timeout_handler_exec(timer_node_t * p_timer)
000000  b510              PUSH     {r4,lr}
;;;379    {
000002  4604              MOV      r4,r0
;;;380    #if APP_TIMER_CONFIG_USE_SCHEDULER
;;;381        app_timer_event_t timer_event;
;;;382    
;;;383        timer_event.timeout_handler = p_timer->p_timeout_handler;
;;;384        timer_event.p_context       = p_timer->p_context;
;;;385        uint32_t err_code = app_sched_event_put(&timer_event, sizeof(timer_event), timeout_handler_scheduled_exec);
;;;386        APP_ERROR_CHECK(err_code);
;;;387    #else
;;;388        p_timer->p_timeout_handler(p_timer->p_context);
000004  e9d41005          LDRD     r1,r0,[r4,#0x14]
000008  4788              BLX      r1
;;;389    #endif
;;;390    }
00000a  bd10              POP      {r4,pc}
;;;391    
                          ENDP


                          AREA ||i.timer_list_handler||, CODE, READONLY, ALIGN=2

                  timer_list_handler PROC
;;;719     */
;;;720    static void timer_list_handler(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;721    {
;;;722        timer_node_t * p_restart_list_head = NULL;
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
;;;723    
;;;724        uint32_t       ticks_elapsed;
;;;725        uint32_t       ticks_previous;
;;;726        bool           ticks_have_elapsed;
;;;727        bool           compare_update = false;
000008  2600              MOVS     r6,#0
;;;728        timer_node_t * p_timer_id_head_old;
;;;729    
;;;730    #if APP_TIMER_WITH_PROFILER
;;;731        {
;;;732            uint8_t size = m_op_queue.size;
;;;733            uint8_t first = m_op_queue.first;
;;;734            uint8_t last = m_op_queue.last;
;;;735            uint8_t utilization = (first <= last) ? (last - first) : (size + 1 - first + last);
;;;736    
;;;737            if (utilization > m_max_user_op_queue_utilization)
;;;738            {
;;;739                m_max_user_op_queue_utilization = utilization;
;;;740            }
;;;741        }
;;;742    #endif
;;;743    
;;;744        // Back up the previous known tick and previous list head
;;;745        ticks_previous    = m_ticks_latest;
00000a  480e              LDR      r0,|L28.68|
00000c  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;746        p_timer_id_head_old = mp_timer_id_head;
00000e  480e              LDR      r0,|L28.72|
000010  6807              LDR      r7,[r0,#0]  ; mp_timer_id_head
;;;747    
;;;748        // Get number of elapsed ticks
;;;749        ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       elapsed_ticks_acquire
000018  4605              MOV      r5,r0
;;;750    
;;;751        // Handle expired timers
;;;752        if (ticks_have_elapsed)
00001a  b12d              CBZ      r5,|L28.40|
;;;753        {
;;;754            expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
00001c  aa01              ADD      r2,sp,#4
00001e  4621              MOV      r1,r4
000020  9800              LDR      r0,[sp,#0]
000022  f7fffffe          BL       expired_timers_handler
;;;755            compare_update = true;
000026  2601              MOVS     r6,#1
                  |L28.40|
;;;756        }
;;;757    
;;;758    
;;;759        // Handle list insertions
;;;760        if (list_insertions_handler(p_restart_list_head))
000028  9801              LDR      r0,[sp,#4]
00002a  f7fffffe          BL       list_insertions_handler
00002e  b100              CBZ      r0,|L28.50|
;;;761        {
;;;762            compare_update = true;
000030  2601              MOVS     r6,#1
                  |L28.50|
;;;763        }
;;;764    
;;;765        // Update compare register if necessary
;;;766        if (compare_update)
000032  b116              CBZ      r6,|L28.58|
;;;767        {
;;;768            compare_reg_update(p_timer_id_head_old);
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       compare_reg_update
                  |L28.58|
;;;769        }
;;;770        m_rtc1_reset = false;
00003a  2000              MOVS     r0,#0
00003c  4903              LDR      r1,|L28.76|
00003e  7008              STRB     r0,[r1,#0]
;;;771    }
000040  e8bd81fc          POP      {r2-r8,pc}
;;;772    
                          ENDP

                  |L28.68|
                          DCD      m_ticks_latest
                  |L28.72|
                          DCD      mp_timer_id_head
                  |L28.76|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_list_handler_sched||, CODE, READONLY, ALIGN=1

                  timer_list_handler_sched PROC
;;;357     */
;;;358    static void timer_list_handler_sched(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360        NVIC_SetPendingIRQ(SWI_IRQn);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;361    }
000008  bd10              POP      {r4,pc}
;;;362    
                          ENDP


                          AREA ||i.timer_list_insert||, CODE, READONLY, ALIGN=2

                  timer_list_insert PROC
;;;236     */
;;;237    static void timer_list_insert(timer_node_t * p_timer)
000000  b510              PUSH     {r4,lr}
;;;238    {
;;;239        if (mp_timer_id_head == NULL)
000002  4918              LDR      r1,|L30.100|
000004  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
000006  b911              CBNZ     r1,|L30.14|
;;;240        {
;;;241            mp_timer_id_head = p_timer;
000008  4916              LDR      r1,|L30.100|
00000a  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
00000c  e028              B        |L30.96|
                  |L30.14|
;;;242        }
;;;243        else
;;;244        {
;;;245            if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
00000e  4a15              LDR      r2,|L30.100|
000010  6801              LDR      r1,[r0,#0]
000012  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
000014  6812              LDR      r2,[r2,#0]
000016  4291              CMP      r1,r2
000018  d80d              BHI      |L30.54|
;;;246            {
;;;247                mp_timer_id_head->ticks_to_expire -= p_timer->ticks_to_expire;
00001a  4912              LDR      r1,|L30.100|
00001c  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
00001e  6809              LDR      r1,[r1,#0]
000020  6802              LDR      r2,[r0,#0]
000022  1a89              SUBS     r1,r1,r2
000024  4a0f              LDR      r2,|L30.100|
000026  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
000028  6011              STR      r1,[r2,#0]
;;;248    
;;;249                p_timer->next   = mp_timer_id_head;
00002a  490e              LDR      r1,|L30.100|
00002c  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
00002e  61c1              STR      r1,[r0,#0x1c]
;;;250                mp_timer_id_head = p_timer;
000030  490c              LDR      r1,|L30.100|
000032  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
000034  e014              B        |L30.96|
                  |L30.54|
;;;251            }
;;;252            else
;;;253            {
;;;254                timer_node_t * p_previous;
;;;255                timer_node_t * p_current;
;;;256                uint32_t       ticks_to_expire;
;;;257    
;;;258                ticks_to_expire   = p_timer->ticks_to_expire;
000036  6802              LDR      r2,[r0,#0]
;;;259                p_previous        = mp_timer_id_head;
000038  4c0a              LDR      r4,|L30.100|
00003a  6823              LDR      r3,[r4,#0]  ; mp_timer_id_head
;;;260                p_current         = mp_timer_id_head;
00003c  6821              LDR      r1,[r4,#0]  ; mp_timer_id_head
;;;261    
;;;262                while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
00003e  e003              B        |L30.72|
                  |L30.64|
;;;263                {
;;;264                    ticks_to_expire   -= p_current->ticks_to_expire;
000040  680c              LDR      r4,[r1,#0]
000042  1b12              SUBS     r2,r2,r4
;;;265                    p_previous         = p_current;
000044  460b              MOV      r3,r1
;;;266                    p_current          = p_current->next;
000046  69c9              LDR      r1,[r1,#0x1c]
                  |L30.72|
000048  b111              CBZ      r1,|L30.80|
00004a  680c              LDR      r4,[r1,#0]            ;262
00004c  4294              CMP      r4,r2                 ;262
00004e  d3f7              BCC      |L30.64|
                  |L30.80|
;;;267                }
;;;268    
;;;269                if (p_current != NULL)
000050  b111              CBZ      r1,|L30.88|
;;;270                {
;;;271                    p_current->ticks_to_expire -= ticks_to_expire;
000052  680c              LDR      r4,[r1,#0]
000054  1aa4              SUBS     r4,r4,r2
000056  600c              STR      r4,[r1,#0]
                  |L30.88|
;;;272                }
;;;273    
;;;274                p_timer->ticks_to_expire = ticks_to_expire;
000058  6002              STR      r2,[r0,#0]
;;;275                p_timer->next            = p_current;
00005a  61c1              STR      r1,[r0,#0x1c]
;;;276                p_previous->next         = p_timer;
00005c  61d8              STR      r0,[r3,#0x1c]
;;;277            }
00005e  bf00              NOP      
                  |L30.96|
;;;278        }
;;;279    }
000060  bd10              POP      {r4,pc}
;;;280    
                          ENDP

000062  0000              DCW      0x0000
                  |L30.100|
                          DCD      mp_timer_id_head

                          AREA ||i.timer_list_remove||, CODE, READONLY, ALIGN=2

                  timer_list_remove PROC
;;;287     */
;;;288    static bool timer_list_remove(timer_node_t * p_timer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
000004  4606              MOV      r6,r0
;;;290        timer_node_t * p_old_head;
;;;291        timer_node_t * p_previous;
;;;292        timer_node_t * p_current;
;;;293        uint32_t       timeout;
;;;294    
;;;295        // Find the timer's position in timer list.
;;;296        p_old_head = mp_timer_id_head;
000006  481c              LDR      r0,|L31.120|
000008  f8d08000          LDR      r8,[r0,#0]  ; mp_timer_id_head
;;;297        p_previous = mp_timer_id_head;
00000c  6805              LDR      r5,[r0,#0]  ; mp_timer_id_head
;;;298        p_current  = p_previous;
00000e  462c              MOV      r4,r5
;;;299    
;;;300        while (p_current != NULL)
000010  e004              B        |L31.28|
                  |L31.18|
;;;301        {
;;;302            if (p_current == p_timer)
000012  42b4              CMP      r4,r6
000014  d100              BNE      |L31.24|
;;;303            {
;;;304                break;
000016  e003              B        |L31.32|
                  |L31.24|
;;;305            }
;;;306            p_previous = p_current;
000018  4625              MOV      r5,r4
;;;307            p_current  = p_current->next;
00001a  69e4              LDR      r4,[r4,#0x1c]
                  |L31.28|
00001c  2c00              CMP      r4,#0                 ;300
00001e  d1f8              BNE      |L31.18|
                  |L31.32|
000020  bf00              NOP                            ;304
;;;308        }
;;;309    
;;;310        // Timer not in active list.
;;;311        if (p_current == NULL)
000022  b914              CBNZ     r4,|L31.42|
;;;312        {
;;;313            return false;
000024  2000              MOVS     r0,#0
                  |L31.38|
;;;314        }
;;;315    
;;;316        // Timer is the first in the list
;;;317        if (p_previous == p_current)
;;;318        {
;;;319            mp_timer_id_head = mp_timer_id_head->next;
;;;320    
;;;321            // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
;;;322            if (mp_timer_id_head == NULL)
;;;323            {
;;;324                NRF_RTC1->TASKS_CLEAR = 1;
;;;325                m_ticks_latest        = 0;
;;;326                m_rtc1_reset          = true;
;;;327                nrf_delay_us(MAX_RTC_TASKS_DELAY);
;;;328            }
;;;329        }
;;;330    
;;;331        // Remaining timeout between next timeout.
;;;332        timeout = p_current->ticks_to_expire;
;;;333    
;;;334        // Link previous timer with next of this timer, i.e. removing the timer from list.
;;;335        p_previous->next = p_current->next;
;;;336    
;;;337        // If this is not the last timer, increment the next timer by this timer timeout.
;;;338        p_current = p_previous->next;
;;;339        if (p_current != NULL)
;;;340        {
;;;341            p_current->ticks_to_expire += timeout;
;;;342        }
;;;343    
;;;344        return (p_old_head != mp_timer_id_head);
;;;345    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L31.42|
00002a  42a5              CMP      r5,r4                 ;317
00002c  d113              BNE      |L31.86|
00002e  4812              LDR      r0,|L31.120|
000030  6800              LDR      r0,[r0,#0]            ;319  ; mp_timer_id_head
000032  69c0              LDR      r0,[r0,#0x1c]         ;319
000034  4910              LDR      r1,|L31.120|
000036  6008              STR      r0,[r1,#0]            ;319  ; mp_timer_id_head
000038  4608              MOV      r0,r1                 ;322
00003a  6800              LDR      r0,[r0,#0]            ;322  ; mp_timer_id_head
00003c  b958              CBNZ     r0,|L31.86|
00003e  2001              MOVS     r0,#1                 ;324
000040  490e              LDR      r1,|L31.124|
000042  6088              STR      r0,[r1,#8]            ;324
000044  2000              MOVS     r0,#0                 ;325
000046  490e              LDR      r1,|L31.128|
000048  6008              STR      r0,[r1,#0]            ;325  ; m_ticks_latest
00004a  2001              MOVS     r0,#1                 ;326
00004c  490d              LDR      r1,|L31.132|
00004e  7008              STRB     r0,[r1,#0]            ;326
000050  202f              MOVS     r0,#0x2f              ;327
000052  f7fffffe          BL       nrf_delay_us
                  |L31.86|
000056  6827              LDR      r7,[r4,#0]            ;332
000058  69e0              LDR      r0,[r4,#0x1c]         ;335
00005a  61e8              STR      r0,[r5,#0x1c]         ;335
00005c  69ec              LDR      r4,[r5,#0x1c]         ;338
00005e  b114              CBZ      r4,|L31.102|
000060  6820              LDR      r0,[r4,#0]            ;341
000062  4438              ADD      r0,r0,r7              ;341
000064  6020              STR      r0,[r4,#0]            ;341
                  |L31.102|
000066  4804              LDR      r0,|L31.120|
000068  6800              LDR      r0,[r0,#0]            ;344  ; mp_timer_id_head
00006a  4580              CMP      r8,r0                 ;344
00006c  d001              BEQ      |L31.114|
00006e  2001              MOVS     r0,#1                 ;344
000070  e7d9              B        |L31.38|
                  |L31.114|
000072  2000              MOVS     r0,#0                 ;344
000074  e7d7              B        |L31.38|
;;;346    
                          ENDP

000076  0000              DCW      0x0000
                  |L31.120|
                          DCD      mp_timer_id_head
                  |L31.124|
                          DCD      0x40011000
                  |L31.128|
                          DCD      m_ticks_latest
                  |L31.132|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_start_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_start_op_schedule PROC
;;;823    
;;;824    static uint32_t timer_start_op_schedule(timer_node_t * p_node,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;825                                            uint32_t        timeout_initial,
;;;826                                            uint32_t        timeout_periodic,
;;;827                                            void *          p_context)
;;;828    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;829        uint8_t last_index;
;;;830        uint32_t err_code = NRF_SUCCESS;
00000c  f04f0900          MOV      r9,#0
;;;831    
;;;832        CRITICAL_REGION_ENTER();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       app_util_critical_region_enter
;;;833        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
00001a  a801              ADD      r0,sp,#4
00001c  f7fffffe          BL       user_op_alloc
000020  4604              MOV      r4,r0
;;;834        if (p_user_op == NULL)
000022  b914              CBNZ     r4,|L32.42|
;;;835        {
;;;836            err_code = NRF_ERROR_NO_MEM;
000024  f04f0904          MOV      r9,#4
000028  e00d              B        |L32.70|
                  |L32.42|
;;;837        }
;;;838        else
;;;839        {
;;;840            p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
00002a  2001              MOVS     r0,#1
00002c  7020              STRB     r0,[r4,#0]
;;;841            p_user_op->p_node                               = p_node;
00002e  6065              STR      r5,[r4,#4]
;;;842            p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
000030  f7fffffe          BL       rtc1_counter_get
000034  60a0              STR      r0,[r4,#8]
;;;843            p_user_op->params.start.ticks_first_interval    = timeout_initial;
000036  60e6              STR      r6,[r4,#0xc]
;;;844            p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
000038  6127              STR      r7,[r4,#0x10]
;;;845            p_user_op->params.start.p_context               = p_context;
00003a  f8c48014          STR      r8,[r4,#0x14]
;;;846    
;;;847            user_op_enque(last_index);
00003e  f89d0004          LDRB     r0,[sp,#4]
000042  f7fffffe          BL       user_op_enque
                  |L32.70|
;;;848        }
;;;849        CRITICAL_REGION_EXIT();
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  f7fffffe          BL       app_util_critical_region_exit
;;;850    
;;;851        if (err_code == NRF_SUCCESS)
00004e  f1b90f00          CMP      r9,#0
000052  d101              BNE      |L32.88|
;;;852        {
;;;853            timer_list_handler_sched();
000054  f7fffffe          BL       timer_list_handler_sched
                  |L32.88|
;;;854        }
;;;855    
;;;856        return err_code;
000058  4648              MOV      r0,r9
;;;857    }
00005a  e8bd87fc          POP      {r2-r10,pc}
;;;858    
                          ENDP


                          AREA ||i.timer_stop_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_stop_op_schedule PROC
;;;867     */
;;;868    static uint32_t timer_stop_op_schedule(timer_node_t * p_node,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;869                                           timer_user_op_type_t op_type)
;;;870    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;871        uint8_t last_index;
;;;872        uint32_t err_code = NRF_SUCCESS;
000008  2700              MOVS     r7,#0
;;;873    
;;;874        CRITICAL_REGION_ENTER();
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       app_util_critical_region_enter
;;;875        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
000014  a801              ADD      r0,sp,#4
000016  f7fffffe          BL       user_op_alloc
00001a  4604              MOV      r4,r0
;;;876        if (p_user_op == NULL)
00001c  b90c              CBNZ     r4,|L33.34|
;;;877        {
;;;878            err_code = NRF_ERROR_NO_MEM;
00001e  2704              MOVS     r7,#4
000020  e005              B        |L33.46|
                  |L33.34|
;;;879        }
;;;880        else
;;;881        {
;;;882            p_user_op->op_type  = op_type;
000022  7026              STRB     r6,[r4,#0]
;;;883            p_user_op->p_node = p_node;
000024  6065              STR      r5,[r4,#4]
;;;884    
;;;885            user_op_enque(last_index);
000026  f89d0004          LDRB     r0,[sp,#4]
00002a  f7fffffe          BL       user_op_enque
                  |L33.46|
;;;886        }
;;;887        CRITICAL_REGION_EXIT();
00002e  f89d0000          LDRB     r0,[sp,#0]
000032  f7fffffe          BL       app_util_critical_region_exit
;;;888    
;;;889        if (err_code == NRF_SUCCESS)
000036  b90f              CBNZ     r7,|L33.60|
;;;890        {
;;;891            timer_list_handler_sched();
000038  f7fffffe          BL       timer_list_handler_sched
                  |L33.60|
;;;892        }
;;;893    
;;;894        return err_code;
00003c  4638              MOV      r0,r7
;;;895    }
00003e  e8bd81fc          POP      {r2-r8,pc}
;;;896    
                          ENDP


                          AREA ||i.timer_timeouts_check||, CODE, READONLY, ALIGN=2

                  timer_timeouts_check PROC
;;;394     */
;;;395    static void timer_timeouts_check(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;396    {
;;;397        // Handle expired of timer
;;;398        if (mp_timer_id_head != NULL)
000004  481f              LDR      r0,|L34.132|
000006  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000008  2800              CMP      r0,#0
00000a  d038              BEQ      |L34.126|
;;;399        {
;;;400            timer_node_t *  p_timer;
;;;401            timer_node_t *  p_previous_timer;
;;;402            uint32_t        ticks_elapsed;
;;;403            uint32_t        ticks_expired;
;;;404    
;;;405            // Initialize actual elapsed ticks being consumed to 0.
;;;406            ticks_expired = 0;
00000c  2700              MOVS     r7,#0
;;;407    
;;;408            // ticks_elapsed is collected here, job will use it.
;;;409            ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
00000e  f7fffffe          BL       rtc1_counter_get
000012  4680              MOV      r8,r0
000014  481c              LDR      r0,|L34.136|
000016  6801              LDR      r1,[r0,#0]  ; m_ticks_latest
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       ticks_diff_get
00001e  4606              MOV      r6,r0
;;;410    
;;;411            // Auto variable containing the head of timers expiring.
;;;412            p_timer = mp_timer_id_head;
000020  4818              LDR      r0,|L34.132|
000022  6805              LDR      r5,[r0,#0]  ; mp_timer_id_head
;;;413    
;;;414            // Expire all timers within ticks_elapsed and collect ticks_expired.
;;;415            while (p_timer != NULL)
000024  e010              B        |L34.72|
                  |L34.38|
;;;416            {
;;;417                // Do nothing if timer did not expire.
;;;418                if (ticks_elapsed < p_timer->ticks_to_expire)
000026  6828              LDR      r0,[r5,#0]
000028  42b0              CMP      r0,r6
00002a  d900              BLS      |L34.46|
;;;419                {
;;;420                    break;
00002c  e00e              B        |L34.76|
                  |L34.46|
;;;421                }
;;;422    
;;;423                // Decrement ticks_elapsed and collect expired ticks.
;;;424                ticks_elapsed -= p_timer->ticks_to_expire;
00002e  6828              LDR      r0,[r5,#0]
000030  1a36              SUBS     r6,r6,r0
;;;425                ticks_expired += p_timer->ticks_to_expire;
000032  6828              LDR      r0,[r5,#0]
000034  4407              ADD      r7,r7,r0
;;;426    
;;;427                // Move to next timer.
;;;428                p_previous_timer = p_timer;
000036  462c              MOV      r4,r5
;;;429                p_timer = p_timer->next;
000038  69ed              LDR      r5,[r5,#0x1c]
;;;430    
;;;431                // Execute Task.
;;;432                if (p_previous_timer->is_running)
00003a  7c20              LDRB     r0,[r4,#0x10]
00003c  b120              CBZ      r0,|L34.72|
;;;433                {
;;;434                    p_previous_timer->is_running = false;
00003e  2000              MOVS     r0,#0
000040  7420              STRB     r0,[r4,#0x10]
;;;435                    timeout_handler_exec(p_previous_timer);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       timeout_handler_exec
                  |L34.72|
000048  2d00              CMP      r5,#0                 ;415
00004a  d1ec              BNE      |L34.38|
                  |L34.76|
00004c  bf00              NOP                            ;420
;;;436                }
;;;437            }
;;;438    
;;;439            // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
;;;440            if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
00004e  480f              LDR      r0,|L34.140|
000050  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000052  490f              LDR      r1,|L34.144|
000054  7809              LDRB     r1,[r1,#0]  ; m_ticks_elapsed_q_write_ind
000056  4288              CMP      r0,r1
000058  d109              BNE      |L34.110|
;;;441            {
;;;442                // The read index of the queue is equal to the write index. This means the new
;;;443                // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
;;;444                // queue (which is implemented as a double buffer).
;;;445    
;;;446                // Check if there will be a queue overflow.
;;;447                if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
00005a  480d              LDR      r0,|L34.144|
00005c  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_write_ind
00005e  1c40              ADDS     r0,r0,#1
000060  b2c0              UXTB     r0,r0
000062  490b              LDR      r1,|L34.144|
000064  7008              STRB     r0,[r1,#0]
000066  2802              CMP      r0,#2
000068  d101              BNE      |L34.110|
;;;448                {
;;;449                    // There will be a queue overflow. Hence the write index should point to the start
;;;450                    // of the queue.
;;;451                    m_ticks_elapsed_q_write_ind = 0;
00006a  2000              MOVS     r0,#0
00006c  7008              STRB     r0,[r1,#0]
                  |L34.110|
;;;452                }
;;;453            }
;;;454    
;;;455            // Queue the ticks expired.
;;;456            m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
00006e  4809              LDR      r0,|L34.148|
000070  4907              LDR      r1,|L34.144|
000072  7809              LDRB     r1,[r1,#0]  ; m_ticks_elapsed_q_write_ind
000074  f8407021          STR      r7,[r0,r1,LSL #2]
;;;457    
;;;458            timer_list_handler_sched();
000078  f7fffffe          BL       timer_list_handler_sched
;;;459        }
00007c  bf00              NOP      
                  |L34.126|
;;;460    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;461    
                          ENDP

000082  0000              DCW      0x0000
                  |L34.132|
                          DCD      mp_timer_id_head
                  |L34.136|
                          DCD      m_ticks_latest
                  |L34.140|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L34.144|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L34.148|
                          DCD      m_ticks_elapsed

                          AREA ||i.timer_timeouts_check_sched||, CODE, READONLY, ALIGN=1

                  timer_timeouts_check_sched PROC
;;;349     */
;;;350    static void timer_timeouts_check_sched(void)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352        NVIC_SetPendingIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;353    }
000008  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i.user_op_alloc||, CODE, READONLY, ALIGN=2

                  user_op_alloc PROC
;;;789     */
;;;790    static timer_user_op_t * user_op_alloc( uint8_t * p_last_index)
000000  b510              PUSH     {r4,lr}
;;;791    {
000002  4602              MOV      r2,r0
;;;792        uint8_t           last;
;;;793        timer_user_op_t * p_user_op;
;;;794    
;;;795        last = m_op_queue.last + 1;
000004  480c              LDR      r0,|L36.56|
000006  7840              LDRB     r0,[r0,#1]  ; m_op_queue
000008  1c40              ADDS     r0,r0,#1
00000a  b2c1              UXTB     r1,r0
;;;796        if (last == m_op_queue.size)
00000c  480a              LDR      r0,|L36.56|
00000e  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000010  4288              CMP      r0,r1
000012  d100              BNE      |L36.22|
;;;797        {
;;;798            // Overflow case.
;;;799            last = 0;
000014  2100              MOVS     r1,#0
                  |L36.22|
;;;800        }
;;;801        if (last == m_op_queue.first)
000016  4808              LDR      r0,|L36.56|
000018  7800              LDRB     r0,[r0,#0]  ; m_op_queue
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L36.34|
;;;802        {
;;;803            // Queue is full.
;;;804            return NULL;
00001e  2000              MOVS     r0,#0
                  |L36.32|
;;;805        }
;;;806    
;;;807        *p_last_index = last;
;;;808        p_user_op     = &m_op_queue.user_op_queue[m_op_queue.last];
;;;809    
;;;810        return p_user_op;
;;;811    }
000020  bd10              POP      {r4,pc}
                  |L36.34|
000022  7011              STRB     r1,[r2,#0]            ;807
000024  4804              LDR      r0,|L36.56|
000026  7840              LDRB     r0,[r0,#1]            ;808  ; m_op_queue
000028  eb000440          ADD      r4,r0,r0,LSL #1       ;808
00002c  4802              LDR      r0,|L36.56|
00002e  1d00              ADDS     r0,r0,#4              ;808
000030  eb0003c4          ADD      r3,r0,r4,LSL #3       ;808
000034  4618              MOV      r0,r3                 ;810
000036  e7f3              B        |L36.32|
;;;812    
                          ENDP

                  |L36.56|
                          DCD      m_op_queue

                          AREA ||i.user_op_enque||, CODE, READONLY, ALIGN=2

                  user_op_enque PROC
;;;777     */
;;;778    static void user_op_enque(uint8_t last_index)
000000  4901              LDR      r1,|L37.8|
;;;779    {
;;;780        m_op_queue.last = last_index;
000002  7048              STRB     r0,[r1,#1]
;;;781    }
000004  4770              BX       lr
;;;782    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      m_op_queue

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_op_queue
                          %        268

                          AREA ||.data||, DATA, ALIGN=2

                  mp_timer_id_head
                          DCD      0x00000000
                  m_ticks_latest
                          DCD      0x00000000
                  m_ticks_elapsed
                          %        8
                  m_ticks_elapsed_q_read_ind
000010  00                DCB      0x00
                  m_ticks_elapsed_q_write_ind
000011  00                DCB      0x00
                  m_rtc1_running
000012  00                DCB      0x00
                  m_rtc1_reset
000013  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\timer\\app_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_app_timer_c_cd27f9c3____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REVSH|
#line 402
|__asm___11_app_timer_c_cd27f9c3____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____RRX|
#line 587
|__asm___11_app_timer_c_cd27f9c3____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
