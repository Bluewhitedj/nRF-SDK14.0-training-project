; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\fds.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\fds.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\fds.crf ..\..\..\..\..\..\components\libraries\fds\fds.c]
                          THUMB

                          AREA ||i.address_is_valid||, CODE, READONLY, ALIGN=2

                  address_is_valid PROC
;;;182    
;;;183    static bool address_is_valid(uint32_t const * const p_addr)
000000  b510              PUSH     {r4,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185        return ((p_addr != NULL) &&
000004  b16c              CBZ      r4,|L1.34|
;;;186                (p_addr >= (uint32_t*)m_fs.start_addr) &&
000006  4808              LDR      r0,|L1.40|
000008  68c0              LDR      r0,[r0,#0xc]  ; m_fs
00000a  42a0              CMP      r0,r4
00000c  d809              BHI      |L1.34|
;;;187                (p_addr <= (uint32_t*)m_fs.end_addr)   &&
00000e  4806              LDR      r0,|L1.40|
000010  6900              LDR      r0,[r0,#0x10]  ; m_fs
000012  42a0              CMP      r0,r4
000014  d305              BCC      |L1.34|
;;;188                (is_word_aligned(p_addr)));
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       is_word_aligned
00001c  b108              CBZ      r0,|L1.34|
00001e  2001              MOVS     r0,#1
                  |L1.32|
;;;189    }
000020  bd10              POP      {r4,pc}
                  |L1.34|
000022  2000              MOVS     r0,#0                 ;188
000024  e7fc              B        |L1.32|
;;;190    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      m_fs

                          AREA ||i.delete_execute||, CODE, READONLY, ALIGN=1

                  delete_execute PROC
;;;1229   
;;;1230   static ret_code_t delete_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;1231   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1232       ret_code_t ret;
;;;1233   
;;;1234       if (prev_ret != NRF_SUCCESS)
000006  b10e              CBZ      r6,|L2.12|
;;;1235       {
;;;1236           return FDS_ERR_OPERATION_TIMEOUT;
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;1237       }
;;;1238   
;;;1239       switch (p_op->del.step)
;;;1240       {
;;;1241           case FDS_OP_DEL_RECORD_FLAG_DIRTY:
;;;1242               ret = record_find_and_delete(p_op);
;;;1243               p_op->del.step = FDS_OP_DEL_DONE;
;;;1244               break;
;;;1245   
;;;1246           case FDS_OP_DEL_FILE_FLAG_DIRTY:
;;;1247               ret = file_find_and_delete(p_op);
;;;1248               if (ret == FDS_ERR_NOT_FOUND)
;;;1249               {
;;;1250                   // No more records could be found.
;;;1251                   // There won't be another callback for this operation, so return now.
;;;1252                   ret = FDS_OP_COMPLETED;
;;;1253               }
;;;1254               break;
;;;1255   
;;;1256           case FDS_OP_DEL_DONE:
;;;1257               ret = FDS_OP_COMPLETED;
;;;1258               break;
;;;1259   
;;;1260           default:
;;;1261               ret = FDS_ERR_INTERNAL;
;;;1262               break;
;;;1263       }
;;;1264   
;;;1265       return ret;
;;;1266   }
00000a  bd70              POP      {r4-r6,pc}
                  |L2.12|
00000c  7928              LDRB     r0,[r5,#4]            ;1239
00000e  b120              CBZ      r0,|L2.26|
000010  2801              CMP      r0,#1                 ;1239
000012  d009              BEQ      |L2.40|
000014  2802              CMP      r0,#2                 ;1239
000016  d113              BNE      |L2.64|
000018  e00f              B        |L2.58|
                  |L2.26|
00001a  4628              MOV      r0,r5                 ;1242
00001c  f7fffffe          BL       record_find_and_delete
000020  4604              MOV      r4,r0                 ;1242
000022  2002              MOVS     r0,#2                 ;1243
000024  7128              STRB     r0,[r5,#4]            ;1243
000026  e00d              B        |L2.68|
                  |L2.40|
000028  4628              MOV      r0,r5                 ;1247
00002a  f7fffffe          BL       file_find_and_delete
00002e  4604              MOV      r4,r0                 ;1247
000030  2c0a              CMP      r4,#0xa               ;1248
000032  d101              BNE      |L2.56|
000034  f641541d          MOV      r4,#0x1d1d            ;1252
                  |L2.56|
000038  e004              B        |L2.68|
                  |L2.58|
00003a  f641541d          MOV      r4,#0x1d1d            ;1257
00003e  e001              B        |L2.68|
                  |L2.64|
000040  240f              MOVS     r4,#0xf               ;1261
000042  bf00              NOP                            ;1262
                  |L2.68|
000044  bf00              NOP                            ;1244
000046  4620              MOV      r0,r4                 ;1265
000048  e7df              B        |L2.10|
;;;1267   
                          ENDP


                          AREA ||i.dirty_records_stat||, CODE, READONLY, ALIGN=2

                  dirty_records_stat PROC
;;;522    // Retrieve basic statistics about dirty records on a page.
;;;523    static void dirty_records_stat(uint16_t         page,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;524                                   uint16_t * const p_dirty_records,
;;;525                                   uint16_t * const p_word_count)
;;;526    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;527        fds_header_t const * p_header;
;;;528        uint32_t     const * p_rec;
;;;529    
;;;530        p_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
00000a  4814              LDR      r0,|L3.92|
00000c  eb001006          ADD      r0,r0,r6,LSL #4
000010  6840              LDR      r0,[r0,#4]
000012  f1000508          ADD      r5,r0,#8
;;;531    
;;;532        while ((p_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE)) &&
000016  e012              B        |L3.62|
                  |L3.24|
;;;533               (*p_rec != FDS_ERASED_WORD))
;;;534        {
;;;535            p_header = (fds_header_t*)p_rec;
000018  462c              MOV      r4,r5
;;;536    
;;;537            if (!header_is_valid(p_header))
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       header_is_valid
000020  b948              CBNZ     r0,|L3.54|
;;;538            {
;;;539                (*p_dirty_records) += 1;
000022  8838              LDRH     r0,[r7,#0]
000024  1c40              ADDS     r0,r0,#1
000026  8038              STRH     r0,[r7,#0]
;;;540                (*p_word_count)    += FDS_HEADER_SIZE + p_header->length_words;
000028  f8b81000          LDRH     r1,[r8,#0]
00002c  8860              LDRH     r0,[r4,#2]
00002e  1cc0              ADDS     r0,r0,#3
000030  4408              ADD      r0,r0,r1
000032  f8a80000          STRH     r0,[r8,#0]
                  |L3.54|
;;;541            }
;;;542    
;;;543            p_rec += (FDS_HEADER_SIZE + (p_header->length_words));
000036  8860              LDRH     r0,[r4,#2]
000038  1cc0              ADDS     r0,r0,#3
00003a  eb050580          ADD      r5,r5,r0,LSL #2
                  |L3.62|
00003e  4807              LDR      r0,|L3.92|
000040  eb001006          ADD      r0,r0,r6,LSL #4       ;532
000044  6840              LDR      r0,[r0,#4]            ;532
000046  f5005080          ADD      r0,r0,#0x1000         ;532
00004a  42a8              CMP      r0,r5                 ;532
00004c  d903              BLS      |L3.86|
00004e  6828              LDR      r0,[r5,#0]            ;533
000050  1c40              ADDS     r0,r0,#1              ;533
000052  2800              CMP      r0,#0                 ;533
000054  d1e0              BNE      |L3.24|
                  |L3.86|
;;;544        }
;;;545    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;546    
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      m_pages

                          AREA ||i.event_prepare||, CODE, READONLY, ALIGN=1

                  event_prepare PROC
;;;126    
;;;127    static void event_prepare(fds_op_t const * const p_op, fds_evt_t * const p_evt)
000000  7802              LDRB     r2,[r0,#0]
;;;128    {
;;;129        switch (p_op->op_code)
000002  2a07              CMP      r2,#7
000004  d238              BCS      |L4.120|
000006  e8dff002          TBB      [pc,r2]
00000a  3704              DCB      0x37,0x04
00000c  0712222b          DCB      0x07,0x12,0x22,0x2b
000010  3400              DCB      0x34,0x00
;;;130        {
;;;131            case FDS_OP_INIT:
;;;132                p_evt->id = FDS_EVT_INIT;
000012  2200              MOVS     r2,#0
000014  700a              STRB     r2,[r1,#0]
;;;133                break;
000016  e030              B        |L4.122|
;;;134    
;;;135            case FDS_OP_WRITE:
;;;136                p_evt->id                      = FDS_EVT_WRITE;
000018  2201              MOVS     r2,#1
00001a  700a              STRB     r2,[r1,#0]
;;;137                p_evt->write.file_id           = p_op->write.header.file_id;
00001c  8903              LDRH     r3,[r0,#8]
00001e  818b              STRH     r3,[r1,#0xc]
;;;138                p_evt->write.record_key        = p_op->write.header.record_key;
000020  8883              LDRH     r3,[r0,#4]
000022  81cb              STRH     r3,[r1,#0xe]
;;;139                p_evt->write.record_id         = p_op->write.header.record_id;
000024  68c2              LDR      r2,[r0,#0xc]
000026  608a              STR      r2,[r1,#8]
;;;140                p_evt->write.is_record_updated = 0;
000028  2300              MOVS     r3,#0
00002a  740b              STRB     r3,[r1,#0x10]
;;;141                break;
00002c  e025              B        |L4.122|
;;;142    
;;;143            case FDS_OP_UPDATE:
;;;144                p_evt->id                      = FDS_EVT_UPDATE;
00002e  2202              MOVS     r2,#2
000030  700a              STRB     r2,[r1,#0]
;;;145                p_evt->write.file_id           = p_op->write.header.file_id;
000032  8903              LDRH     r3,[r0,#8]
000034  818b              STRH     r3,[r1,#0xc]
;;;146                p_evt->write.record_key        = p_op->write.header.record_key;
000036  8883              LDRH     r3,[r0,#4]
000038  81cb              STRH     r3,[r1,#0xe]
;;;147                p_evt->write.record_id         = p_op->write.header.record_id;
00003a  68c2              LDR      r2,[r0,#0xc]
00003c  608a              STR      r2,[r1,#8]
;;;148                p_evt->write.is_record_updated = (p_op->write.step == FDS_OP_WRITE_DONE);
00003e  7d82              LDRB     r2,[r0,#0x16]
000040  2a06              CMP      r2,#6
000042  d101              BNE      |L4.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L4.74|
                  |L4.72|
000048  2300              MOVS     r3,#0
                  |L4.74|
00004a  740b              STRB     r3,[r1,#0x10]
;;;149                break;
00004c  e015              B        |L4.122|
;;;150    
;;;151            case FDS_OP_DEL_RECORD:
;;;152                p_evt->id             = FDS_EVT_DEL_RECORD;
00004e  2203              MOVS     r2,#3
000050  700a              STRB     r2,[r1,#0]
;;;153                p_evt->del.file_id    = p_op->del.file_id;
000052  88c3              LDRH     r3,[r0,#6]
000054  818b              STRH     r3,[r1,#0xc]
;;;154                p_evt->del.record_key = p_op->del.record_key;
000056  8903              LDRH     r3,[r0,#8]
000058  81cb              STRH     r3,[r1,#0xe]
;;;155                p_evt->del.record_id  = p_op->del.record_to_delete;
00005a  68c2              LDR      r2,[r0,#0xc]
00005c  608a              STR      r2,[r1,#8]
;;;156                break;
00005e  e00c              B        |L4.122|
;;;157    
;;;158            case FDS_OP_DEL_FILE:
;;;159                p_evt->id             = FDS_EVT_DEL_FILE;
000060  2204              MOVS     r2,#4
000062  700a              STRB     r2,[r1,#0]
;;;160                p_evt->del.file_id    = p_op->del.file_id;
000064  88c3              LDRH     r3,[r0,#6]
000066  818b              STRH     r3,[r1,#0xc]
;;;161                p_evt->del.record_key = FDS_RECORD_KEY_DIRTY;
000068  2300              MOVS     r3,#0
00006a  81cb              STRH     r3,[r1,#0xe]
;;;162                p_evt->del.record_id  = 0;
00006c  2200              MOVS     r2,#0
00006e  608a              STR      r2,[r1,#8]
;;;163                break;
000070  e003              B        |L4.122|
;;;164    
;;;165            case FDS_OP_GC:
;;;166                p_evt->id = FDS_EVT_GC;
000072  2205              MOVS     r2,#5
000074  700a              STRB     r2,[r1,#0]
;;;167                break;
000076  e000              B        |L4.122|
                  |L4.120|
;;;168    
;;;169            default:
;;;170                // Should not happen.
;;;171                break;
000078  bf00              NOP      
                  |L4.122|
00007a  bf00              NOP                            ;133
;;;172        }
;;;173    }
00007c  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.event_send||, CODE, READONLY, ALIGN=2

                  event_send PROC
;;;114    
;;;115    static void event_send(fds_evt_t const * const p_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;116    {
000002  4605              MOV      r5,r0
;;;117        for (uint32_t user = 0; user < FDS_MAX_USERS; user++)
000004  2400              MOVS     r4,#0
000006  e009              B        |L5.28|
                  |L5.8|
;;;118        {
;;;119            if (m_cb_table[user] != NULL)
000008  4806              LDR      r0,|L5.36|
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  b120              CBZ      r0,|L5.26|
;;;120            {
;;;121                m_cb_table[user](p_evt);
000010  4804              LDR      r0,|L5.36|
000012  f8501024          LDR      r1,[r0,r4,LSL #2]
000016  4628              MOV      r0,r5
000018  4788              BLX      r1
                  |L5.26|
00001a  1c64              ADDS     r4,r4,#1              ;117
                  |L5.28|
00001c  2c04              CMP      r4,#4                 ;117
00001e  d3f3              BCC      |L5.8|
;;;122            }
;;;123        }
;;;124    }
000020  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      m_cb_table

                          AREA ||i.fds_descriptor_from_rec_id||, CODE, READONLY, ALIGN=1

                  fds_descriptor_from_rec_id PROC
;;;1945   
;;;1946   ret_code_t fds_descriptor_from_rec_id(fds_record_desc_t * const p_desc,
000000  4602              MOV      r2,r0
;;;1947                                         uint32_t                  record_id)
;;;1948   {
;;;1949       if (p_desc == NULL)
000002  b90a              CBNZ     r2,|L6.8|
;;;1950       {
;;;1951           return FDS_ERR_NULL_ARG;
000004  2005              MOVS     r0,#5
                  |L6.6|
;;;1952       }
;;;1953   
;;;1954       // Zero the descriptor and set the record_id field.
;;;1955       memset(p_desc, 0x00, sizeof(fds_record_desc_t));
;;;1956       p_desc->record_id = record_id;
;;;1957   
;;;1958       return FDS_SUCCESS;
;;;1959   }
000006  4770              BX       lr
                  |L6.8|
000008  2000              MOVS     r0,#0                 ;1955
00000a  6010              STR      r0,[r2,#0]            ;1955
00000c  6050              STR      r0,[r2,#4]            ;1955
00000e  6090              STR      r0,[r2,#8]            ;1955
000010  6011              STR      r1,[r2,#0]            ;1956
000012  bf00              NOP                            ;1958
000014  e7f7              B        |L6.6|
;;;1960   
                          ENDP


                          AREA ||i.fds_file_delete||, CODE, READONLY, ALIGN=1

                  fds_file_delete PROC
;;;1858   
;;;1859   ret_code_t fds_file_delete(uint16_t file_id)
000000  b510              PUSH     {r4,lr}
;;;1860   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1861       fds_op_t op;
;;;1862   
;;;1863       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b910              CBNZ     r0,|L7.20|
;;;1864       {
;;;1865           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L7.16|
;;;1866       }
;;;1867   
;;;1868       if (file_id == FDS_FILE_ID_INVALID)
;;;1869       {
;;;1870           return FDS_ERR_INVALID_ARG;
;;;1871       }
;;;1872   
;;;1873       op.op_code      = FDS_OP_DEL_FILE;
;;;1874       op.del.step     = FDS_OP_DEL_FILE_FLAG_DIRTY;
;;;1875       op.del.file_id  = file_id;
;;;1876   
;;;1877       if (op_enqueue(&op))
;;;1878       {
;;;1879           queue_start();
;;;1880           return FDS_SUCCESS;
;;;1881       }
;;;1882   
;;;1883       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1884   }
000010  b008              ADD      sp,sp,#0x20
000012  bd10              POP      {r4,pc}
                  |L7.20|
000014  f64f70ff          MOV      r0,#0xffff            ;1868
000018  4284              CMP      r4,r0                 ;1868
00001a  d101              BNE      |L7.32|
00001c  2004              MOVS     r0,#4                 ;1870
00001e  e7f7              B        |L7.16|
                  |L7.32|
000020  2005              MOVS     r0,#5                 ;1873
000022  f88d0004          STRB     r0,[sp,#4]            ;1873
000026  2001              MOVS     r0,#1                 ;1874
000028  f88d0008          STRB     r0,[sp,#8]            ;1874
00002c  f8ad400a          STRH     r4,[sp,#0xa]          ;1875
000030  a801              ADD      r0,sp,#4              ;1877
000032  f7fffffe          BL       op_enqueue
000036  b118              CBZ      r0,|L7.64|
000038  f7fffffe          BL       queue_start
00003c  2000              MOVS     r0,#0                 ;1880
00003e  e7e7              B        |L7.16|
                  |L7.64|
000040  2008              MOVS     r0,#8                 ;1883
000042  e7e5              B        |L7.16|
;;;1885   
                          ENDP


                          AREA ||i.fds_gc||, CODE, READONLY, ALIGN=2

                  fds_gc PROC
;;;1886   
;;;1887   ret_code_t fds_gc(void)
000000  b500              PUSH     {lr}
;;;1888   {
000002  b087              SUB      sp,sp,#0x1c
;;;1889       fds_op_t op;
;;;1890   
;;;1891       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  b910              CBNZ     r0,|L8.18|
;;;1892       {
;;;1893           return FDS_ERR_NOT_INITIALIZED;
00000c  2002              MOVS     r0,#2
                  |L8.14|
;;;1894       }
;;;1895   
;;;1896       op.op_code = FDS_OP_GC;
;;;1897   
;;;1898       if (op_enqueue(&op))
;;;1899       {
;;;1900           if (m_gc.state != GC_BEGIN)
;;;1901           {
;;;1902               // Resume GC by retrying the last step.
;;;1903               m_gc.resume = true;
;;;1904           }
;;;1905   
;;;1906           queue_start();
;;;1907           return FDS_SUCCESS;
;;;1908       }
;;;1909   
;;;1910       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1911   }
00000e  b007              ADD      sp,sp,#0x1c
000010  bd00              POP      {pc}
                  |L8.18|
000012  2006              MOVS     r0,#6                 ;1896
000014  f88d0000          STRB     r0,[sp,#0]            ;1896
000018  4668              MOV      r0,sp                 ;1898
00001a  f7fffffe          BL       op_enqueue
00001e  b148              CBZ      r0,|L8.52|
000020  4805              LDR      r0,|L8.56|
000022  7800              LDRB     r0,[r0,#0]            ;1900  ; m_gc
000024  b110              CBZ      r0,|L8.44|
000026  2001              MOVS     r0,#1                 ;1903
000028  4903              LDR      r1,|L8.56|
00002a  7308              STRB     r0,[r1,#0xc]          ;1903
                  |L8.44|
00002c  f7fffffe          BL       queue_start
000030  2000              MOVS     r0,#0                 ;1907
000032  e7ec              B        |L8.14|
                  |L8.52|
000034  2008              MOVS     r0,#8                 ;1910
000036  e7ea              B        |L8.14|
;;;1912   
                          ENDP

                  |L8.56|
                          DCD      m_gc

                          AREA ||i.fds_init||, CODE, READONLY, ALIGN=2

                  fds_init PROC
;;;1553   
;;;1554   ret_code_t fds_init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1555   {
000002  b08d              SUB      sp,sp,#0x34
;;;1556       ret_code_t ret;
;;;1557       fds_evt_t const evt_success =
000004  2114              MOVS     r1,#0x14
000006  a808              ADD      r0,sp,#0x20
000008  f7fffffe          BL       __aeabi_memclr4
;;;1558       {
;;;1559           .id     = FDS_EVT_INIT,
;;;1560           .result = FDS_SUCCESS
;;;1561       };
;;;1562   
;;;1563       // No initialization is necessary. Notify the application immediately.
;;;1564       if (flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b128              CBZ      r0,|L9.32|
;;;1565       {
;;;1566           event_send(&evt_success);
000014  a808              ADD      r0,sp,#0x20
000016  f7fffffe          BL       event_send
;;;1567           return FDS_SUCCESS;
00001a  2000              MOVS     r0,#0
                  |L9.28|
;;;1568       }
;;;1569   
;;;1570       if (flag_is_set(FDS_FLAG_INITIALIZING))
;;;1571       {
;;;1572           return FDS_SUCCESS;
;;;1573       }
;;;1574   
;;;1575       flag_set(FDS_FLAG_INITIALIZING);
;;;1576   
;;;1577       flash_bounds_set();
;;;1578   
;;;1579   #if   (FDS_BACKEND == NRF_FSTORAGE_SD)
;;;1580       ret = nrf_fstorage_init(&m_fs, &nrf_fstorage_sd, NULL);
;;;1581   #elif (FDS_BACKEND == NRF_FSTORAGE_NVMC)
;;;1582       ret = nrf_fstorage_init(&m_fs, &nrf_fstorage_nvmc, NULL);
;;;1583   #else
;;;1584       #error Invalid FDS_BACKEND.
;;;1585   #endif
;;;1586   
;;;1587       if (ret != NRF_SUCCESS)
;;;1588       {
;;;1589           return ret;
;;;1590       }
;;;1591   
;;;1592       // Initialize the page structure (m_pages), and determine which
;;;1593       // initialization steps are required given the current state of the filesystem.
;;;1594       fds_op_t op;
;;;1595       op.op_code = FDS_OP_INIT;
;;;1596   
;;;1597       fds_init_opts_t init_opts = pages_init();
;;;1598   
;;;1599       switch (init_opts)
;;;1600       {
;;;1601           case NO_PAGES:
;;;1602           case NO_SWAP:
;;;1603               return FDS_ERR_NO_PAGES;
;;;1604   
;;;1605           case ALREADY_INSTALLED:
;;;1606               // No initialization is necessary. Notify the application immediately.
;;;1607               flag_set(FDS_FLAG_INITIALIZED);
;;;1608               flag_clear(FDS_FLAG_INITIALIZING);
;;;1609               event_send(&evt_success);
;;;1610               return FDS_SUCCESS;
;;;1611   
;;;1612           case FRESH_INSTALL:
;;;1613           case TAG_SWAP:
;;;1614               op.init.step = FDS_OP_INIT_TAG_SWAP;
;;;1615               break;
;;;1616   
;;;1617           case PROMOTE_SWAP:
;;;1618           case PROMOTE_SWAP_INST:
;;;1619               op.init.step = FDS_OP_INIT_PROMOTE_SWAP;
;;;1620               break;
;;;1621   
;;;1622           case DISCARD_SWAP:
;;;1623               op.init.step = FDS_OP_INIT_ERASE_SWAP;
;;;1624               break;
;;;1625   
;;;1626           case TAG_DATA:
;;;1627           case TAG_DATA_INST:
;;;1628               op.init.step = FDS_OP_INIT_TAG_DATA;
;;;1629               break;
;;;1630   
;;;1631           default:
;;;1632               // Should not happen.
;;;1633               break;
;;;1634       }
;;;1635   
;;;1636       // This cannot fail since it will be the first operation in the queue.
;;;1637       (void)op_enqueue(&op);
;;;1638   
;;;1639       queue_start();
;;;1640   
;;;1641       return FDS_SUCCESS;
;;;1642   }
00001c  b00d              ADD      sp,sp,#0x34
00001e  bd30              POP      {r4,r5,pc}
                  |L9.32|
000020  2001              MOVS     r0,#1                 ;1570
000022  f7fffffe          BL       flag_is_set
000026  b108              CBZ      r0,|L9.44|
000028  2000              MOVS     r0,#0                 ;1572
00002a  e7f7              B        |L9.28|
                  |L9.44|
00002c  2001              MOVS     r0,#1                 ;1575
00002e  f7fffffe          BL       flag_set
000032  f7fffffe          BL       flash_bounds_set
000036  2200              MOVS     r2,#0                 ;1580
000038  4920              LDR      r1,|L9.188|
00003a  4821              LDR      r0,|L9.192|
00003c  f7fffffe          BL       nrf_fstorage_init
000040  4605              MOV      r5,r0                 ;1580
000042  b10d              CBZ      r5,|L9.72|
000044  4628              MOV      r0,r5                 ;1589
000046  e7e9              B        |L9.28|
                  |L9.72|
000048  2001              MOVS     r0,#1                 ;1595
00004a  f88d0004          STRB     r0,[sp,#4]            ;1595
00004e  f7fffffe          BL       pages_init
000052  4604              MOV      r4,r0                 ;1597
000054  2c0c              CMP      r4,#0xc               ;1599
000056  d228              BCS      |L9.170|
000058  e8dff004          TBB      [pc,r4]               ;1599
00005c  06140715          DCB      0x06,0x14,0x07,0x15
000060  27220923          DCB      0x27,0x22,0x09,0x23
000064  27191e1a          DCB      0x27,0x19,0x1e,0x1a
000068  bf00              NOP                            ;1602
00006a  200b              MOVS     r0,#0xb               ;1603
00006c  e7d6              B        |L9.28|
00006e  2002              MOVS     r0,#2                 ;1607
000070  f7fffffe          BL       flag_set
000074  2001              MOVS     r0,#1                 ;1608
000076  f7fffffe          BL       flag_clear
00007a  a808              ADD      r0,sp,#0x20           ;1609
00007c  f7fffffe          BL       event_send
000080  2000              MOVS     r0,#0                 ;1610
000082  e7cb              B        |L9.28|
000084  bf00              NOP                            ;1613
000086  2000              MOVS     r0,#0                 ;1614
000088  f88d0008          STRB     r0,[sp,#8]            ;1614
00008c  e00e              B        |L9.172|
00008e  bf00              NOP                            ;1618
000090  2003              MOVS     r0,#3                 ;1619
000092  f88d0008          STRB     r0,[sp,#8]            ;1619
000096  e009              B        |L9.172|
000098  2002              MOVS     r0,#2                 ;1623
00009a  f88d0008          STRB     r0,[sp,#8]            ;1623
00009e  e005              B        |L9.172|
0000a0  bf00              NOP                            ;1627
0000a2  2001              MOVS     r0,#1                 ;1628
0000a4  f88d0008          STRB     r0,[sp,#8]            ;1628
0000a8  e000              B        |L9.172|
                  |L9.170|
0000aa  bf00              NOP                            ;1633
                  |L9.172|
0000ac  bf00              NOP                            ;1615
0000ae  a801              ADD      r0,sp,#4              ;1637
0000b0  f7fffffe          BL       op_enqueue
0000b4  f7fffffe          BL       queue_start
0000b8  2000              MOVS     r0,#0                 ;1641
0000ba  e7af              B        |L9.28|
;;;1643   
                          ENDP

                  |L9.188|
                          DCD      nrf_fstorage_sd
                  |L9.192|
                          DCD      m_fs

                          AREA ||i.fds_record_close||, CODE, READONLY, ALIGN=2

                  fds_record_close PROC
;;;1688   
;;;1689   ret_code_t fds_record_close(fds_record_desc_t * const p_desc)
000000  b538              PUSH     {r3-r5,lr}
;;;1690   {
000002  4604              MOV      r4,r0
;;;1691       ret_code_t ret;
;;;1692       uint16_t   page;
;;;1693   
;;;1694       if (p_desc == NULL)
000004  b90c              CBNZ     r4,|L10.10|
;;;1695       {
;;;1696           return FDS_ERR_NULL_ARG;
000006  2005              MOVS     r0,#5
                  |L10.8|
;;;1697       }
;;;1698   
;;;1699       if (record_find_by_desc((fds_record_desc_t*)p_desc, &page))
;;;1700       {
;;;1701           CRITICAL_SECTION_ENTER();
;;;1702           if ((m_pages[page].records_open > 0) && (p_desc->record_is_open))
;;;1703           {
;;;1704   
;;;1705               m_pages[page].records_open--;
;;;1706               p_desc->record_is_open = false;
;;;1707   
;;;1708               ret = FDS_SUCCESS;
;;;1709           }
;;;1710           else
;;;1711           {
;;;1712               ret = FDS_ERR_NO_OPEN_RECORDS;
;;;1713           }
;;;1714           CRITICAL_SECTION_EXIT();
;;;1715       }
;;;1716       else
;;;1717       {
;;;1718           ret = FDS_ERR_NOT_FOUND;
;;;1719       }
;;;1720   
;;;1721       return ret;
;;;1722   }
000008  bd38              POP      {r3-r5,pc}
                  |L10.10|
00000a  4669              MOV      r1,sp                 ;1699
00000c  4620              MOV      r0,r4                 ;1699
00000e  f7fffffe          BL       record_find_by_desc
000012  b1e0              CBZ      r0,|L10.78|
000014  480f              LDR      r0,|L10.84|
000016  f8bd1000          LDRH     r1,[sp,#0]            ;1702
00001a  eb001001          ADD      r0,r0,r1,LSL #4       ;1702
00001e  8980              LDRH     r0,[r0,#0xc]          ;1702
000020  2800              CMP      r0,#0                 ;1702
000022  dd12              BLE      |L10.74|
000024  7aa0              LDRB     r0,[r4,#0xa]          ;1702
000026  b180              CBZ      r0,|L10.74|
000028  480a              LDR      r0,|L10.84|
00002a  f8bd1000          LDRH     r1,[sp,#0]            ;1705
00002e  eb001001          ADD      r0,r0,r1,LSL #4       ;1705
000032  8980              LDRH     r0,[r0,#0xc]          ;1705
000034  1e40              SUBS     r0,r0,#1              ;1705
000036  4907              LDR      r1,|L10.84|
000038  f8bd2000          LDRH     r2,[sp,#0]            ;1705
00003c  eb011102          ADD      r1,r1,r2,LSL #4       ;1705
000040  8188              STRH     r0,[r1,#0xc]          ;1705
000042  2000              MOVS     r0,#0                 ;1706
000044  72a0              STRB     r0,[r4,#0xa]          ;1706
000046  2500              MOVS     r5,#0                 ;1708
000048  e002              B        |L10.80|
                  |L10.74|
00004a  2506              MOVS     r5,#6                 ;1712
00004c  e000              B        |L10.80|
                  |L10.78|
00004e  250a              MOVS     r5,#0xa               ;1718
                  |L10.80|
000050  4628              MOV      r0,r5                 ;1721
000052  e7d9              B        |L10.8|
;;;1723   
                          ENDP

                  |L10.84|
                          DCD      m_pages

                          AREA ||i.fds_record_delete||, CODE, READONLY, ALIGN=1

                  fds_record_delete PROC
;;;1830   
;;;1831   ret_code_t fds_record_delete(fds_record_desc_t * const p_desc)
000000  b510              PUSH     {r4,lr}
;;;1832   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1833       fds_op_t op;
;;;1834   
;;;1835       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b910              CBNZ     r0,|L11.20|
;;;1836       {
;;;1837           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L11.16|
;;;1838       }
;;;1839   
;;;1840       if (p_desc == NULL)
;;;1841       {
;;;1842           return FDS_ERR_NULL_ARG;
;;;1843       }
;;;1844   
;;;1845       op.op_code              = FDS_OP_DEL_RECORD;
;;;1846       op.del.step             = FDS_OP_DEL_RECORD_FLAG_DIRTY;
;;;1847       op.del.record_to_delete = p_desc->record_id;
;;;1848   
;;;1849       if (op_enqueue(&op))
;;;1850       {
;;;1851           queue_start();
;;;1852           return FDS_SUCCESS;
;;;1853       }
;;;1854   
;;;1855      return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1856   }
000010  b008              ADD      sp,sp,#0x20
000012  bd10              POP      {r4,pc}
                  |L11.20|
000014  b90c              CBNZ     r4,|L11.26|
000016  2005              MOVS     r0,#5                 ;1842
000018  e7fa              B        |L11.16|
                  |L11.26|
00001a  2004              MOVS     r0,#4                 ;1845
00001c  f88d0004          STRB     r0,[sp,#4]            ;1845
000020  2000              MOVS     r0,#0                 ;1846
000022  f88d0008          STRB     r0,[sp,#8]            ;1846
000026  6821              LDR      r1,[r4,#0]            ;1847
000028  9104              STR      r1,[sp,#0x10]         ;1847
00002a  a801              ADD      r0,sp,#4              ;1849
00002c  f7fffffe          BL       op_enqueue
000030  b118              CBZ      r0,|L11.58|
000032  f7fffffe          BL       queue_start
000036  2000              MOVS     r0,#0                 ;1852
000038  e7ea              B        |L11.16|
                  |L11.58|
00003a  2008              MOVS     r0,#8                 ;1855
00003c  e7e8              B        |L11.16|
;;;1857   
                          ENDP


                          AREA ||i.fds_record_find||, CODE, READONLY, ALIGN=1

                  fds_record_find PROC
;;;1920   
;;;1921   ret_code_t fds_record_find(uint16_t                  file_id,
000000  b57f              PUSH     {r0-r6,lr}
;;;1922                              uint16_t                  record_key,
;;;1923                              fds_record_desc_t * const p_desc,
;;;1924                              fds_find_token_t  * const p_token)
;;;1925   {
000002  4614              MOV      r4,r2
000004  461d              MOV      r5,r3
;;;1926       return record_find(&file_id, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  a901              ADD      r1,sp,#4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;1927   }
000012  b004              ADD      sp,sp,#0x10
000014  bd70              POP      {r4-r6,pc}
;;;1928   
                          ENDP


                          AREA ||i.fds_record_find_by_key||, CODE, READONLY, ALIGN=1

                  fds_record_find_by_key PROC
;;;1929   
;;;1930   ret_code_t fds_record_find_by_key(uint16_t                  record_key,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1931                                     fds_record_desc_t * const p_desc,
;;;1932                                     fds_find_token_t  * const p_token)
;;;1933   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1934       return record_find(NULL, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       record_find
;;;1935   }
000012  bd3e              POP      {r1-r5,pc}
;;;1936   
                          ENDP


                          AREA ||i.fds_record_find_in_file||, CODE, READONLY, ALIGN=1

                  fds_record_find_in_file PROC
;;;1937   
;;;1938   ret_code_t fds_record_find_in_file(uint16_t                  file_id,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1939                                      fds_record_desc_t * const p_desc,
;;;1940                                      fds_find_token_t  * const p_token)
;;;1941   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1942       return record_find(&file_id, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;1943   }
000012  bd3e              POP      {r1-r5,pc}
;;;1944   
                          ENDP


                          AREA ||i.fds_record_id_from_desc||, CODE, READONLY, ALIGN=1

                  fds_record_id_from_desc PROC
;;;1961   
;;;1962   ret_code_t fds_record_id_from_desc(fds_record_desc_t const * const p_desc,
000000  4602              MOV      r2,r0
;;;1963                                      uint32_t                * const p_record_id)
;;;1964   {
;;;1965       if ((p_desc == NULL) || (p_record_id == NULL))
000002  b102              CBZ      r2,|L15.6|
000004  b909              CBNZ     r1,|L15.10|
                  |L15.6|
;;;1966       {
;;;1967           return FDS_ERR_NULL_ARG;
000006  2005              MOVS     r0,#5
                  |L15.8|
;;;1968       }
;;;1969   
;;;1970       *p_record_id = p_desc->record_id;
;;;1971   
;;;1972       return FDS_SUCCESS;
;;;1973   }
000008  4770              BX       lr
                  |L15.10|
00000a  6810              LDR      r0,[r2,#0]            ;1970
00000c  6008              STR      r0,[r1,#0]            ;1970
00000e  2000              MOVS     r0,#0                 ;1972
000010  e7fa              B        |L15.8|
;;;1974   
                          ENDP


                          AREA ||i.fds_record_iterate||, CODE, READONLY, ALIGN=1

                  fds_record_iterate PROC
;;;1913   
;;;1914   ret_code_t fds_record_iterate(fds_record_desc_t * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1915                                 fds_find_token_t  * const p_token)
;;;1916   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1917       return record_find(NULL, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       record_find
;;;1918   }
000012  bd70              POP      {r4-r6,pc}
;;;1919   
                          ENDP


                          AREA ||i.fds_record_open||, CODE, READONLY, ALIGN=2

                  fds_record_open PROC
;;;1644   
;;;1645   ret_code_t fds_record_open(fds_record_desc_t  * const p_desc,
000000  b538              PUSH     {r3-r5,lr}
;;;1646                              fds_flash_record_t * const p_flash_rec)
;;;1647   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1648       uint16_t page;
;;;1649   
;;;1650       if ((p_desc == NULL) || (p_flash_rec == NULL))
000006  b104              CBZ      r4,|L17.10|
000008  b90d              CBNZ     r5,|L17.14|
                  |L17.10|
;;;1651       {
;;;1652           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L17.12|
;;;1653       }
;;;1654   
;;;1655       // Find the record if necessary.
;;;1656       if (record_find_by_desc(p_desc, &page))
;;;1657       {
;;;1658           fds_header_t const * const p_header = (fds_header_t*)p_desc->p_record;
;;;1659   
;;;1660   #if (FDS_CRC_CHECK_ON_READ)
;;;1661           if (!crc_verify_success(p_header->crc16,
;;;1662                                   p_header->length_words,
;;;1663                                   p_desc->p_record))
;;;1664           {
;;;1665               return FDS_ERR_CRC_CHECK_FAILED;
;;;1666           }
;;;1667   #endif
;;;1668   
;;;1669           CRITICAL_SECTION_ENTER();
;;;1670           m_pages[page].records_open++;
;;;1671           CRITICAL_SECTION_EXIT();
;;;1672   
;;;1673           // Initialize p_flash_rec.
;;;1674           p_flash_rec->p_header = p_header;
;;;1675           p_flash_rec->p_data   = (p_desc->p_record + FDS_HEADER_SIZE);
;;;1676   
;;;1677           // Set the record as open in the descriptor.
;;;1678           p_desc->record_is_open = true;
;;;1679   
;;;1680           return FDS_SUCCESS;
;;;1681       }
;;;1682   
;;;1683       // The record could not be found.
;;;1684       // It either never existed or it has been deleted.
;;;1685       return FDS_ERR_NOT_FOUND;
;;;1686   }
00000c  bd38              POP      {r3-r5,pc}
                  |L17.14|
00000e  4669              MOV      r1,sp                 ;1656
000010  4620              MOV      r0,r4                 ;1656
000012  f7fffffe          BL       record_find_by_desc
000016  b1a8              CBZ      r0,|L17.68|
000018  6861              LDR      r1,[r4,#4]            ;1658
00001a  480b              LDR      r0,|L17.72|
00001c  f8bd2000          LDRH     r2,[sp,#0]            ;1670
000020  eb001002          ADD      r0,r0,r2,LSL #4       ;1670
000024  8980              LDRH     r0,[r0,#0xc]          ;1670
000026  1c40              ADDS     r0,r0,#1              ;1670
000028  4a07              LDR      r2,|L17.72|
00002a  f8bd3000          LDRH     r3,[sp,#0]            ;1670
00002e  eb021203          ADD      r2,r2,r3,LSL #4       ;1670
000032  8190              STRH     r0,[r2,#0xc]          ;1670
000034  6029              STR      r1,[r5,#0]            ;1674
000036  6860              LDR      r0,[r4,#4]            ;1675
000038  300c              ADDS     r0,r0,#0xc            ;1675
00003a  6068              STR      r0,[r5,#4]            ;1675
00003c  2001              MOVS     r0,#1                 ;1678
00003e  72a0              STRB     r0,[r4,#0xa]          ;1678
000040  2000              MOVS     r0,#0                 ;1680
000042  e7e3              B        |L17.12|
                  |L17.68|
000044  200a              MOVS     r0,#0xa               ;1685
000046  e7e1              B        |L17.12|
;;;1687   
                          ENDP

                  |L17.72|
                          DCD      m_pages

                          AREA ||i.fds_record_update||, CODE, READONLY, ALIGN=1

                  fds_record_update PROC
;;;1817   
;;;1818   ret_code_t fds_record_update(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1819                                fds_record_t      const * const p_record)
;;;1820   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1821       // A NULL descriptor is not allowed when updating a record.
;;;1822       if (p_desc == NULL)
000006  b90c              CBNZ     r4,|L18.12|
;;;1823       {
;;;1824           return FDS_ERR_NULL_ARG;
000008  2005              MOVS     r0,#5
                  |L18.10|
;;;1825       }
;;;1826   
;;;1827       return write_enqueue(p_desc, p_record, NULL, FDS_OP_UPDATE);
;;;1828   }
00000a  bd70              POP      {r4-r6,pc}
                  |L18.12|
00000c  2303              MOVS     r3,#3                 ;1827
00000e  2200              MOVS     r2,#0                 ;1827
000010  4629              MOV      r1,r5                 ;1827
000012  4620              MOV      r0,r4                 ;1827
000014  f7fffffe          BL       write_enqueue
000018  e7f7              B        |L18.10|
;;;1829   
                          ENDP


                          AREA ||i.fds_record_write||, CODE, READONLY, ALIGN=1

                  fds_record_write PROC
;;;1796   
;;;1797   ret_code_t fds_record_write(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1798                               fds_record_t      const * const p_record)
;;;1799   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1800       return write_enqueue(p_desc, p_record, NULL, FDS_OP_WRITE);
000006  2302              MOVS     r3,#2
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_enqueue
;;;1801   }
000012  bd70              POP      {r4-r6,pc}
;;;1802   
                          ENDP


                          AREA ||i.fds_record_write_reserved||, CODE, READONLY, ALIGN=1

                  fds_record_write_reserved PROC
;;;1803   
;;;1804   ret_code_t fds_record_write_reserved(fds_record_desc_t         * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1805                                        fds_record_t        const * const p_record,
;;;1806                                        fds_reserve_token_t const * const p_tok)
;;;1807   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1808       // A NULL token is not allowed when writing to a reserved space.
;;;1809       if (p_tok == NULL)
000008  b90c              CBNZ     r4,|L20.14|
;;;1810       {
;;;1811           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L20.12|
;;;1812       }
;;;1813   
;;;1814       return write_enqueue(p_desc, p_record, p_tok, FDS_OP_WRITE);
;;;1815   }
00000c  bd70              POP      {r4-r6,pc}
                  |L20.14|
00000e  2302              MOVS     r3,#2                 ;1814
000010  4622              MOV      r2,r4                 ;1814
000012  4631              MOV      r1,r6                 ;1814
000014  4628              MOV      r0,r5                 ;1814
000016  f7fffffe          BL       write_enqueue
00001a  e7f7              B        |L20.12|
;;;1816   
                          ENDP


                          AREA ||i.fds_register||, CODE, READONLY, ALIGN=2

                  fds_register PROC
;;;1513   
;;;1514   ret_code_t fds_register(fds_cb_t cb)
000000  4601              MOV      r1,r0
;;;1515   {
;;;1516       ret_code_t ret;
;;;1517   
;;;1518       CRITICAL_SECTION_ENTER();
;;;1519       if (m_users == FDS_MAX_USERS)
000002  4a09              LDR      r2,|L21.40|
000004  7812              LDRB     r2,[r2,#0]  ; m_users
000006  2a04              CMP      r2,#4
000008  d101              BNE      |L21.14|
;;;1520       {
;;;1521           ret = FDS_ERR_USER_LIMIT_REACHED;
00000a  200c              MOVS     r0,#0xc
00000c  e00a              B        |L21.36|
                  |L21.14|
;;;1522       }
;;;1523       else
;;;1524       {
;;;1525           m_cb_table[m_users] = cb;
00000e  4a07              LDR      r2,|L21.44|
000010  4b05              LDR      r3,|L21.40|
000012  781b              LDRB     r3,[r3,#0]  ; m_users
000014  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1526           m_users++;
000018  4a03              LDR      r2,|L21.40|
00001a  7812              LDRB     r2,[r2,#0]  ; m_users
00001c  1c52              ADDS     r2,r2,#1
00001e  4b02              LDR      r3,|L21.40|
000020  701a              STRB     r2,[r3,#0]
;;;1527   
;;;1528           ret = FDS_SUCCESS;
000022  2000              MOVS     r0,#0
                  |L21.36|
;;;1529       }
;;;1530       CRITICAL_SECTION_EXIT();
;;;1531   
;;;1532       return ret;
;;;1533   }
000024  4770              BX       lr
;;;1534   
                          ENDP

000026  0000              DCW      0x0000
                  |L21.40|
                          DCD      m_users
                  |L21.44|
                          DCD      m_cb_table

                          AREA ||i.fds_reserve||, CODE, READONLY, ALIGN=1

                  fds_reserve PROC
;;;1724   
;;;1725   ret_code_t fds_reserve(fds_reserve_token_t * const p_tok, uint16_t length_words)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1726   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1727       ret_code_t ret;
;;;1728       uint16_t   page;
;;;1729   
;;;1730       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  b908              CBNZ     r0,|L22.18|
;;;1731       {
;;;1732           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L22.16|
;;;1733       }
;;;1734   
;;;1735       if (p_tok == NULL)
;;;1736       {
;;;1737           return FDS_ERR_NULL_ARG;
;;;1738       }
;;;1739   
;;;1740       ret = write_space_reserve(length_words, &page);
;;;1741   
;;;1742       if (ret == FDS_SUCCESS)
;;;1743       {
;;;1744           p_tok->page         = page;
;;;1745           p_tok->length_words = length_words;
;;;1746       }
;;;1747   
;;;1748       return ret;
;;;1749   }
000010  bdf8              POP      {r3-r7,pc}
                  |L22.18|
000012  b90c              CBNZ     r4,|L22.24|
000014  2005              MOVS     r0,#5                 ;1737
000016  e7fb              B        |L22.16|
                  |L22.24|
000018  4669              MOV      r1,sp                 ;1740
00001a  4628              MOV      r0,r5                 ;1740
00001c  f7fffffe          BL       write_space_reserve
000020  4606              MOV      r6,r0                 ;1740
000022  b91e              CBNZ     r6,|L22.44|
000024  f8bd0000          LDRH     r0,[sp,#0]            ;1744
000028  8020              STRH     r0,[r4,#0]            ;1744
00002a  8065              STRH     r5,[r4,#2]            ;1745
                  |L22.44|
00002c  4630              MOV      r0,r6                 ;1748
00002e  e7ef              B        |L22.16|
;;;1750   
                          ENDP


                          AREA ||i.fds_reserve_cancel||, CODE, READONLY, ALIGN=2

                  fds_reserve_cancel PROC
;;;1751   
;;;1752   ret_code_t fds_reserve_cancel(fds_reserve_token_t * const p_tok)
000000  b570              PUSH     {r4-r6,lr}
;;;1753   {
000002  4604              MOV      r4,r0
;;;1754       ret_code_t ret;
;;;1755   
;;;1756       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  b908              CBNZ     r0,|L23.16|
;;;1757       {
;;;1758           return FDS_ERR_NOT_INITIALIZED;
00000c  2002              MOVS     r0,#2
                  |L23.14|
;;;1759       }
;;;1760   
;;;1761       if (p_tok == NULL)
;;;1762       {
;;;1763           return FDS_ERR_NULL_ARG;
;;;1764       }
;;;1765   
;;;1766       if (p_tok->page > FDS_DATA_PAGES)
;;;1767       {
;;;1768           // The page does not exist. This shouldn't happen.
;;;1769           return FDS_ERR_INVALID_ARG;
;;;1770       }
;;;1771   
;;;1772       fds_page_t const * const p_page = &m_pages[p_tok->page];
;;;1773   
;;;1774       CRITICAL_SECTION_ENTER();
;;;1775       if (p_page->words_reserved - (FDS_HEADER_SIZE + p_tok->length_words) >= 0)
;;;1776       {
;;;1777           // Free reserved space.
;;;1778           write_space_free(p_tok->length_words, p_tok->page);
;;;1779   
;;;1780           // Clean the token.
;;;1781           p_tok->page         = 0;
;;;1782           p_tok->length_words = 0;
;;;1783           ret = FDS_SUCCESS;
;;;1784       }
;;;1785       else
;;;1786       {
;;;1787           // We are trying to cancel a reservation of more words than how many are
;;;1788           // currently reserved on the page. Clearly, this shouldn't happen.
;;;1789           ret = FDS_ERR_INVALID_ARG;
;;;1790       }
;;;1791       CRITICAL_SECTION_EXIT();
;;;1792   
;;;1793       return ret;
;;;1794   }
00000e  bd70              POP      {r4-r6,pc}
                  |L23.16|
000010  b90c              CBNZ     r4,|L23.22|
000012  2005              MOVS     r0,#5                 ;1763
000014  e7fb              B        |L23.14|
                  |L23.22|
000016  8820              LDRH     r0,[r4,#0]            ;1766
000018  2802              CMP      r0,#2                 ;1766
00001a  dd01              BLE      |L23.32|
00001c  2004              MOVS     r0,#4                 ;1769
00001e  e7f6              B        |L23.14|
                  |L23.32|
000020  8820              LDRH     r0,[r4,#0]            ;1772
000022  490a              LDR      r1,|L23.76|
000024  eb011600          ADD      r6,r1,r0,LSL #4       ;1772
000028  8971              LDRH     r1,[r6,#0xa]          ;1775
00002a  8860              LDRH     r0,[r4,#2]            ;1775
00002c  1cc0              ADDS     r0,r0,#3              ;1775
00002e  1a08              SUBS     r0,r1,r0              ;1775
000030  d408              BMI      |L23.68|
000032  8821              LDRH     r1,[r4,#0]            ;1778
000034  8860              LDRH     r0,[r4,#2]            ;1778
000036  f7fffffe          BL       write_space_free
00003a  2000              MOVS     r0,#0                 ;1781
00003c  8020              STRH     r0,[r4,#0]            ;1781
00003e  8060              STRH     r0,[r4,#2]            ;1782
000040  2500              MOVS     r5,#0                 ;1783
000042  e000              B        |L23.70|
                  |L23.68|
000044  2504              MOVS     r5,#4                 ;1789
                  |L23.70|
000046  4628              MOV      r0,r5                 ;1793
000048  e7e1              B        |L23.14|
;;;1795   
                          ENDP

00004a  0000              DCW      0x0000
                  |L23.76|
                          DCD      m_pages

                          AREA ||i.fds_stat||, CODE, READONLY, ALIGN=2

                  fds_stat PROC
;;;1975   
;;;1976   ret_code_t fds_stat(fds_stat_t * const p_stat)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1977   {
000004  4604              MOV      r4,r0
;;;1978       uint16_t const words_in_page = FDS_PAGE_SIZE;
000006  f44f6880          MOV      r8,#0x400
;;;1979       // The largest number of free contiguous words on any page.
;;;1980       uint16_t       contig_words  = 0;
00000a  2600              MOVS     r6,#0
;;;1981   
;;;1982       if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b910              CBNZ     r0,|L24.26|
;;;1983       {
;;;1984           return FDS_ERR_NOT_INITIALIZED;
000014  2002              MOVS     r0,#2
                  |L24.22|
;;;1985       }
;;;1986   
;;;1987       if (p_stat == NULL)
;;;1988       {
;;;1989           return FDS_ERR_NULL_ARG;
;;;1990       }
;;;1991   
;;;1992       memset(p_stat, 0x00, sizeof(fds_stat_t));
;;;1993   
;;;1994       for (uint16_t i = 0; i < FDS_DATA_PAGES; i++)
;;;1995       {
;;;1996           uint32_t const * p_record   = NULL;
;;;1997           uint16_t const   words_used = m_pages[i].write_offset + m_pages[i].words_reserved;
;;;1998   
;;;1999           p_stat->open_records   += m_pages[i].records_open;
;;;2000           p_stat->words_reserved += m_pages[i].words_reserved;
;;;2001           p_stat->words_used     += words_used;
;;;2002           contig_words           =  (words_in_page - words_used);
;;;2003   
;;;2004           if (contig_words > p_stat->largest_contig)
;;;2005           {
;;;2006               p_stat->largest_contig = contig_words;
;;;2007           }
;;;2008   
;;;2009           while (record_find_next(i, &p_record))
;;;2010           {
;;;2011               p_stat->valid_records++;
;;;2012           }
;;;2013   
;;;2014           dirty_records_stat(i, &p_stat->dirty_records, &p_stat->freeable_words);
;;;2015       }
;;;2016   
;;;2017       return FDS_SUCCESS;
;;;2018   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L24.26|
00001a  b90c              CBNZ     r4,|L24.32|
00001c  2005              MOVS     r0,#5                 ;1989
00001e  e7fa              B        |L24.22|
                  |L24.32|
000020  210e              MOVS     r1,#0xe               ;1992
000022  4620              MOV      r0,r4                 ;1992
000024  f7fffffe          BL       __aeabi_memclr
000028  2500              MOVS     r5,#0                 ;1994
00002a  e035              B        |L24.152|
                  |L24.44|
00002c  2000              MOVS     r0,#0                 ;1996
00002e  9000              STR      r0,[sp,#0]            ;1996
000030  481b              LDR      r0,|L24.160|
000032  eb001005          ADD      r0,r0,r5,LSL #4       ;1997
000036  8900              LDRH     r0,[r0,#8]            ;1997
000038  4919              LDR      r1,|L24.160|
00003a  eb011105          ADD      r1,r1,r5,LSL #4       ;1997
00003e  8949              LDRH     r1,[r1,#0xa]          ;1997
000040  4408              ADD      r0,r0,r1              ;1997
000042  b287              UXTH     r7,r0                 ;1997
000044  8820              LDRH     r0,[r4,#0]            ;1999
000046  4916              LDR      r1,|L24.160|
000048  eb011105          ADD      r1,r1,r5,LSL #4       ;1999
00004c  8989              LDRH     r1,[r1,#0xc]          ;1999
00004e  4408              ADD      r0,r0,r1              ;1999
000050  8020              STRH     r0,[r4,#0]            ;1999
000052  88e0              LDRH     r0,[r4,#6]            ;2000
000054  4912              LDR      r1,|L24.160|
000056  eb011105          ADD      r1,r1,r5,LSL #4       ;2000
00005a  8949              LDRH     r1,[r1,#0xa]          ;2000
00005c  4408              ADD      r0,r0,r1              ;2000
00005e  80e0              STRH     r0,[r4,#6]            ;2000
000060  8920              LDRH     r0,[r4,#8]            ;2001
000062  4438              ADD      r0,r0,r7              ;2001
000064  8120              STRH     r0,[r4,#8]            ;2001
000066  f5c76080          RSB      r0,r7,#0x400          ;2002
00006a  b286              UXTH     r6,r0                 ;2002
00006c  8960              LDRH     r0,[r4,#0xa]          ;2004
00006e  42b0              CMP      r0,r6                 ;2004
000070  da00              BGE      |L24.116|
000072  8166              STRH     r6,[r4,#0xa]          ;2006
                  |L24.116|
000074  e002              B        |L24.124|
                  |L24.118|
000076  8860              LDRH     r0,[r4,#2]            ;2011
000078  1c40              ADDS     r0,r0,#1              ;2011
00007a  8060              STRH     r0,[r4,#2]            ;2011
                  |L24.124|
00007c  4669              MOV      r1,sp                 ;2009
00007e  4628              MOV      r0,r5                 ;2009
000080  f7fffffe          BL       record_find_next
000084  2800              CMP      r0,#0                 ;2009
000086  d1f6              BNE      |L24.118|
000088  f104020c          ADD      r2,r4,#0xc            ;2014
00008c  1d21              ADDS     r1,r4,#4              ;2014
00008e  4628              MOV      r0,r5                 ;2014
000090  f7fffffe          BL       dirty_records_stat
000094  1c68              ADDS     r0,r5,#1              ;1994
000096  b285              UXTH     r5,r0                 ;1994
                  |L24.152|
000098  2d02              CMP      r5,#2                 ;1994
00009a  dbc7              BLT      |L24.44|
00009c  2000              MOVS     r0,#0                 ;2017
00009e  e7ba              B        |L24.22|
;;;2019   
                          ENDP

                  |L24.160|
                          DCD      m_pages

                          AREA ||i.file_find_and_delete||, CODE, READONLY, ALIGN=2

                  file_find_and_delete PROC
;;;778    // Finds a record within a file and flags it as dirty.
;;;779    static ret_code_t file_find_and_delete(fds_op_t * const p_op)
000000  b53e              PUSH     {r1-r5,lr}
;;;780    {
000002  4604              MOV      r4,r0
;;;781        ret_code_t        ret;
;;;782        fds_record_desc_t desc;
;;;783    
;;;784        // This token must persist across calls.
;;;785        static fds_find_token_t tok = {0};
;;;786    
;;;787        // Pass NULL to ignore the record key.
;;;788        ret = record_find(&p_op->del.file_id, NULL, &desc, &tok);
000004  4b0a              LDR      r3,|L25.48|
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  1da0              ADDS     r0,r4,#6
00000c  f7fffffe          BL       record_find
000010  4605              MOV      r5,r0
;;;789    
;;;790        if (ret == FDS_SUCCESS)
000012  b935              CBNZ     r5,|L25.34|
;;;791        {
;;;792             // A record was found: flag it as dirty.
;;;793            ret = record_header_flag_dirty((uint32_t*)desc.p_record, tok.page);
000014  4a06              LDR      r2,|L25.48|
000016  8891              LDRH     r1,[r2,#4]  ; tok
000018  9801              LDR      r0,[sp,#4]
00001a  f7fffffe          BL       record_header_flag_dirty
00001e  4605              MOV      r5,r0
000020  e003              B        |L25.42|
                  |L25.34|
;;;794        }
;;;795        else // FDS_ERR_NOT_FOUND
;;;796        {
;;;797            // No more records were found. Zero the token, so that it can be reused.
;;;798            memset(&tok, 0x00, sizeof(fds_find_token_t));
000022  4803              LDR      r0,|L25.48|
000024  2100              MOVS     r1,#0
000026  6001              STR      r1,[r0,#0]  ; tok
000028  6041              STR      r1,[r0,#4]  ; tok
                  |L25.42|
;;;799        }
;;;800    
;;;801        return ret;
00002a  4628              MOV      r0,r5
;;;802    }
00002c  bd3e              POP      {r1-r5,pc}
;;;803    
                          ENDP

00002e  0000              DCW      0x0000
                  |L25.48|
                          DCD      tok

                          AREA ||i.flag_clear||, CODE, READONLY, ALIGN=2

                  flag_clear PROC
;;;100    
;;;101    static void flag_clear(fds_flags_t flag)
000000  4902              LDR      r1,|L26.12|
;;;102    {
;;;103        CRITICAL_SECTION_ENTER();
;;;104        m_flags &= ~(flag);
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L26.12|
000008  7011              STRB     r1,[r2,#0]
;;;105        CRITICAL_SECTION_EXIT();
;;;106    }
00000a  4770              BX       lr
;;;107    
                          ENDP

                  |L26.12|
                          DCD      m_flags

                          AREA ||i.flag_is_set||, CODE, READONLY, ALIGN=2

                  flag_is_set PROC
;;;108    
;;;109    static bool flag_is_set(fds_flags_t flag)
000000  4601              MOV      r1,r0
;;;110    {
;;;111        return (m_flags & flag);
000002  4804              LDR      r0,|L27.20|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  4008              ANDS     r0,r0,r1
000008  b108              CBZ      r0,|L27.14|
00000a  2001              MOVS     r0,#1
                  |L27.12|
;;;112    }
00000c  4770              BX       lr
                  |L27.14|
00000e  2000              MOVS     r0,#0                 ;111
000010  e7fc              B        |L27.12|
;;;113    
                          ENDP

000012  0000              DCW      0x0000
                  |L27.20|
                          DCD      m_flags

                          AREA ||i.flag_set||, CODE, READONLY, ALIGN=2

                  flag_set PROC
;;;92     
;;;93     static void flag_set(fds_flags_t flag)
000000  4902              LDR      r1,|L28.12|
;;;94     {
;;;95         CRITICAL_SECTION_ENTER();
;;;96         m_flags |= flag;
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L28.12|
000008  7011              STRB     r1,[r2,#0]
;;;97         CRITICAL_SECTION_EXIT();
;;;98     }
00000a  4770              BX       lr
;;;99     
                          ENDP

                  |L28.12|
                          DCD      m_flags

                          AREA ||i.flash_bounds_set||, CODE, READONLY, ALIGN=2

                  flash_bounds_set PROC
;;;1545   
;;;1546   static void flash_bounds_set(void)
000000  b510              PUSH     {r4,lr}
;;;1547   {
;;;1548       uint32_t flash_size  = (FDS_PHY_PAGES * FDS_PHY_PAGE_SIZE * sizeof(uint32_t));
000002  f44f5440          MOV      r4,#0x3000
;;;1549       m_fs.end_addr   = flash_end_addr();
000006  f7fffffe          BL       flash_end_addr
00000a  4903              LDR      r1,|L29.24|
00000c  6108              STR      r0,[r1,#0x10]  ; m_fs
;;;1550       m_fs.start_addr = m_fs.end_addr - flash_size;
00000e  4608              MOV      r0,r1
000010  6900              LDR      r0,[r0,#0x10]  ; m_fs
000012  1b00              SUBS     r0,r0,r4
000014  60c8              STR      r0,[r1,#0xc]  ; m_fs
;;;1551   }
000016  bd10              POP      {r4,pc}
;;;1552   
                          ENDP

                  |L29.24|
                          DCD      m_fs

                          AREA ||i.flash_end_addr||, CODE, READONLY, ALIGN=1

                  flash_end_addr PROC
;;;1535   
;;;1536   static uint32_t flash_end_addr()
000000  f04f2010          MOV      r0,#0x10001000
;;;1537   {
;;;1538       uint32_t const bootloader_addr = NRF_UICR->NRFFW[0];
000004  6941              LDR      r1,[r0,#0x14]
;;;1539       uint32_t const page_sz         = NRF_FICR->CODEPAGESIZE;
000006  0400              LSLS     r0,r0,#16
000008  6902              LDR      r2,[r0,#0x10]
;;;1540       uint32_t const code_sz         = NRF_FICR->CODESIZE;
00000a  6943              LDR      r3,[r0,#0x14]
;;;1541   
;;;1542       return (bootloader_addr != 0xFFFFFFFF) ? bootloader_addr : (code_sz * page_sz);
00000c  1c48              ADDS     r0,r1,#1
00000e  b108              CBZ      r0,|L30.20|
000010  4608              MOV      r0,r1
                  |L30.18|
;;;1543   }
000012  4770              BX       lr
                  |L30.20|
000014  fb03f002          MUL      r0,r3,r2              ;1542
000018  e7fb              B        |L30.18|
;;;1544   
                          ENDP


                          AREA ||i.fs_event_handler||, CODE, READONLY, ALIGN=1

                  fs_event_handler PROC
;;;1396   
;;;1397   static void fs_event_handler(nrf_fstorage_evt_t * p_evt)
000000  b510              PUSH     {r4,lr}
;;;1398   {
000002  4604              MOV      r4,r0
;;;1399       queue_process(p_evt->result);
000004  6860              LDR      r0,[r4,#4]
000006  f7fffffe          BL       queue_process
;;;1400   }
00000a  bd10              POP      {r4,pc}
;;;1401   
                          ENDP


                          AREA ||i.gc_execute||, CODE, READONLY, ALIGN=2

                  gc_execute PROC
;;;1268   
;;;1269   static ret_code_t gc_execute(uint32_t prev_ret)
000000  b570              PUSH     {r4-r6,lr}
;;;1270   {
000002  4605              MOV      r5,r0
;;;1271       ret_code_t ret;
;;;1272   
;;;1273       if (prev_ret != NRF_SUCCESS)
000004  b10d              CBZ      r5,|L32.10|
;;;1274       {
;;;1275           return FDS_ERR_OPERATION_TIMEOUT;
000006  2001              MOVS     r0,#1
                  |L32.8|
;;;1276       }
;;;1277   
;;;1278       if (m_gc.resume)
;;;1279       {
;;;1280           m_gc.resume = false;
;;;1281       }
;;;1282       else
;;;1283       {
;;;1284           gc_state_advance();
;;;1285       }
;;;1286   
;;;1287       switch (m_gc.state)
;;;1288       {
;;;1289           case GC_NEXT_PAGE:
;;;1290               ret = gc_next_page();
;;;1291               break;
;;;1292   
;;;1293           case GC_FIND_NEXT_RECORD:
;;;1294               ret = gc_record_find_next();
;;;1295               break;
;;;1296   
;;;1297           case GC_COPY_RECORD:
;;;1298               ret = gc_record_copy();
;;;1299               break;
;;;1300   
;;;1301           case GC_ERASE_PAGE:
;;;1302               ret = gc_page_erase();
;;;1303               break;
;;;1304   
;;;1305           case GC_PROMOTE_SWAP:
;;;1306               ret = gc_swap_promote();
;;;1307               break;
;;;1308   
;;;1309           case GC_TAG_NEW_SWAP:
;;;1310               ret = gc_tag_new_swap();
;;;1311               break;
;;;1312   
;;;1313           default:
;;;1314               // Should not happen.
;;;1315               ret = FDS_ERR_INTERNAL;
;;;1316               break;
;;;1317       }
;;;1318   
;;;1319       // Either FDS_OP_EXECUTING, FDS_OP_COMPLETED, FDS_ERR_BUSY or FDS_ERR_INTERNAL.
;;;1320       return ret;
;;;1321   }
000008  bd70              POP      {r4-r6,pc}
                  |L32.10|
00000a  4818              LDR      r0,|L32.108|
00000c  7b00              LDRB     r0,[r0,#0xc]          ;1278  ; m_gc
00000e  b118              CBZ      r0,|L32.24|
000010  2000              MOVS     r0,#0                 ;1280
000012  4916              LDR      r1,|L32.108|
000014  7308              STRB     r0,[r1,#0xc]          ;1280
000016  e001              B        |L32.28|
                  |L32.24|
000018  f7fffffe          BL       gc_state_advance
                  |L32.28|
00001c  4813              LDR      r0,|L32.108|
00001e  7800              LDRB     r0,[r0,#0]            ;1287  ; m_gc
000020  2808              CMP      r0,#8                 ;1287
000022  d21d              BCS      |L32.96|
000024  e8dff000          TBB      [pc,r0]               ;1287
000028  1c04080c          DCB      0x1c,0x04,0x08,0x0c
00002c  101c1418          DCB      0x10,0x1c,0x14,0x18
000030  f7fffffe          BL       gc_next_page
000034  4604              MOV      r4,r0                 ;1290
000036  e015              B        |L32.100|
000038  f7fffffe          BL       gc_record_find_next
00003c  4604              MOV      r4,r0                 ;1294
00003e  e011              B        |L32.100|
000040  f7fffffe          BL       gc_record_copy
000044  4604              MOV      r4,r0                 ;1298
000046  e00d              B        |L32.100|
000048  f7fffffe          BL       gc_page_erase
00004c  4604              MOV      r4,r0                 ;1302
00004e  e009              B        |L32.100|
000050  f7fffffe          BL       gc_swap_promote
000054  4604              MOV      r4,r0                 ;1306
000056  e005              B        |L32.100|
000058  f7fffffe          BL       gc_tag_new_swap
00005c  4604              MOV      r4,r0                 ;1310
00005e  e001              B        |L32.100|
                  |L32.96|
000060  240f              MOVS     r4,#0xf               ;1315
000062  bf00              NOP                            ;1316
                  |L32.100|
000064  bf00              NOP                            ;1291
000066  4620              MOV      r0,r4                 ;1320
000068  e7ce              B        |L32.8|
;;;1322   
                          ENDP

00006a  0000              DCW      0x0000
                  |L32.108|
                          DCD      m_gc

                          AREA ||i.gc_init||, CODE, READONLY, ALIGN=2

                  gc_init PROC
;;;840    
;;;841    static void gc_init(void)
000000  480c              LDR      r0,|L33.52|
;;;842    {
;;;843        m_gc.run_count++;
000002  8900              LDRH     r0,[r0,#8]  ; m_gc
000004  1c40              ADDS     r0,r0,#1
000006  490b              LDR      r1,|L33.52|
000008  8108              STRH     r0,[r1,#8]
;;;844        m_gc.cur_page = 0;
00000a  2000              MOVS     r0,#0
00000c  8048              STRH     r0,[r1,#2]
;;;845        m_gc.resume   = false;
00000e  7308              STRB     r0,[r1,#0xc]
;;;846    
;;;847        // Setup which pages to GC. Defer checking for open records and the can_gc flag,
;;;848        // as other operations might change those while GC is running.
;;;849        for (uint16_t i = 0; i < FDS_DATA_PAGES; i++)
000010  bf00              NOP      
000012  e00c              B        |L33.46|
                  |L33.20|
;;;850        {
;;;851            m_gc.do_gc_page[i] = (m_pages[i].page_type == FDS_PAGE_DATA);
000014  4908              LDR      r1,|L33.56|
000016  eb011100          ADD      r1,r1,r0,LSL #4
00001a  7809              LDRB     r1,[r1,#0]
00001c  b909              CBNZ     r1,|L33.34|
00001e  2201              MOVS     r2,#1
000020  e000              B        |L33.36|
                  |L33.34|
000022  2200              MOVS     r2,#0
                  |L33.36|
000024  4903              LDR      r1,|L33.52|
000026  310a              ADDS     r1,r1,#0xa
000028  540a              STRB     r2,[r1,r0]
00002a  1c41              ADDS     r1,r0,#1              ;849
00002c  b288              UXTH     r0,r1                 ;849
                  |L33.46|
00002e  2802              CMP      r0,#2                 ;849
000030  dbf0              BLT      |L33.20|
;;;852        }
;;;853    }
000032  4770              BX       lr
;;;854    
                          ENDP

                  |L33.52|
                          DCD      m_gc
                  |L33.56|
                          DCD      m_pages

                          AREA ||i.gc_next_page||, CODE, READONLY, ALIGN=2

                  gc_next_page PROC
;;;967    
;;;968    static ret_code_t gc_next_page(void)
000000  b510              PUSH     {r4,lr}
;;;969    {
;;;970        if (!gc_page_next(&m_gc.cur_page))
000002  4808              LDR      r0,|L34.36|
000004  f7fffffe          BL       gc_page_next
000008  b940              CBNZ     r0,|L34.28|
;;;971        {
;;;972            // No pages left to GC; GC has terminated. Reset the state.
;;;973            m_gc.state        = GC_BEGIN;
00000a  2000              MOVS     r0,#0
00000c  4905              LDR      r1,|L34.36|
00000e  1e89              SUBS     r1,r1,#2
000010  7008              STRB     r0,[r1,#0]
;;;974            m_gc.cur_page     = 0;
000012  8048              STRH     r0,[r1,#2]
;;;975            m_gc.p_record_src = NULL;
000014  6048              STR      r0,[r1,#4]  ; m_gc
;;;976    
;;;977            return FDS_OP_COMPLETED;
000016  f641501d          MOV      r0,#0x1d1d
                  |L34.26|
;;;978        }
;;;979    
;;;980        return gc_record_find_next();
;;;981    }
00001a  bd10              POP      {r4,pc}
                  |L34.28|
00001c  f7fffffe          BL       gc_record_find_next
000020  e7fb              B        |L34.26|
;;;982    
                          ENDP

000022  0000              DCW      0x0000
                  |L34.36|
                          DCD      m_gc+0x2

                          AREA ||i.gc_page_erase||, CODE, READONLY, ALIGN=2

                  gc_page_erase PROC
;;;893    // records on the page being garbage collected.
;;;894    static ret_code_t gc_page_erase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;895    {
;;;896        uint32_t       ret;
;;;897        uint16_t const gc = m_gc.cur_page;
000002  480d              LDR      r0,|L35.56|
000004  8845              LDRH     r5,[r0,#2]  ; m_gc
;;;898    
;;;899        if (m_pages[gc].records_open == 0)
000006  480d              LDR      r0,|L35.60|
000008  eb001005          ADD      r0,r0,r5,LSL #4
00000c  8980              LDRH     r0,[r0,#0xc]
00000e  b968              CBNZ     r0,|L35.44|
;;;900        {
;;;901            ret = nrf_fstorage_erase(&m_fs, (uint32_t)m_pages[gc].p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
000010  480a              LDR      r0,|L35.60|
000012  eb001005          ADD      r0,r0,r5,LSL #4
000016  2300              MOVS     r3,#0
000018  2201              MOVS     r2,#1
00001a  6841              LDR      r1,[r0,#4]
00001c  4808              LDR      r0,|L35.64|
00001e  f7fffffe          BL       nrf_fstorage_erase
000022  4604              MOV      r4,r0
;;;902            m_gc.state = GC_ERASE_PAGE;
000024  2004              MOVS     r0,#4
000026  4904              LDR      r1,|L35.56|
000028  7008              STRB     r0,[r1,#0]
00002a  e002              B        |L35.50|
                  |L35.44|
;;;903        }
;;;904        else
;;;905        {
;;;906            // If there are open records, stop garbage collection on this page.
;;;907            // Discard the swap and try to garbage collect another page.
;;;908            ret = gc_swap_erase();
00002c  f7fffffe          BL       gc_swap_erase
000030  4604              MOV      r4,r0
                  |L35.50|
;;;909        }
;;;910    
;;;911        return ret;
000032  4620              MOV      r0,r4
;;;912    }
000034  bd70              POP      {r4-r6,pc}
;;;913    
                          ENDP

000036  0000              DCW      0x0000
                  |L35.56|
                          DCD      m_gc
                  |L35.60|
                          DCD      m_pages
                  |L35.64|
                          DCD      m_fs

                          AREA ||i.gc_page_next||, CODE, READONLY, ALIGN=2

                  gc_page_next PROC
;;;857    // Returns true if there are pages left to garbage collect, returns false otherwise.
;;;858    static bool gc_page_next(uint16_t * const p_next_page)
000000  b510              PUSH     {r4,lr}
;;;859    {
000002  4601              MOV      r1,r0
;;;860        bool ret = false;
000004  2200              MOVS     r2,#0
;;;861    
;;;862        for (uint16_t i = 0; i < FDS_DATA_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e015              B        |L36.54|
                  |L36.10|
;;;863        {
;;;864            if (m_gc.do_gc_page[i])
00000a  4b0d              LDR      r3,|L36.64|
00000c  5c1b              LDRB     r3,[r3,r0]
00000e  b183              CBZ      r3,|L36.50|
;;;865            {
;;;866                // Do not attempt to GC this page again.
;;;867                m_gc.do_gc_page[i] = false;
000010  2400              MOVS     r4,#0
000012  4b0b              LDR      r3,|L36.64|
000014  541c              STRB     r4,[r3,r0]
;;;868    
;;;869                // Only GC pages with no open records and with some records which have been deleted.
;;;870                if ((m_pages[i].records_open == 0) && (m_pages[i].can_gc == true))
000016  4b0b              LDR      r3,|L36.68|
000018  eb031300          ADD      r3,r3,r0,LSL #4
00001c  899b              LDRH     r3,[r3,#0xc]
00001e  b943              CBNZ     r3,|L36.50|
000020  4b08              LDR      r3,|L36.68|
000022  eb031300          ADD      r3,r3,r0,LSL #4
000026  7b9b              LDRB     r3,[r3,#0xe]
000028  2b01              CMP      r3,#1
00002a  d102              BNE      |L36.50|
;;;871                {
;;;872                    *p_next_page = i;
00002c  8008              STRH     r0,[r1,#0]
;;;873                    ret = true;
00002e  2201              MOVS     r2,#1
;;;874                    break;
000030  e003              B        |L36.58|
                  |L36.50|
000032  1c43              ADDS     r3,r0,#1              ;862
000034  b298              UXTH     r0,r3                 ;862
                  |L36.54|
000036  2802              CMP      r0,#2                 ;862
000038  dbe7              BLT      |L36.10|
                  |L36.58|
00003a  bf00              NOP      
;;;875                }
;;;876            }
;;;877        }
;;;878    
;;;879        return ret;
00003c  4610              MOV      r0,r2
;;;880    }
00003e  bd10              POP      {r4,pc}
;;;881    
                          ENDP

                  |L36.64|
                          DCD      m_gc+0xa
                  |L36.68|
                          DCD      m_pages

                          AREA ||i.gc_record_copy||, CODE, READONLY, ALIGN=2

                  gc_record_copy PROC
;;;915    // Copy the current record to swap.
;;;916    static ret_code_t gc_record_copy(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;917    {
;;;918        fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  480c              LDR      r0,|L37.52|
000004  6844              LDR      r4,[r0,#4]  ; m_gc
;;;919        uint32_t     const * const p_dest     = m_swap_page.p_addr + m_swap_page.write_offset;
000006  480c              LDR      r0,|L37.56|
000008  6800              LDR      r0,[r0,#0]  ; m_swap_page
00000a  490b              LDR      r1,|L37.56|
00000c  8889              LDRH     r1,[r1,#4]  ; m_swap_page
00000e  eb000581          ADD      r5,r0,r1,LSL #2
;;;920        uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->length_words;
000012  8860              LDRH     r0,[r4,#2]
000014  1cc0              ADDS     r0,r0,#3
000016  b286              UXTH     r6,r0
;;;921    
;;;922        m_gc.state = GC_COPY_RECORD;
000018  2003              MOVS     r0,#3
00001a  4906              LDR      r1,|L37.52|
00001c  7008              STRB     r0,[r1,#0]
;;;923    
;;;924        // Copy the record to swap; it is guaranteed to fit in the destination page,
;;;925        // so there is no need to check its size. This will either succeed or timeout.
;;;926        return nrf_fstorage_write(&m_fs, (uint32_t)p_dest, m_gc.p_record_src,
00001e  2000              MOVS     r0,#0
000020  00b3              LSLS     r3,r6,#2
000022  9000              STR      r0,[sp,#0]
000024  4608              MOV      r0,r1
000026  4629              MOV      r1,r5
000028  6842              LDR      r2,[r0,#4]  ; m_gc
00002a  4804              LDR      r0,|L37.60|
00002c  f7fffffe          BL       nrf_fstorage_write
;;;927                                  record_len * sizeof(uint32_t),
;;;928                                  NULL);
;;;929    }
000030  bdf8              POP      {r3-r7,pc}
;;;930    
                          ENDP

000032  0000              DCW      0x0000
                  |L37.52|
                          DCD      m_gc
                  |L37.56|
                          DCD      m_swap_page
                  |L37.60|
                          DCD      m_fs

                          AREA ||i.gc_record_find_next||, CODE, READONLY, ALIGN=2

                  gc_record_find_next PROC
;;;931    
;;;932    static ret_code_t gc_record_find_next(void)
000000  b510              PUSH     {r4,lr}
;;;933    {
;;;934        ret_code_t ret;
;;;935    
;;;936        // Find the next valid record to copy.
;;;937        if (record_find_next(m_gc.cur_page, &m_gc.p_record_src))
000002  4907              LDR      r1,|L38.32|
000004  8848              LDRH     r0,[r1,#2]  ; m_gc
000006  1d09              ADDS     r1,r1,#4
000008  f7fffffe          BL       record_find_next
00000c  b118              CBZ      r0,|L38.22|
;;;938        {
;;;939            ret = gc_record_copy();
00000e  f7fffffe          BL       gc_record_copy
000012  4604              MOV      r4,r0
000014  e002              B        |L38.28|
                  |L38.22|
;;;940        }
;;;941        else
;;;942        {
;;;943            // No more records left to copy on this page; swap pages.
;;;944            ret = gc_page_erase();
000016  f7fffffe          BL       gc_page_erase
00001a  4604              MOV      r4,r0
                  |L38.28|
;;;945        }
;;;946    
;;;947        return ret;
00001c  4620              MOV      r0,r4
;;;948    }
00001e  bd10              POP      {r4,pc}
;;;949    
                          ENDP

                  |L38.32|
                          DCD      m_gc

                          AREA ||i.gc_state_advance||, CODE, READONLY, ALIGN=2

                  gc_state_advance PROC
;;;1008   
;;;1009   static void gc_state_advance(void)
000000  b510              PUSH     {r4,lr}
;;;1010   {
;;;1011       switch (m_gc.state)
000002  4814              LDR      r0,|L39.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_gc
000006  2808              CMP      r0,#8
000008  d220              BCS      |L39.76|
00000a  e8dff000          TBB      [pc,r0]
00000e  041f              DCB      0x04,0x1f
000010  1f0a1016          DCB      0x1f,0x0a,0x10,0x16
000014  171b              DCB      0x17,0x1b
;;;1012       {
;;;1013           case GC_BEGIN:
;;;1014               gc_init();
000016  f7fffffe          BL       gc_init
;;;1015               m_gc.state = GC_NEXT_PAGE;
00001a  2001              MOVS     r0,#1
00001c  490d              LDR      r1,|L39.84|
00001e  7008              STRB     r0,[r1,#0]
;;;1016               break;
000020  e015              B        |L39.78|
;;;1017   
;;;1018           // A record was successfully copied.
;;;1019           case GC_COPY_RECORD:
;;;1020               gc_update_swap_offset();
000022  f7fffffe          BL       gc_update_swap_offset
;;;1021               m_gc.state = GC_FIND_NEXT_RECORD;
000026  2002              MOVS     r0,#2
000028  490a              LDR      r1,|L39.84|
00002a  7008              STRB     r0,[r1,#0]
;;;1022               break;
00002c  e00f              B        |L39.78|
;;;1023   
;;;1024           // A page was successfully erased. Prepare to promote the swap.
;;;1025           case GC_ERASE_PAGE:
;;;1026               gc_swap_pages();
00002e  f7fffffe          BL       gc_swap_pages
;;;1027               m_gc.state = GC_PROMOTE_SWAP;
000032  2006              MOVS     r0,#6
000034  4907              LDR      r1,|L39.84|
000036  7008              STRB     r0,[r1,#0]
;;;1028               break;
000038  e009              B        |L39.78|
;;;1029   
;;;1030           // Swap was discarded because the page being GC'ed had open records.
;;;1031           case GC_DISCARD_SWAP:
;;;1032           // Swap was sucessfully promoted.
;;;1033           case GC_PROMOTE_SWAP:
00003a  bf00              NOP      
;;;1034               // Prepare to tag the page just GC'ed as swap.
;;;1035               m_gc.state = GC_TAG_NEW_SWAP;
00003c  2007              MOVS     r0,#7
00003e  4905              LDR      r1,|L39.84|
000040  7008              STRB     r0,[r1,#0]
;;;1036               break;
000042  e004              B        |L39.78|
;;;1037   
;;;1038           case GC_TAG_NEW_SWAP:
;;;1039               m_gc.state = GC_NEXT_PAGE;
000044  2001              MOVS     r0,#1
000046  4903              LDR      r1,|L39.84|
000048  7008              STRB     r0,[r1,#0]
;;;1040               break;
00004a  e000              B        |L39.78|
                  |L39.76|
;;;1041   
;;;1042           default:
;;;1043               // Should not happen.
;;;1044               break;
00004c  bf00              NOP      
                  |L39.78|
00004e  bf00              NOP                            ;1016
;;;1045       }
;;;1046   }
000050  bd10              POP      {r4,pc}
;;;1047   
                          ENDP

000052  0000              DCW      0x0000
                  |L39.84|
                          DCD      m_gc

                          AREA ||i.gc_swap_erase||, CODE, READONLY, ALIGN=2

                  gc_swap_erase PROC
;;;882    
;;;883    static ret_code_t gc_swap_erase(void)
000000  b510              PUSH     {r4,lr}
;;;884    {
;;;885        m_gc.state               = GC_DISCARD_SWAP;
000002  2005              MOVS     r0,#5
000004  4906              LDR      r1,|L40.32|
000006  7008              STRB     r0,[r1,#0]
;;;886        m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000008  2002              MOVS     r0,#2
00000a  4906              LDR      r1,|L40.36|
00000c  8088              STRH     r0,[r1,#4]
;;;887    
;;;888        return nrf_fstorage_erase(&m_fs, (uint32_t)m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
00000e  4608              MOV      r0,r1
000010  2300              MOVS     r3,#0
000012  2201              MOVS     r2,#1
000014  6801              LDR      r1,[r0,#0]  ; m_swap_page
000016  4804              LDR      r0,|L40.40|
000018  f7fffffe          BL       nrf_fstorage_erase
;;;889    }
00001c  bd10              POP      {r4,pc}
;;;890    
                          ENDP

00001e  0000              DCW      0x0000
                  |L40.32|
                          DCD      m_gc
                  |L40.36|
                          DCD      m_swap_page
                  |L40.40|
                          DCD      m_fs

                          AREA ||i.gc_swap_pages||, CODE, READONLY, ALIGN=2

                  gc_swap_pages PROC
;;;993    
;;;994    static void gc_swap_pages(void)
000000  490d              LDR      r1,|L41.56|
;;;995    {
;;;996        // The page being garbage collected will be the new swap page,
;;;997        // and the current swap will be used as a data page (promoted).
;;;998        uint32_t const * const p_addr = m_swap_page.p_addr;
000002  6808              LDR      r0,[r1,#0]  ; m_swap_page
;;;999    
;;;1000       m_swap_page.p_addr            = m_pages[m_gc.cur_page].p_addr;
000004  490d              LDR      r1,|L41.60|
000006  8849              LDRH     r1,[r1,#2]  ; m_gc
000008  4a0d              LDR      r2,|L41.64|
00000a  eb021101          ADD      r1,r2,r1,LSL #4
00000e  6849              LDR      r1,[r1,#4]
000010  4a09              LDR      r2,|L41.56|
000012  6011              STR      r1,[r2,#0]  ; m_swap_page
;;;1001       m_pages[m_gc.cur_page].p_addr = p_addr;
000014  4909              LDR      r1,|L41.60|
000016  8849              LDRH     r1,[r1,#2]  ; m_gc
000018  4a09              LDR      r2,|L41.64|
00001a  eb021101          ADD      r1,r2,r1,LSL #4
00001e  6048              STR      r0,[r1,#4]
;;;1002   
;;;1003       // Keep the offset for this page, but reset it for the swap.
;;;1004       m_pages[m_gc.cur_page].write_offset = m_swap_page.write_offset;
000020  4905              LDR      r1,|L41.56|
000022  8889              LDRH     r1,[r1,#4]  ; m_swap_page
000024  4a05              LDR      r2,|L41.60|
000026  8852              LDRH     r2,[r2,#2]  ; m_gc
000028  4b05              LDR      r3,|L41.64|
00002a  eb031202          ADD      r2,r3,r2,LSL #4
00002e  8111              STRH     r1,[r2,#8]
;;;1005       m_swap_page.write_offset            = FDS_PAGE_TAG_SIZE;
000030  2102              MOVS     r1,#2
000032  4a01              LDR      r2,|L41.56|
000034  8091              STRH     r1,[r2,#4]
;;;1006   }
000036  4770              BX       lr
;;;1007   
                          ENDP

                  |L41.56|
                          DCD      m_swap_page
                  |L41.60|
                          DCD      m_gc
                  |L41.64|
                          DCD      m_pages

                          AREA ||i.gc_swap_promote||, CODE, READONLY, ALIGN=2

                  gc_swap_promote PROC
;;;951    // Promote the swap by tagging it as a data page.
;;;952    static ret_code_t gc_swap_promote(void)
000000  b510              PUSH     {r4,lr}
;;;953    {
;;;954        m_gc.state = GC_PROMOTE_SWAP;
000002  2006              MOVS     r0,#6
000004  4904              LDR      r1,|L42.24|
000006  7008              STRB     r0,[r1,#0]
;;;955        return page_tag_write_data(m_pages[m_gc.cur_page].p_addr);
000008  8849              LDRH     r1,[r1,#2]  ; m_gc
00000a  4a04              LDR      r2,|L42.28|
00000c  eb021101          ADD      r1,r2,r1,LSL #4
000010  6848              LDR      r0,[r1,#4]
000012  f7fffffe          BL       page_tag_write_data
;;;956    }
000016  bd10              POP      {r4,pc}
;;;957    
                          ENDP

                  |L42.24|
                          DCD      m_gc
                  |L42.28|
                          DCD      m_pages

                          AREA ||i.gc_tag_new_swap||, CODE, READONLY, ALIGN=2

                  gc_tag_new_swap PROC
;;;959    // Tag the page just garbage collected as swap.
;;;960    static ret_code_t gc_tag_new_swap(void)
000000  b510              PUSH     {r4,lr}
;;;961    {
;;;962        m_gc.state        = GC_TAG_NEW_SWAP;
000002  2007              MOVS     r0,#7
000004  4903              LDR      r1,|L43.20|
000006  7008              STRB     r0,[r1,#0]
;;;963        m_gc.p_record_src = NULL;
000008  2000              MOVS     r0,#0
00000a  6048              STR      r0,[r1,#4]  ; m_gc
;;;964        return page_tag_write_swap();
00000c  f7fffffe          BL       page_tag_write_swap
;;;965    }
000010  bd10              POP      {r4,pc}
;;;966    
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      m_gc

                          AREA ||i.gc_update_swap_offset||, CODE, READONLY, ALIGN=2

                  gc_update_swap_offset PROC
;;;984    // Update the swap page offeset after a record has been successfully copied to it.
;;;985    static void gc_update_swap_offset(void)
000000  4a05              LDR      r2,|L44.24|
;;;986    {
;;;987        fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  6850              LDR      r0,[r2,#4]  ; m_gc
;;;988        uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->length_words;
000004  8842              LDRH     r2,[r0,#2]
000006  1cd2              ADDS     r2,r2,#3
000008  b291              UXTH     r1,r2
;;;989    
;;;990        m_swap_page.write_offset += record_len;
00000a  4a04              LDR      r2,|L44.28|
00000c  8892              LDRH     r2,[r2,#4]  ; m_swap_page
00000e  440a              ADD      r2,r2,r1
000010  4b02              LDR      r3,|L44.28|
000012  809a              STRH     r2,[r3,#4]
;;;991    }
000014  4770              BX       lr
;;;992    
                          ENDP

000016  0000              DCW      0x0000
                  |L44.24|
                          DCD      m_gc
                  |L44.28|
                          DCD      m_swap_page

                          AREA ||i.header_is_valid||, CODE, READONLY, ALIGN=1

                  header_is_valid PROC
;;;175    
;;;176    static bool header_is_valid(fds_header_t const * const p_header)
000000  4601              MOV      r1,r0
;;;177    {
;;;178        return ((p_header->file_id    != FDS_FILE_ID_INVALID) &&
000002  8888              LDRH     r0,[r1,#4]
000004  f64f72ff          MOV      r2,#0xffff
000008  4290              CMP      r0,r2
00000a  d003              BEQ      |L45.20|
;;;179                (p_header->record_key != FDS_RECORD_KEY_DIRTY));
00000c  8808              LDRH     r0,[r1,#0]
00000e  b108              CBZ      r0,|L45.20|
000010  2001              MOVS     r0,#1
                  |L45.18|
;;;180    }
000012  4770              BX       lr
                  |L45.20|
000014  2000              MOVS     r0,#0                 ;179
000016  e7fc              B        |L45.18|
;;;181    
                          ENDP


                          AREA ||i.init_execute||, CODE, READONLY, ALIGN=2

                  init_execute PROC
;;;1049   // Initialize the filesystem.
;;;1050   static ret_code_t init_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1051   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1052       ret_code_t ret = FDS_ERR_INTERNAL;
000008  270f              MOVS     r7,#0xf
;;;1053   
;;;1054       if (prev_ret != NRF_SUCCESS)
00000a  b12e              CBZ      r6,|L46.24|
;;;1055       {
;;;1056           // A previous operation has timed out.
;;;1057           flag_clear(FDS_FLAG_INITIALIZING);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       flag_clear
;;;1058           return FDS_ERR_OPERATION_TIMEOUT;
000012  2001              MOVS     r0,#1
                  |L46.20|
;;;1059       }
;;;1060   
;;;1061       switch (p_op->init.step)
;;;1062       {
;;;1063           case FDS_OP_INIT_TAG_SWAP:
;;;1064               // The page write offset was determined previously by pages_init().
;;;1065               ret             = page_tag_write_swap();
;;;1066               p_op->init.step = FDS_OP_INIT_TAG_DATA;
;;;1067               break;
;;;1068   
;;;1069           case FDS_OP_INIT_TAG_DATA:
;;;1070           {
;;;1071               // Tag remaining erased pages as data.
;;;1072               bool write_reqd = false;
;;;1073               for (uint16_t i = 0; i < FDS_DATA_PAGES; i++)
;;;1074               {
;;;1075                   if (m_pages[i].page_type == FDS_PAGE_ERASED)
;;;1076                   {
;;;1077                       ret = page_tag_write_data(m_pages[i].p_addr);
;;;1078                       m_pages[i].page_type = FDS_PAGE_DATA;
;;;1079                       write_reqd           = true;
;;;1080                       break;
;;;1081                   }
;;;1082               }
;;;1083               if (!write_reqd)
;;;1084               {
;;;1085                   flag_set(FDS_FLAG_INITIALIZED);
;;;1086                   flag_clear(FDS_FLAG_INITIALIZING);
;;;1087                   return FDS_OP_COMPLETED;
;;;1088               }
;;;1089           }
;;;1090           break;
;;;1091   
;;;1092           case FDS_OP_INIT_ERASE_SWAP:
;;;1093               ret = nrf_fstorage_erase(&m_fs, (uint32_t)m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
;;;1094               // If the swap is going to be discarded then reset its write_offset.
;;;1095               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1096               p_op->init.step          = FDS_OP_INIT_TAG_SWAP;
;;;1097               break;
;;;1098   
;;;1099           case FDS_OP_INIT_PROMOTE_SWAP:
;;;1100           {
;;;1101               // When promoting the swap, keep the write_offset set by pages_init().
;;;1102               ret = page_tag_write_data(m_swap_page.p_addr);
;;;1103   
;;;1104               uint16_t const         gc         = m_gc.cur_page;
;;;1105               uint32_t const * const p_old_swap = m_swap_page.p_addr;
;;;1106   
;;;1107               // Execute the swap.
;;;1108               m_swap_page.p_addr = m_pages[gc].p_addr;
;;;1109               m_pages[gc].p_addr = p_old_swap;
;;;1110   
;;;1111               // Copy the offset from the swap to the new page.
;;;1112               m_pages[gc].write_offset = m_swap_page.write_offset;
;;;1113               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1114   
;;;1115               m_pages[gc].page_type = FDS_PAGE_DATA;
;;;1116               p_op->init.step       = FDS_OP_INIT_TAG_SWAP;
;;;1117           }
;;;1118           break;
;;;1119   
;;;1120           default:
;;;1121               // Should not happen.
;;;1122               break;
;;;1123       }
;;;1124   
;;;1125       if (ret != FDS_SUCCESS)
;;;1126       {
;;;1127           // fstorage queue was full.
;;;1128           flag_clear(FDS_FLAG_INITIALIZING);
;;;1129           return FDS_ERR_BUSY;
;;;1130       }
;;;1131   
;;;1132       return FDS_OP_EXECUTING;
;;;1133   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L46.24|
000018  7920              LDRB     r0,[r4,#4]            ;1061
00001a  b130              CBZ      r0,|L46.42|
00001c  2801              CMP      r0,#1                 ;1061
00001e  d00a              BEQ      |L46.54|
000020  2802              CMP      r0,#2                 ;1061
000022  d033              BEQ      |L46.140|
000024  2803              CMP      r0,#3                 ;1061
000026  d164              BNE      |L46.242|
000028  e03e              B        |L46.168|
                  |L46.42|
00002a  f7fffffe          BL       page_tag_write_swap
00002e  4607              MOV      r7,r0                 ;1065
000030  2001              MOVS     r0,#1                 ;1066
000032  7120              STRB     r0,[r4,#4]            ;1066
000034  e05e              B        |L46.244|
                  |L46.54|
000036  f04f0800          MOV      r8,#0                 ;1072
00003a  2500              MOVS     r5,#0                 ;1073
00003c  e016              B        |L46.108|
                  |L46.62|
00003e  4832              LDR      r0,|L46.264|
000040  eb001005          ADD      r0,r0,r5,LSL #4       ;1075
000044  7800              LDRB     r0,[r0,#0]            ;1075
000046  2802              CMP      r0,#2                 ;1075
000048  d10e              BNE      |L46.104|
00004a  492f              LDR      r1,|L46.264|
00004c  eb011105          ADD      r1,r1,r5,LSL #4       ;1077
000050  6848              LDR      r0,[r1,#4]            ;1077
000052  f7fffffe          BL       page_tag_write_data
000056  4607              MOV      r7,r0                 ;1077
000058  2000              MOVS     r0,#0                 ;1078
00005a  492b              LDR      r1,|L46.264|
00005c  eb011105          ADD      r1,r1,r5,LSL #4       ;1078
000060  7008              STRB     r0,[r1,#0]            ;1078
000062  f04f0801          MOV      r8,#1                 ;1079
000066  e003              B        |L46.112|
                  |L46.104|
000068  1c68              ADDS     r0,r5,#1              ;1073
00006a  b285              UXTH     r5,r0                 ;1073
                  |L46.108|
00006c  2d02              CMP      r5,#2                 ;1073
00006e  dbe6              BLT      |L46.62|
                  |L46.112|
000070  bf00              NOP                            ;1080
000072  f1b80f00          CMP      r8,#0                 ;1083
000076  d108              BNE      |L46.138|
000078  2002              MOVS     r0,#2                 ;1085
00007a  f7fffffe          BL       flag_set
00007e  2001              MOVS     r0,#1                 ;1086
000080  f7fffffe          BL       flag_clear
000084  f641501d          MOV      r0,#0x1d1d            ;1087
000088  e7c4              B        |L46.20|
                  |L46.138|
00008a  e033              B        |L46.244|
                  |L46.140|
00008c  481f              LDR      r0,|L46.268|
00008e  2300              MOVS     r3,#0                 ;1093
000090  2201              MOVS     r2,#1                 ;1093
000092  6801              LDR      r1,[r0,#0]            ;1093  ; m_swap_page
000094  481e              LDR      r0,|L46.272|
000096  f7fffffe          BL       nrf_fstorage_erase
00009a  4607              MOV      r7,r0                 ;1093
00009c  2002              MOVS     r0,#2                 ;1095
00009e  491b              LDR      r1,|L46.268|
0000a0  8088              STRH     r0,[r1,#4]            ;1095
0000a2  2000              MOVS     r0,#0                 ;1096
0000a4  7120              STRB     r0,[r4,#4]            ;1096
0000a6  e025              B        |L46.244|
                  |L46.168|
0000a8  4918              LDR      r1,|L46.268|
0000aa  6808              LDR      r0,[r1,#0]            ;1102  ; m_swap_page
0000ac  f7fffffe          BL       page_tag_write_data
0000b0  4607              MOV      r7,r0                 ;1102
0000b2  4818              LDR      r0,|L46.276|
0000b4  8845              LDRH     r5,[r0,#2]            ;1104  ; m_gc
0000b6  4815              LDR      r0,|L46.268|
0000b8  f8d08000          LDR      r8,[r0,#0]            ;1105  ; m_swap_page
0000bc  4812              LDR      r0,|L46.264|
0000be  eb001005          ADD      r0,r0,r5,LSL #4       ;1108
0000c2  6840              LDR      r0,[r0,#4]            ;1108
0000c4  4911              LDR      r1,|L46.268|
0000c6  6008              STR      r0,[r1,#0]            ;1108  ; m_swap_page
0000c8  480f              LDR      r0,|L46.264|
0000ca  eb001005          ADD      r0,r0,r5,LSL #4       ;1109
0000ce  f8c08004          STR      r8,[r0,#4]            ;1109
0000d2  4608              MOV      r0,r1                 ;1112
0000d4  8880              LDRH     r0,[r0,#4]            ;1112  ; m_swap_page
0000d6  490c              LDR      r1,|L46.264|
0000d8  eb011105          ADD      r1,r1,r5,LSL #4       ;1112
0000dc  8108              STRH     r0,[r1,#8]            ;1112
0000de  2002              MOVS     r0,#2                 ;1113
0000e0  490a              LDR      r1,|L46.268|
0000e2  8088              STRH     r0,[r1,#4]            ;1113
0000e4  2000              MOVS     r0,#0                 ;1115
0000e6  4908              LDR      r1,|L46.264|
0000e8  eb011105          ADD      r1,r1,r5,LSL #4       ;1115
0000ec  7008              STRB     r0,[r1,#0]            ;1115
0000ee  7120              STRB     r0,[r4,#4]            ;1116
0000f0  e000              B        |L46.244|
                  |L46.242|
0000f2  bf00              NOP                            ;1122
                  |L46.244|
0000f4  bf00              NOP                            ;1067
0000f6  b127              CBZ      r7,|L46.258|
0000f8  2001              MOVS     r0,#1                 ;1128
0000fa  f7fffffe          BL       flag_clear
0000fe  200e              MOVS     r0,#0xe               ;1129
000100  e788              B        |L46.20|
                  |L46.258|
000102  2000              MOVS     r0,#0                 ;1132
000104  e786              B        |L46.20|
;;;1134   
                          ENDP

000106  0000              DCW      0x0000
                  |L46.264|
                          DCD      m_pages
                  |L46.268|
                          DCD      m_swap_page
                  |L46.272|
                          DCD      m_fs
                  |L46.276|
                          DCD      m_gc

                          AREA ||i.is_word_aligned||, CODE, READONLY, ALIGN=1

                  is_word_aligned PROC
;;;1027    */
;;;1028   static __INLINE bool is_word_aligned(void const* p)
000000  4601              MOV      r1,r0
;;;1029   {
;;;1030       return (((uintptr_t)p & 0x03) == 0);
000002  f0010003          AND      r0,r1,#3
000006  b908              CBNZ     r0,|L47.12|
000008  2001              MOVS     r0,#1
                  |L47.10|
;;;1031   }
00000a  4770              BX       lr
                  |L47.12|
00000c  2000              MOVS     r0,#0                 ;1030
00000e  e7fc              B        |L47.10|
;;;1032   
                          ENDP


                          AREA ||i.op_enqueue||, CODE, READONLY, ALIGN=2

                  op_enqueue PROC
;;;566    // Enqueue an operation.
;;;567    static bool op_enqueue(fds_op_t const * p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;568    {
000002  4604              MOV      r4,r0
;;;569        uint32_t idx;
;;;570        bool     ret = false;
000004  2600              MOVS     r6,#0
;;;571    
;;;572        CRITICAL_SECTION_ENTER();
;;;573        if  (m_op_queue.count    <= FDS_OP_QUEUE_SIZE - 1)
000006  480f              LDR      r0,|L48.68|
000008  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
00000a  2803              CMP      r0,#3
00000c  d817              BHI      |L48.62|
;;;574        {
;;;575            idx = (m_op_queue.count + m_op_queue.rp) % FDS_OP_QUEUE_SIZE;
00000e  480d              LDR      r0,|L48.68|
000010  f8900074          LDRB     r0,[r0,#0x74]  ; m_op_queue
000014  490b              LDR      r1,|L48.68|
000016  f8911070          LDRB     r1,[r1,#0x70]  ; m_op_queue
00001a  4408              ADD      r0,r0,r1
00001c  f0000503          AND      r5,r0,#3
;;;576    
;;;577            m_op_queue.op[idx] = *p_op;
000020  ebc501c5          RSB      r1,r5,r5,LSL #3
000024  4a07              LDR      r2,|L48.68|
000026  eb020081          ADD      r0,r2,r1,LSL #2
00002a  221c              MOVS     r2,#0x1c
00002c  4621              MOV      r1,r4
00002e  f7fffffe          BL       __aeabi_memcpy4
;;;578            m_op_queue.count++;
000032  4804              LDR      r0,|L48.68|
000034  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000036  1c40              ADDS     r0,r0,#1
000038  4902              LDR      r1,|L48.68|
00003a  6748              STR      r0,[r1,#0x74]  ; m_op_queue
;;;579    
;;;580            ret = true;
00003c  2601              MOVS     r6,#1
                  |L48.62|
;;;581        }
;;;582        CRITICAL_SECTION_EXIT();
;;;583    
;;;584        return ret;
00003e  4630              MOV      r0,r6
;;;585    }
000040  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

000042  0000              DCW      0x0000
                  |L48.68|
                          DCD      m_op_queue

                          AREA ||i.page_from_record||, CODE, READONLY, ALIGN=2

                  page_from_record PROC
;;;238    // Returns FDS_SUCCESS if the page is found, FDS_ERR_NOT_FOUND otherwise.
;;;239    static ret_code_t page_from_record(uint16_t * const p_page, uint32_t const * const p_rec)
000000  b510              PUSH     {r4,lr}
;;;240    {
000002  4602              MOV      r2,r0
;;;241        ret_code_t ret = FDS_ERR_NOT_FOUND;
000004  230a              MOVS     r3,#0xa
;;;242    
;;;243        CRITICAL_SECTION_ENTER();
;;;244        for (uint16_t i = 0; i < FDS_DATA_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e012              B        |L49.48|
                  |L49.10|
;;;245        {
;;;246            if ((p_rec > m_pages[i].p_addr) &&
00000a  4c0c              LDR      r4,|L49.60|
00000c  eb041400          ADD      r4,r4,r0,LSL #4
000010  6864              LDR      r4,[r4,#4]
000012  428c              CMP      r4,r1
000014  d20a              BCS      |L49.44|
;;;247                (p_rec < m_pages[i].p_addr + FDS_PAGE_SIZE))
000016  4c09              LDR      r4,|L49.60|
000018  eb041400          ADD      r4,r4,r0,LSL #4
00001c  6864              LDR      r4,[r4,#4]
00001e  f5045480          ADD      r4,r4,#0x1000
000022  428c              CMP      r4,r1
000024  d902              BLS      |L49.44|
;;;248            {
;;;249                ret     = FDS_SUCCESS;
000026  2300              MOVS     r3,#0
;;;250                *p_page = i;
000028  8010              STRH     r0,[r2,#0]
;;;251                break;
00002a  e003              B        |L49.52|
                  |L49.44|
00002c  1c44              ADDS     r4,r0,#1              ;244
00002e  b2a0              UXTH     r0,r4                 ;244
                  |L49.48|
000030  2802              CMP      r0,#2                 ;244
000032  dbea              BLT      |L49.10|
                  |L49.52|
000034  bf00              NOP      
;;;252            }
;;;253        }
;;;254        CRITICAL_SECTION_EXIT();
;;;255    
;;;256        return ret;
000036  4618              MOV      r0,r3
;;;257    }
000038  bd10              POP      {r4,pc}
;;;258    
                          ENDP

00003a  0000              DCW      0x0000
                  |L49.60|
                          DCD      m_pages

                          AREA ||i.page_has_space||, CODE, READONLY, ALIGN=2

                  page_has_space PROC
;;;228    // NOTE: Must be called from within a critical section.
;;;229    static bool page_has_space(uint16_t page, uint16_t length_words)
000000  4602              MOV      r2,r0
;;;230    {
;;;231        length_words += m_pages[page].write_offset;
000002  4809              LDR      r0,|L50.40|
000004  eb001002          ADD      r0,r0,r2,LSL #4
000008  8900              LDRH     r0,[r0,#8]
00000a  4408              ADD      r0,r0,r1
00000c  b281              UXTH     r1,r0
;;;232        length_words += m_pages[page].words_reserved;
00000e  4806              LDR      r0,|L50.40|
000010  eb001002          ADD      r0,r0,r2,LSL #4
000014  8940              LDRH     r0,[r0,#0xa]
000016  4408              ADD      r0,r0,r1
000018  b281              UXTH     r1,r0
;;;233        return (length_words < FDS_PAGE_SIZE);
00001a  f5b16f80          CMP      r1,#0x400
00001e  da01              BGE      |L50.36|
000020  2001              MOVS     r0,#1
                  |L50.34|
;;;234    }
000022  4770              BX       lr
                  |L50.36|
000024  2000              MOVS     r0,#0                 ;233
000026  e7fc              B        |L50.34|
;;;235    
                          ENDP

                  |L50.40|
                          DCD      m_pages

                          AREA ||i.page_identify||, CODE, READONLY, ALIGN=2

                  page_identify PROC
;;;192    // Reads a page tag, and determines if the page is used to store data or as swap.
;;;193    static fds_page_type_t page_identify(uint32_t const * const p_page_addr)
000000  4601              MOV      r1,r0
;;;194    {
;;;195        if (p_page_addr[FDS_PAGE_TAG_WORD_0] != FDS_PAGE_TAG_MAGIC)
000002  4a08              LDR      r2,|L51.36|
000004  6808              LDR      r0,[r1,#0]
000006  4290              CMP      r0,r2
000008  d001              BEQ      |L51.14|
;;;196        {
;;;197            return FDS_PAGE_UNDEFINED;
00000a  2003              MOVS     r0,#3
                  |L51.12|
;;;198        }
;;;199    
;;;200        switch (p_page_addr[FDS_PAGE_TAG_WORD_1])
;;;201        {
;;;202            case FDS_PAGE_TAG_SWAP:
;;;203                return FDS_PAGE_SWAP;
;;;204    
;;;205            case FDS_PAGE_TAG_DATA:
;;;206                return FDS_PAGE_DATA;
;;;207    
;;;208            default:
;;;209                return FDS_PAGE_UNDEFINED;
;;;210        }
;;;211    }
00000c  4770              BX       lr
                  |L51.14|
00000e  4a06              LDR      r2,|L51.40|
000010  6848              LDR      r0,[r1,#4]            ;200
000012  4410              ADD      r0,r0,r2              ;200
000014  b110              CBZ      r0,|L51.28|
000016  2801              CMP      r0,#1                 ;200
000018  d102              BNE      |L51.32|
00001a  e7f7              B        |L51.12|
                  |L51.28|
00001c  2000              MOVS     r0,#0                 ;206
00001e  e7f5              B        |L51.12|
                  |L51.32|
000020  2003              MOVS     r0,#3                 ;209
000022  e7f3              B        |L51.12|
;;;212    
                          ENDP

                  |L51.36|
                          DCD      0xdeadc0de
                  |L51.40|
                          DCD      0x0ee1fe02

                          AREA ||i.page_is_erased||, CODE, READONLY, ALIGN=1

                  page_is_erased PROC
;;;213    
;;;214    static bool page_is_erased(uint32_t const * const p_page_addr)
000000  4602              MOV      r2,r0
;;;215    {
;;;216        for (uint32_t i = 0; i < FDS_PAGE_SIZE; i++)
000002  2100              MOVS     r1,#0
000004  e006              B        |L52.20|
                  |L52.6|
;;;217        {
;;;218            if (*(p_page_addr + i) != FDS_ERASED_WORD)
000006  f8520021          LDR      r0,[r2,r1,LSL #2]
00000a  1c40              ADDS     r0,r0,#1
00000c  b108              CBZ      r0,|L52.18|
;;;219            {
;;;220                return false;
00000e  2000              MOVS     r0,#0
                  |L52.16|
;;;221            }
;;;222        }
;;;223    
;;;224        return true;
;;;225    }
000010  4770              BX       lr
                  |L52.18|
000012  1c49              ADDS     r1,r1,#1              ;216
                  |L52.20|
000014  f5b16f80          CMP      r1,#0x400             ;216
000018  d3f5              BCC      |L52.6|
00001a  2001              MOVS     r0,#1                 ;224
00001c  e7f8              B        |L52.16|
;;;226    
                          ENDP


                          AREA ||i.page_offsets_update||, CODE, READONLY, ALIGN=1

                  page_offsets_update PROC
;;;303    
;;;304    static void page_offsets_update(fds_page_t * const p_page, uint16_t length_words)
000000  8903              LDRH     r3,[r0,#8]
;;;305    {
;;;306        p_page->write_offset   += (FDS_HEADER_SIZE + length_words);
000002  1cca              ADDS     r2,r1,#3
000004  441a              ADD      r2,r2,r3
000006  8102              STRH     r2,[r0,#8]
;;;307        p_page->words_reserved -= (FDS_HEADER_SIZE + length_words);
000008  8943              LDRH     r3,[r0,#0xa]
00000a  1cca              ADDS     r2,r1,#3
00000c  1a9a              SUBS     r2,r3,r2
00000e  8142              STRH     r2,[r0,#0xa]
;;;308    }
000010  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.page_scan||, CODE, READONLY, ALIGN=2

                  page_scan PROC
;;;263    // If an invalid record header is found, the can_gc argument is set to true.
;;;264    static void page_scan(uint32_t const *       p_addr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;265                          uint16_t       * const words_written,
;;;266                          bool           * const can_gc)
;;;267    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;268        uint32_t const * const p_end_addr          = p_addr + FDS_PAGE_SIZE;
00000a  f5045880          ADD      r8,r4,#0x1000
;;;269        bool                   dirty_record_found  = false;
00000e  f04f0900          MOV      r9,#0
;;;270    
;;;271        p_addr         += FDS_PAGE_TAG_SIZE;
000012  3408              ADDS     r4,r4,#8
;;;272        *words_written  = FDS_PAGE_TAG_SIZE;
000014  2002              MOVS     r0,#2
000016  8030              STRH     r0,[r6,#0]
;;;273    
;;;274        while ((p_addr < p_end_addr) && (*p_addr != FDS_ERASED_WORD))
000018  e019              B        |L54.78|
                  |L54.26|
;;;275        {
;;;276            // NOTE: Skip records with a dirty key or with a missing file ID.
;;;277            fds_header_t const * const p_header = (fds_header_t*)p_addr;
00001a  4625              MOV      r5,r4
;;;278    
;;;279            if (!header_is_valid(p_header))
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       header_is_valid
000022  b910              CBNZ     r0,|L54.42|
;;;280            {
;;;281                dirty_record_found = true;
000024  f04f0901          MOV      r9,#1
000028  e007              B        |L54.58|
                  |L54.42|
;;;282            }
;;;283            else
;;;284            {
;;;285                // Update the latest (largest) record ID.
;;;286                if (p_header->record_id > m_latest_rec_id)
00002a  490e              LDR      r1,|L54.100|
00002c  68a8              LDR      r0,[r5,#8]
00002e  6809              LDR      r1,[r1,#0]  ; m_latest_rec_id
000030  4288              CMP      r0,r1
000032  d902              BLS      |L54.58|
;;;287                {
;;;288                   m_latest_rec_id = p_header->record_id;
000034  490b              LDR      r1,|L54.100|
000036  68a8              LDR      r0,[r5,#8]
000038  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
                  |L54.58|
;;;289                }
;;;290            }
;;;291    
;;;292            // Jump to the next record.
;;;293            p_addr         += (FDS_HEADER_SIZE + p_header->length_words);
00003a  8868              LDRH     r0,[r5,#2]
00003c  1cc0              ADDS     r0,r0,#3
00003e  eb040480          ADD      r4,r4,r0,LSL #2
;;;294            *words_written += (FDS_HEADER_SIZE + p_header->length_words);
000042  8831              LDRH     r1,[r6,#0]
000044  8868              LDRH     r0,[r5,#2]
000046  1cc0              ADDS     r0,r0,#3
000048  4408              ADD      r0,r0,r1
00004a  8030              STRH     r0,[r6,#0]
;;;295        }
00004c  bf00              NOP      
                  |L54.78|
00004e  4544              CMP      r4,r8                 ;274
000050  d203              BCS      |L54.90|
000052  6820              LDR      r0,[r4,#0]            ;274
000054  1c40              ADDS     r0,r0,#1              ;274
000056  2800              CMP      r0,#0                 ;274
000058  d1df              BNE      |L54.26|
                  |L54.90|
;;;296    
;;;297        if (can_gc != NULL)
00005a  b10f              CBZ      r7,|L54.96|
;;;298        {
;;;299            *can_gc = dirty_record_found;
00005c  f8879000          STRB     r9,[r7,#0]
                  |L54.96|
;;;300        }
;;;301    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;302    
                          ENDP

                  |L54.100|
                          DCD      m_latest_rec_id

                          AREA ||i.page_tag_write_data||, CODE, READONLY, ALIGN=2

                  page_tag_write_data PROC
;;;320    // Tags a page as data, i.e, ready for storage.
;;;321    static ret_code_t page_tag_write_data(uint32_t const * const p_page_addr)
000000  b538              PUSH     {r3-r5,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323        // The tag needs to be statically allocated since it is not buffered by fstorage.
;;;324        static uint32_t const page_tag_data[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_DATA};
;;;325        return nrf_fstorage_write(&m_fs, (uint32_t)p_page_addr, page_tag_data, FDS_PAGE_TAG_SIZE * sizeof(uint32_t), NULL);
000004  2000              MOVS     r0,#0
000006  2308              MOVS     r3,#8
000008  4a03              LDR      r2,|L55.24|
00000a  4621              MOV      r1,r4
00000c  9000              STR      r0,[sp,#0]
00000e  4803              LDR      r0,|L55.28|
000010  f7fffffe          BL       nrf_fstorage_write
;;;326    }
000014  bd38              POP      {r3-r5,pc}
;;;327    
                          ENDP

000016  0000              DCW      0x0000
                  |L55.24|
                          DCD      page_tag_data
                  |L55.28|
                          DCD      m_fs

                          AREA ||i.page_tag_write_swap||, CODE, READONLY, ALIGN=2

                  page_tag_write_swap PROC
;;;311    // Tags a page as swap, i.e., reserved for GC.
;;;312    static ret_code_t page_tag_write_swap()
000000  b508              PUSH     {r3,lr}
;;;313    {
;;;314        // The tag needs to be statically allocated since it is not buffered by fstorage.
;;;315        static uint32_t const page_tag_swap[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_SWAP};
;;;316        return nrf_fstorage_write(&m_fs, (uint32_t)m_swap_page.p_addr, page_tag_swap, FDS_PAGE_TAG_SIZE * sizeof(uint32_t), NULL);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4804              LDR      r0,|L56.24|
000008  2308              MOVS     r3,#8
00000a  4a04              LDR      r2,|L56.28|
00000c  6801              LDR      r1,[r0,#0]  ; m_swap_page
00000e  4804              LDR      r0,|L56.32|
000010  f7fffffe          BL       nrf_fstorage_write
;;;317    }
000014  bd08              POP      {r3,pc}
;;;318    
                          ENDP

000016  0000              DCW      0x0000
                  |L56.24|
                          DCD      m_swap_page
                  |L56.28|
                          DCD      page_tag_swap
                  |L56.32|
                          DCD      m_fs

                          AREA ||i.pages_init||, CODE, READONLY, ALIGN=2

                  pages_init PROC
;;;589    // provide additional information regarding eventual further initialization steps.
;;;590    static fds_init_opts_t pages_init()
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;591    {
;;;592        uint32_t ret = NO_PAGES;
000004  2600              MOVS     r6,#0
;;;593        // The index of the page being initialized in m_pages[].
;;;594        uint16_t page = 0;
000006  2400              MOVS     r4,#0
;;;595        bool     swap_set_but_not_found  = false;
000008  46a0              MOV      r8,r4
;;;596    
;;;597        for (uint16_t i = 0; i < FDS_VIRTUAL_PAGES; i++)
00000a  2700              MOVS     r7,#0
00000c  e081              B        |L57.274|
                  |L57.14|
;;;598        {
;;;599            uint32_t        const * const p_page_addr = (uint32_t*)m_fs.start_addr + (i * FDS_PAGE_SIZE);
00000e  4844              LDR      r0,|L57.288|
000010  68c0              LDR      r0,[r0,#0xc]  ; m_fs
000012  eb003507          ADD      r5,r0,r7,LSL #12
;;;600            fds_page_type_t const         page_type   = page_identify(p_page_addr);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       page_identify
00001c  4681              MOV      r9,r0
;;;601    
;;;602            switch (page_type)
00001e  f1b90f00          CMP      r9,#0
000022  d032              BEQ      |L57.138|
000024  f1b90f01          CMP      r9,#1
000028  d04a              BEQ      |L57.192|
00002a  f1b90f03          CMP      r9,#3
00002e  d16c              BNE      |L57.266|
;;;603            {
;;;604                case FDS_PAGE_UNDEFINED:
;;;605                    if (page_is_erased(p_page_addr))
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       page_is_erased
000036  b1f8              CBZ      r0,|L57.120|
;;;606                    {
;;;607                        if (m_swap_page.p_addr != NULL)
000038  483a              LDR      r0,|L57.292|
00003a  6800              LDR      r0,[r0,#0]  ; m_swap_page
00003c  b190              CBZ      r0,|L57.100|
;;;608                        {
;;;609                            // If a swap page is already set, flag the page as erased (in m_pages)
;;;610                            // and try to tag it as data (in flash) later on during initialization.
;;;611                            m_pages[page].page_type    = FDS_PAGE_ERASED;
00003e  2002              MOVS     r0,#2
000040  4939              LDR      r1,|L57.296|
000042  eb011104          ADD      r1,r1,r4,LSL #4
000046  7008              STRB     r0,[r1,#0]
;;;612                            m_pages[page].p_addr       = p_page_addr;
000048  4837              LDR      r0,|L57.296|
00004a  eb001004          ADD      r0,r0,r4,LSL #4
00004e  6045              STR      r5,[r0,#4]
;;;613                            m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
000050  2002              MOVS     r0,#2
000052  4935              LDR      r1,|L57.296|
000054  eb011104          ADD      r1,r1,r4,LSL #4
000058  8108              STRH     r0,[r1,#8]
;;;614    
;;;615                            // This is a candidate for a potential new swap page, in case the
;;;616                            // current swap is going to be promoted to complete a GC instance.
;;;617                            m_gc.cur_page = page;
00005a  4834              LDR      r0,|L57.300|
00005c  8044              STRH     r4,[r0,#2]
;;;618                            page++;
00005e  1c60              ADDS     r0,r4,#1
000060  b284              UXTH     r4,r0
000062  e006              B        |L57.114|
                  |L57.100|
;;;619                        }
;;;620                        else
;;;621                        {
;;;622                            // If there is no swap page yet, use this one.
;;;623                            m_swap_page.p_addr       = p_page_addr;
000064  482f              LDR      r0,|L57.292|
000066  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;624                            m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000068  2002              MOVS     r0,#2
00006a  492e              LDR      r1,|L57.292|
00006c  8088              STRH     r0,[r1,#4]
;;;625                            swap_set_but_not_found   = true;
00006e  f04f0801          MOV      r8,#1
                  |L57.114|
;;;626                        }
;;;627    
;;;628                        ret |= PAGE_ERASED;
000072  f0460601          ORR      r6,r6,#1
000076  e007              B        |L57.136|
                  |L57.120|
;;;629                    }
;;;630                    else
;;;631                    {
;;;632                        // Do not initialize or use this page.
;;;633                        m_pages[page++].page_type = FDS_PAGE_UNDEFINED;
000078  2203              MOVS     r2,#3
00007a  4620              MOV      r0,r4
00007c  1c61              ADDS     r1,r4,#1
00007e  b28c              UXTH     r4,r1
000080  4929              LDR      r1,|L57.296|
000082  eb011000          ADD      r0,r1,r0,LSL #4
000086  7002              STRB     r2,[r0,#0]
                  |L57.136|
;;;634                    }
;;;635                    break;
000088  e040              B        |L57.268|
                  |L57.138|
;;;636    
;;;637                case FDS_PAGE_DATA:
;;;638                    m_pages[page].page_type = FDS_PAGE_DATA;
00008a  2000              MOVS     r0,#0
00008c  4926              LDR      r1,|L57.296|
00008e  eb011104          ADD      r1,r1,r4,LSL #4
000092  7008              STRB     r0,[r1,#0]
;;;639                    m_pages[page].p_addr    = p_page_addr;
000094  4824              LDR      r0,|L57.296|
000096  eb001004          ADD      r0,r0,r4,LSL #4
00009a  6045              STR      r5,[r0,#4]
;;;640                    // Scan the page to compute its write offset and determine whether or not the page
;;;641                    // can be garbage collected. Additionally, update the latest kwown record ID.
;;;642                    page_scan(p_page_addr, &m_pages[page].write_offset, &m_pages[page].can_gc);
00009c  4822              LDR      r0,|L57.296|
00009e  eb001004          ADD      r0,r0,r4,LSL #4
0000a2  f100020e          ADD      r2,r0,#0xe
0000a6  4820              LDR      r0,|L57.296|
0000a8  eb001004          ADD      r0,r0,r4,LSL #4
0000ac  f1000108          ADD      r1,r0,#8
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       page_scan
;;;643    
;;;644                    ret |= PAGE_DATA;
0000b6  f0460602          ORR      r6,r6,#2
;;;645                    page++;
0000ba  1c60              ADDS     r0,r4,#1
0000bc  b284              UXTH     r4,r0
;;;646    
;;;647                    break;
0000be  e025              B        |L57.268|
                  |L57.192|
;;;648    
;;;649                case FDS_PAGE_SWAP:
;;;650                    if (swap_set_but_not_found)
0000c0  f1b80f00          CMP      r8,#0
0000c4  d011              BEQ      |L57.234|
;;;651                    {
;;;652                        m_pages[page].page_type    = FDS_PAGE_ERASED;
0000c6  2002              MOVS     r0,#2
0000c8  4917              LDR      r1,|L57.296|
0000ca  eb011104          ADD      r1,r1,r4,LSL #4
0000ce  7008              STRB     r0,[r1,#0]
;;;653                        m_pages[page].p_addr       = m_swap_page.p_addr;
0000d0  4814              LDR      r0,|L57.292|
0000d2  6800              LDR      r0,[r0,#0]  ; m_swap_page
0000d4  4914              LDR      r1,|L57.296|
0000d6  eb011104          ADD      r1,r1,r4,LSL #4
0000da  6048              STR      r0,[r1,#4]
;;;654                        m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
0000dc  2002              MOVS     r0,#2
0000de  4912              LDR      r1,|L57.296|
0000e0  eb011104          ADD      r1,r1,r4,LSL #4
0000e4  8108              STRH     r0,[r1,#8]
;;;655    
;;;656                        page++;
0000e6  1c60              ADDS     r0,r4,#1
0000e8  b284              UXTH     r4,r0
                  |L57.234|
;;;657                    }
;;;658    
;;;659                    m_swap_page.p_addr = p_page_addr;
0000ea  480e              LDR      r0,|L57.292|
0000ec  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;660                    // If the swap is promoted, this offset should be kept, otherwise,
;;;661                    // it should be set to FDS_PAGE_TAG_SIZE.
;;;662                    page_scan(p_page_addr, &m_swap_page.write_offset, NULL);
0000ee  2200              MOVS     r2,#0
0000f0  1d01              ADDS     r1,r0,#4
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       page_scan
;;;663    
;;;664                    ret |= (m_swap_page.write_offset == FDS_PAGE_TAG_SIZE) ?
0000f8  480a              LDR      r0,|L57.292|
0000fa  8880              LDRH     r0,[r0,#4]  ; m_swap_page
0000fc  2802              CMP      r0,#2
0000fe  d101              BNE      |L57.260|
;;;665                            PAGE_SWAP_CLEAN : PAGE_SWAP_DIRTY;
000100  2004              MOVS     r0,#4
000102  e000              B        |L57.262|
                  |L57.260|
000104  2008              MOVS     r0,#8
                  |L57.262|
000106  4306              ORRS     r6,r6,r0
;;;666                    break;
000108  e000              B        |L57.268|
                  |L57.266|
;;;667    
;;;668                default:
;;;669                    // Shouldn't happen.
;;;670                    break;
00010a  bf00              NOP      
                  |L57.268|
00010c  bf00              NOP                            ;635
00010e  1c78              ADDS     r0,r7,#1              ;597
000110  b287              UXTH     r7,r0                 ;597
                  |L57.274|
000112  2f03              CMP      r7,#3                 ;597
000114  f6ffaf7b          BLT      |L57.14|
;;;671            }
;;;672        }
;;;673    
;;;674        return (fds_init_opts_t)ret;
000118  b2f0              UXTB     r0,r6
;;;675    }
00011a  e8bd87f0          POP      {r4-r10,pc}
;;;676    
                          ENDP

00011e  0000              DCW      0x0000
                  |L57.288|
                          DCD      m_fs
                  |L57.292|
                          DCD      m_swap_page
                  |L57.296|
                          DCD      m_pages
                  |L57.300|
                          DCD      m_gc

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;549    // Returns true if the queue is not empty.
;;;550    static bool queue_advance(void)
000000  b510              PUSH     {r4,lr}
;;;551    {
;;;552        // Reset the current element.
;;;553        memset(&m_op_queue.op[m_op_queue.rp], 0x00, sizeof(fds_op_t));
000002  4910              LDR      r1,|L58.68|
000004  6f09              LDR      r1,[r1,#0x70]  ; m_op_queue
000006  ebc101c1          RSB      r1,r1,r1,LSL #3
00000a  4a0e              LDR      r2,|L58.68|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  211c              MOVS     r1,#0x1c
000012  f7fffffe          BL       __aeabi_memclr4
;;;554    
;;;555        if (m_op_queue.count != 0)
000016  480b              LDR      r0,|L58.68|
000018  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
00001a  b158              CBZ      r0,|L58.52|
;;;556        {
;;;557            // Advance in the queue, wrapping around if necessary.
;;;558            m_op_queue.rp = (m_op_queue.rp + 1) % FDS_OP_QUEUE_SIZE;
00001c  4809              LDR      r0,|L58.68|
00001e  f8900070          LDRB     r0,[r0,#0x70]  ; m_op_queue
000022  1c40              ADDS     r0,r0,#1
000024  f0000003          AND      r0,r0,#3
000028  4906              LDR      r1,|L58.68|
00002a  6708              STR      r0,[r1,#0x70]  ; m_op_queue
;;;559            m_op_queue.count--;
00002c  4608              MOV      r0,r1
00002e  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000030  1e40              SUBS     r0,r0,#1
000032  6748              STR      r0,[r1,#0x74]  ; m_op_queue
                  |L58.52|
;;;560        }
;;;561    
;;;562        return (m_op_queue.count != 0);
000034  4803              LDR      r0,|L58.68|
000036  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000038  b108              CBZ      r0,|L58.62|
00003a  2001              MOVS     r0,#1
                  |L58.60|
;;;563    }
00003c  bd10              POP      {r4,pc}
                  |L58.62|
00003e  2000              MOVS     r0,#0                 ;562
000040  e7fc              B        |L58.60|
;;;564    
                          ENDP

000042  0000              DCW      0x0000
                  |L58.68|
                          DCD      m_op_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;1323   
;;;1324   static void queue_process(ret_code_t result)
000000  b570              PUSH     {r4-r6,lr}
;;;1325   {
000002  b086              SUB      sp,sp,#0x18
000004  4606              MOV      r6,r0
;;;1326       ret_code_t         ret;
;;;1327       fds_op_t   * const p_op = &m_op_queue.op[m_op_queue.rp];
000006  4824              LDR      r0,|L59.152|
000008  6f00              LDR      r0,[r0,#0x70]  ; m_op_queue
00000a  ebc000c0          RSB      r0,r0,r0,LSL #3
00000e  4922              LDR      r1,|L59.152|
000010  eb010580          ADD      r5,r1,r0,LSL #2
;;;1328   
;;;1329       switch (p_op->op_code)
000014  7828              LDRB     r0,[r5,#0]
000016  2807              CMP      r0,#7
000018  d21e              BCS      |L59.88|
00001a  e8dff000          TBB      [pc,r0]
00001e  1d04              DCB      0x1d,0x04
000020  0a0b1112          DCB      0x0a,0x0b,0x11,0x12
000024  1800              DCB      0x18,0x00
;;;1330       {
;;;1331           case FDS_OP_INIT:
;;;1332               ret = init_execute(result, p_op);
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       init_execute
00002e  4604              MOV      r4,r0
;;;1333               break;
000030  e014              B        |L59.92|
;;;1334   
;;;1335           case FDS_OP_WRITE:
;;;1336           case FDS_OP_UPDATE:
000032  bf00              NOP      
;;;1337               ret = write_execute(result, p_op);
000034  4629              MOV      r1,r5
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       write_execute
00003c  4604              MOV      r4,r0
;;;1338               break;
00003e  e00d              B        |L59.92|
;;;1339   
;;;1340           case FDS_OP_DEL_RECORD:
;;;1341           case FDS_OP_DEL_FILE:
000040  bf00              NOP      
;;;1342               ret = delete_execute(result, p_op);
000042  4629              MOV      r1,r5
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       delete_execute
00004a  4604              MOV      r4,r0
;;;1343               break;
00004c  e006              B        |L59.92|
;;;1344   
;;;1345           case FDS_OP_GC:
;;;1346               ret = gc_execute(result);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       gc_execute
000054  4604              MOV      r4,r0
;;;1347               break;
000056  e001              B        |L59.92|
                  |L59.88|
;;;1348   
;;;1349           default:
;;;1350               ret = FDS_ERR_INTERNAL;
000058  240f              MOVS     r4,#0xf
;;;1351               break;
00005a  bf00              NOP      
                  |L59.92|
00005c  bf00              NOP                            ;1333
;;;1352       }
;;;1353   
;;;1354       if (ret != FDS_OP_EXECUTING)
00005e  b1cc              CBZ      r4,|L59.148|
;;;1355       {
;;;1356           fds_evt_t evt;
;;;1357   
;;;1358           if (ret == FDS_OP_COMPLETED)
000060  f641501d          MOV      r0,#0x1d1d
000064  4284              CMP      r4,r0
000066  d102              BNE      |L59.110|
;;;1359           {
;;;1360               evt.result = FDS_SUCCESS;
000068  2000              MOVS     r0,#0
00006a  9002              STR      r0,[sp,#8]
00006c  e000              B        |L59.112|
                  |L59.110|
;;;1361           }
;;;1362           else
;;;1363           {
;;;1364               // Either FDS_ERR_BUSY, FDS_ERR_OPERATION_TIMEOUT,
;;;1365               // FDS_ERR_CRC_CHECK_FAILED or FDS_ERR_NOT_FOUND.
;;;1366               evt.result = ret;
00006e  9402              STR      r4,[sp,#8]
                  |L59.112|
;;;1367           }
;;;1368   
;;;1369           event_prepare(p_op, &evt);
000070  a901              ADD      r1,sp,#4
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       event_prepare
;;;1370           event_send(&evt);
000078  a801              ADD      r0,sp,#4
00007a  f7fffffe          BL       event_send
;;;1371   
;;;1372           // Advance the queue, and if there are any queued operations, process them.
;;;1373           if (queue_advance())
00007e  f7fffffe          BL       queue_advance
000082  b118              CBZ      r0,|L59.140|
;;;1374           {
;;;1375               queue_process(NRF_SUCCESS);
000084  2000              MOVS     r0,#0
000086  f7fffffe          BL       queue_process
00008a  e002              B        |L59.146|
                  |L59.140|
;;;1376           }
;;;1377           else
;;;1378           {
;;;1379               // No more elements in the queue. Clear the FDS_FLAG_PROCESSING flag,
;;;1380               // so that new operation can start processing the queue.
;;;1381               flag_clear(FDS_FLAG_PROCESSING);
00008c  2004              MOVS     r0,#4
00008e  f7fffffe          BL       flag_clear
                  |L59.146|
;;;1382           }
;;;1383       }
000092  bf00              NOP      
                  |L59.148|
;;;1384   }
000094  b006              ADD      sp,sp,#0x18
000096  bd70              POP      {r4-r6,pc}
;;;1385   
                          ENDP

                  |L59.152|
                          DCD      m_op_queue

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=1

                  queue_start PROC
;;;1386   
;;;1387   static void queue_start(void)
000000  b510              PUSH     {r4,lr}
;;;1388   {
;;;1389       if (!flag_is_set(FDS_FLAG_PROCESSING))
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       flag_is_set
000008  b928              CBNZ     r0,|L60.22|
;;;1390       {
;;;1391           flag_set(FDS_FLAG_PROCESSING);
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       flag_set
;;;1392           queue_process(NRF_SUCCESS);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       queue_process
                  |L60.22|
;;;1393       }
;;;1394   }
000016  bd10              POP      {r4,pc}
;;;1395   
                          ENDP


                          AREA ||i.record_find||, CODE, READONLY, ALIGN=2

                  record_find PROC
;;;462    // If both are NULL, it will iterate through all records.
;;;463    static ret_code_t record_find(uint16_t          const * p_file_id,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;464                                  uint16_t          const * p_record_key,
;;;465                                  fds_record_desc_t       * p_desc,
;;;466                                  fds_find_token_t        * p_token)
;;;467    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;468        if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  b910              CBNZ     r0,|L61.26|
;;;469        {
;;;470            return FDS_ERR_NOT_INITIALIZED;
000014  2002              MOVS     r0,#2
                  |L61.22|
;;;471        }
;;;472    
;;;473        if (p_desc == NULL || p_token == NULL)
;;;474        {
;;;475            return FDS_ERR_NULL_ARG;
;;;476        }
;;;477    
;;;478        // Begin (or resume) searching for a record.
;;;479        for (; p_token->page < FDS_DATA_PAGES; p_token->page++)
;;;480        {
;;;481            if (m_pages[p_token->page].page_type != FDS_PAGE_DATA)
;;;482            {
;;;483                // It might be that the page is FDS_PAGE_UNDEFINED.
;;;484                // Skip this page.
;;;485                continue;
;;;486            }
;;;487    
;;;488            while (record_find_next(p_token->page, &p_token->p_addr))
;;;489            {
;;;490                fds_header_t const * p_header = (fds_header_t*)p_token->p_addr;
;;;491    
;;;492                // A valid record was found, check its header for a match.
;;;493                if ((p_file_id != NULL) &&
;;;494                    (p_header->file_id != *p_file_id))
;;;495                {
;;;496                    continue;
;;;497                }
;;;498    
;;;499                if ((p_record_key != NULL) &&
;;;500                    (p_header->record_key != *p_record_key))
;;;501                {
;;;502                    continue;
;;;503                }
;;;504    
;;;505                // Record found; update the descriptor.
;;;506                p_desc->record_id    = p_header->record_id;
;;;507                p_desc->p_record     = p_token->p_addr;
;;;508                p_desc->gc_run_count = m_gc.run_count;
;;;509    
;;;510                return FDS_SUCCESS;
;;;511            }
;;;512    
;;;513            // We have scanned an entire page. Set the address in the token to NULL
;;;514            // so that it will be updated in the next iteration.
;;;515            p_token->p_addr = NULL;
;;;516        }
;;;517    
;;;518        return FDS_ERR_NOT_FOUND;
;;;519    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L61.26|
00001a  b105              CBZ      r5,|L61.30|
00001c  b90c              CBNZ     r4,|L61.34|
                  |L61.30|
00001e  2005              MOVS     r0,#5                 ;475
000020  e7f9              B        |L61.22|
                  |L61.34|
000022  e028              B        |L61.118|
                  |L61.36|
000024  88a0              LDRH     r0,[r4,#4]            ;481
000026  4916              LDR      r1,|L61.128|
000028  eb011000          ADD      r0,r1,r0,LSL #4       ;481
00002c  7800              LDRB     r0,[r0,#0]            ;481
00002e  b100              CBZ      r0,|L61.50|
000030  e01e              B        |L61.112|
                  |L61.50|
000032  e015              B        |L61.96|
                  |L61.52|
000034  6821              LDR      r1,[r4,#0]            ;490
000036  b126              CBZ      r6,|L61.66|
000038  8888              LDRH     r0,[r1,#4]            ;494
00003a  8832              LDRH     r2,[r6,#0]            ;494
00003c  4290              CMP      r0,r2                 ;494
00003e  d000              BEQ      |L61.66|
000040  e00e              B        |L61.96|
                  |L61.66|
000042  b127              CBZ      r7,|L61.78|
000044  8808              LDRH     r0,[r1,#0]            ;500
000046  883a              LDRH     r2,[r7,#0]            ;500
000048  4290              CMP      r0,r2                 ;500
00004a  d000              BEQ      |L61.78|
00004c  e008              B        |L61.96|
                  |L61.78|
00004e  6888              LDR      r0,[r1,#8]            ;506
000050  6028              STR      r0,[r5,#0]            ;506
000052  6820              LDR      r0,[r4,#0]            ;507
000054  6068              STR      r0,[r5,#4]            ;507
000056  480b              LDR      r0,|L61.132|
000058  8900              LDRH     r0,[r0,#8]            ;508  ; m_gc
00005a  8128              STRH     r0,[r5,#8]            ;508
00005c  2000              MOVS     r0,#0                 ;510
00005e  e7da              B        |L61.22|
                  |L61.96|
000060  88a0              LDRH     r0,[r4,#4]            ;488
000062  4621              MOV      r1,r4                 ;488
000064  f7fffffe          BL       record_find_next
000068  2800              CMP      r0,#0                 ;488
00006a  d1e3              BNE      |L61.52|
00006c  6020              STR      r0,[r4,#0]            ;515
00006e  bf00              NOP                            ;485
                  |L61.112|
000070  88a0              LDRH     r0,[r4,#4]            ;479
000072  1c40              ADDS     r0,r0,#1              ;479
000074  80a0              STRH     r0,[r4,#4]            ;479
                  |L61.118|
000076  88a0              LDRH     r0,[r4,#4]            ;479
000078  2802              CMP      r0,#2                 ;479
00007a  dbd3              BLT      |L61.36|
00007c  200a              MOVS     r0,#0xa               ;518
00007e  e7ca              B        |L61.22|
;;;520    
                          ENDP

                  |L61.128|
                          DCD      m_pages
                  |L61.132|
                          DCD      m_gc

                          AREA ||i.record_find_and_delete||, CODE, READONLY, ALIGN=1

                  record_find_and_delete PROC
;;;744    
;;;745    static ret_code_t record_find_and_delete(fds_op_t * const p_op)
000000  b57f              PUSH     {r0-r6,lr}
;;;746    {
000002  4604              MOV      r4,r0
;;;747        ret_code_t        ret;
;;;748        uint16_t          page;
;;;749        fds_record_desc_t desc = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
;;;750    
;;;751        desc.record_id = p_op->del.record_to_delete;
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  9000              STR      r0,[sp,#0]
;;;752    
;;;753        if (record_find_by_desc(&desc, &page))
000010  a903              ADD      r1,sp,#0xc
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       record_find_by_desc
000018  b158              CBZ      r0,|L62.50|
;;;754        {
;;;755            fds_header_t const * const p_header = (fds_header_t const *)desc.p_record;
00001a  9e01              LDR      r6,[sp,#4]
;;;756    
;;;757            // Copy the record key and file ID, so that they can be returned in the event.
;;;758            // In case this function is run as part of an update, there is no need to copy
;;;759            // the file ID and record key since they are present in the header stored
;;;760            // in the queue element.
;;;761    
;;;762            p_op->del.file_id    = p_header->file_id;
00001c  88b1              LDRH     r1,[r6,#4]
00001e  80e1              STRH     r1,[r4,#6]
;;;763            p_op->del.record_key = p_header->record_key;
000020  8831              LDRH     r1,[r6,#0]
000022  8121              STRH     r1,[r4,#8]
;;;764    
;;;765            // Flag the record as dirty.
;;;766            ret = record_header_flag_dirty((uint32_t*)desc.p_record, page);
000024  f8bd100c          LDRH     r1,[sp,#0xc]
000028  9801              LDR      r0,[sp,#4]
00002a  f7fffffe          BL       record_header_flag_dirty
00002e  4605              MOV      r5,r0
;;;767        }
000030  e000              B        |L62.52|
                  |L62.50|
;;;768        else
;;;769        {
;;;770            // The record never existed, or it has already been deleted.
;;;771            ret = FDS_ERR_NOT_FOUND;
000032  250a              MOVS     r5,#0xa
                  |L62.52|
;;;772        }
;;;773    
;;;774        return ret;
000034  4628              MOV      r0,r5
;;;775    }
000036  b004              ADD      sp,sp,#0x10
000038  bd70              POP      {r4-r6,pc}
;;;776    
                          ENDP


                          AREA ||i.record_find_by_desc||, CODE, READONLY, ALIGN=2

                  record_find_by_desc PROC
;;;423    // NOTE: Do not pass NULL as an argument for p_page.
;;;424    static bool record_find_by_desc(fds_record_desc_t * const p_desc, uint16_t * const p_page)
000000  b538              PUSH     {r3-r5,lr}
;;;425    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;426        // If the gc_run_count field in the descriptor matches our counter, then the record has
;;;427        // not been moved. If the address is valid, and the record ID matches, there is no need
;;;428        // to find the record again. Only lookup the page in which the record is stored.
;;;429    
;;;430        if ((address_is_valid(p_desc->p_record))     &&
000006  6860              LDR      r0,[r4,#4]
000008  f7fffffe          BL       address_is_valid
00000c  b190              CBZ      r0,|L63.52|
;;;431            (p_desc->gc_run_count == m_gc.run_count) &&
00000e  8920              LDRH     r0,[r4,#8]
000010  4919              LDR      r1,|L63.120|
000012  8909              LDRH     r1,[r1,#8]  ; m_gc
000014  4288              CMP      r0,r1
000016  d10d              BNE      |L63.52|
;;;432            (p_desc->record_id    == ((fds_header_t*)p_desc->p_record)->record_id))
000018  e9d40100          LDRD     r0,r1,[r4,#0]
00001c  6889              LDR      r1,[r1,#8]
00001e  4288              CMP      r0,r1
000020  d108              BNE      |L63.52|
;;;433        {
;;;434            return (page_from_record(p_page, p_desc->p_record) == FDS_SUCCESS);
000022  4628              MOV      r0,r5
000024  6861              LDR      r1,[r4,#4]
000026  f7fffffe          BL       page_from_record
00002a  b908              CBNZ     r0,|L63.48|
00002c  2001              MOVS     r0,#1
                  |L63.46|
;;;435        }
;;;436    
;;;437        // Otherwise, find the record in flash.
;;;438        for (*p_page = 0; *p_page < FDS_DATA_PAGES; (*p_page)++)
;;;439        {
;;;440            // Set p_record to NULL to make record_find_next() search from the beginning of the page.
;;;441            uint32_t const * p_record = NULL;
;;;442    
;;;443            while (record_find_next(*p_page, &p_record))
;;;444            {
;;;445                fds_header_t const * const p_header = (fds_header_t*)p_record;
;;;446                if (p_header->record_id == p_desc->record_id)
;;;447                {
;;;448                    p_desc->p_record     = p_record;
;;;449                    p_desc->gc_run_count = m_gc.run_count;
;;;450                    return true;
;;;451                }
;;;452            }
;;;453        }
;;;454    
;;;455        return false;
;;;456    }
00002e  bd38              POP      {r3-r5,pc}
                  |L63.48|
000030  2000              MOVS     r0,#0                 ;434
000032  e7fc              B        |L63.46|
                  |L63.52|
000034  2000              MOVS     r0,#0                 ;438
000036  8028              STRH     r0,[r5,#0]            ;438
000038  e018              B        |L63.108|
                  |L63.58|
00003a  2000              MOVS     r0,#0                 ;441
00003c  9000              STR      r0,[sp,#0]            ;441
00003e  e00c              B        |L63.90|
                  |L63.64|
000040  9900              LDR      r1,[sp,#0]            ;445
000042  6888              LDR      r0,[r1,#8]            ;446
000044  6822              LDR      r2,[r4,#0]            ;446
000046  4290              CMP      r0,r2                 ;446
000048  d106              BNE      |L63.88|
00004a  9800              LDR      r0,[sp,#0]            ;448
00004c  6060              STR      r0,[r4,#4]            ;448
00004e  480a              LDR      r0,|L63.120|
000050  8900              LDRH     r0,[r0,#8]            ;449  ; m_gc
000052  8120              STRH     r0,[r4,#8]            ;449
000054  2001              MOVS     r0,#1                 ;450
000056  e7ea              B        |L63.46|
                  |L63.88|
000058  bf00              NOP                            ;452
                  |L63.90|
00005a  8828              LDRH     r0,[r5,#0]            ;443
00005c  4669              MOV      r1,sp                 ;443
00005e  f7fffffe          BL       record_find_next
000062  2800              CMP      r0,#0                 ;443
000064  d1ec              BNE      |L63.64|
000066  8828              LDRH     r0,[r5,#0]            ;438
000068  1c40              ADDS     r0,r0,#1              ;438
00006a  8028              STRH     r0,[r5,#0]            ;438
                  |L63.108|
00006c  8828              LDRH     r0,[r5,#0]            ;438
00006e  2802              CMP      r0,#2                 ;438
000070  dbe3              BLT      |L63.58|
000072  2000              MOVS     r0,#0                 ;455
000074  e7db              B        |L63.46|
;;;457    
                          ENDP

000076  0000              DCW      0x0000
                  |L63.120|
                          DCD      m_gc

                          AREA ||i.record_find_next||, CODE, READONLY, ALIGN=2

                  record_find_next PROC
;;;380    // If no record is found, p_record is unchanged.
;;;381    static bool record_find_next(uint16_t page, uint32_t const ** p_record)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;382    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;383        fds_header_t const * p_header;
;;;384        uint32_t     const * p_next_rec = (*p_record);
000008  683c              LDR      r4,[r7,#0]
;;;385    
;;;386        // If this is not the first invocation on this page, then jump to the next record.
;;;387        // Otherwise, start searching from the beginning of the page.
;;;388        if (p_next_rec != NULL)
00000a  b12c              CBZ      r4,|L64.24|
;;;389        {
;;;390            p_header    = ((fds_header_t*)p_next_rec);
00000c  4625              MOV      r5,r4
;;;391            p_next_rec += (FDS_HEADER_SIZE + p_header->length_words);
00000e  8868              LDRH     r0,[r5,#2]
000010  1cc0              ADDS     r0,r0,#3
000012  eb040480          ADD      r4,r4,r0,LSL #2
000016  e005              B        |L64.36|
                  |L64.24|
;;;392        }
;;;393        else
;;;394        {
;;;395            p_next_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
000018  4810              LDR      r0,|L64.92|
00001a  eb001006          ADD      r0,r0,r6,LSL #4
00001e  6840              LDR      r0,[r0,#4]
000020  f1000408          ADD      r4,r0,#8
                  |L64.36|
;;;396        }
;;;397    
;;;398        // Read records from the page, until a valid record is found or the end of the page is
;;;399        // reached. The argument p_record is only updated if a valid record is found.
;;;400        while ((p_next_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE) &&
000024  e00c              B        |L64.64|
                  |L64.38|
;;;401               *p_next_rec != FDS_ERASED_WORD))
;;;402        {
;;;403            p_header = (fds_header_t*)p_next_rec;
000026  4625              MOV      r5,r4
;;;404    
;;;405            if (header_is_valid(p_header))
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       header_is_valid
00002e  b118              CBZ      r0,|L64.56|
;;;406            {
;;;407                *p_record = p_next_rec;
000030  603c              STR      r4,[r7,#0]
;;;408                return true;
000032  2001              MOVS     r0,#1
                  |L64.52|
;;;409            }
;;;410            else
;;;411            {
;;;412                // The record is not valid, jump to the next.
;;;413                p_next_rec += (FDS_HEADER_SIZE + (p_header->length_words));
;;;414            }
;;;415        }
;;;416    
;;;417        // No more valid records on this page.
;;;418        return false;
;;;419    }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L64.56|
000038  8868              LDRH     r0,[r5,#2]            ;413
00003a  1cc0              ADDS     r0,r0,#3              ;413
00003c  eb040480          ADD      r4,r4,r0,LSL #2       ;413
                  |L64.64|
000040  4806              LDR      r0,|L64.92|
000042  eb001006          ADD      r0,r0,r6,LSL #4       ;400
000046  6840              LDR      r0,[r0,#4]            ;400
000048  f5005080          ADD      r0,r0,#0x1000         ;400
00004c  42a0              CMP      r0,r4                 ;400
00004e  d903              BLS      |L64.88|
000050  6820              LDR      r0,[r4,#0]            ;401
000052  1c40              ADDS     r0,r0,#1              ;401
000054  2800              CMP      r0,#0                 ;401
000056  d1e6              BNE      |L64.38|
                  |L64.88|
000058  2000              MOVS     r0,#0                 ;418
00005a  e7eb              B        |L64.52|
;;;420    
                          ENDP

                  |L64.92|
                          DCD      m_pages

                          AREA ||i.record_header_flag_dirty||, CODE, READONLY, ALIGN=2

                  record_header_flag_dirty PROC
;;;723    
;;;724    static ret_code_t record_header_flag_dirty(uint32_t * const p_record, uint16_t page_to_gc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;725    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;726        // Used to flag a record as dirty, i.e. ready for garbage collection.
;;;727        // Must be statically allocated since it will be written to flash.
;;;728        __ALIGN(4) static uint32_t const dirty_header = {0xFFFF0000};
;;;729    
;;;730        // Flag the record as dirty.
;;;731        ret_code_t ret = nrf_fstorage_write(&m_fs, (uint32_t)p_record,
000006  2000              MOVS     r0,#0
000008  2304              MOVS     r3,#4
00000a  4a08              LDR      r2,|L65.44|
00000c  4621              MOV      r1,r4
00000e  9000              STR      r0,[sp,#0]
000010  4807              LDR      r0,|L65.48|
000012  f7fffffe          BL       nrf_fstorage_write
000016  4606              MOV      r6,r0
;;;732                                &dirty_header, FDS_HEADER_SIZE_TL * sizeof(uint32_t), NULL);
;;;733    
;;;734        if (ret != NRF_SUCCESS)
000018  b10e              CBZ      r6,|L65.30|
;;;735        {
;;;736            return FDS_ERR_BUSY;
00001a  200e              MOVS     r0,#0xe
                  |L65.28|
;;;737        }
;;;738    
;;;739        m_pages[page_to_gc].can_gc = true;
;;;740    
;;;741        return FDS_SUCCESS;
;;;742    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L65.30|
00001e  2001              MOVS     r0,#1                 ;739
000020  4904              LDR      r1,|L65.52|
000022  eb011105          ADD      r1,r1,r5,LSL #4       ;739
000026  7388              STRB     r0,[r1,#0xe]          ;739
000028  2000              MOVS     r0,#0                 ;741
00002a  e7f7              B        |L65.28|
;;;743    
                          ENDP

                  |L65.44|
                          DCD      dirty_header
                  |L65.48|
                          DCD      m_fs
                  |L65.52|
                          DCD      m_pages

                          AREA ||i.record_header_write_begin||, CODE, READONLY, ALIGN=2

                  record_header_write_begin PROC
;;;678    // Write the first part of a record header (the key and length).
;;;679    static ret_code_t record_header_write_begin(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;680    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;681        ret_code_t ret;
;;;682    
;;;683        // Write the record ID next.
;;;684        p_op->write.step = FDS_OP_WRITE_RECORD_ID;
000006  2102              MOVS     r1,#2
000008  75a1              STRB     r1,[r4,#0x16]
;;;685    
;;;686        ret = nrf_fstorage_write(&m_fs, (uint32_t)(p_addr + FDS_OFFSET_TL),
00000a  2000              MOVS     r0,#0
00000c  2304              MOVS     r3,#4
00000e  1d22              ADDS     r2,r4,#4
000010  4629              MOV      r1,r5
000012  9000              STR      r0,[sp,#0]
000014  4804              LDR      r0,|L66.40|
000016  f7fffffe          BL       nrf_fstorage_write
00001a  4606              MOV      r6,r0
;;;687            &p_op->write.header.record_key, FDS_HEADER_SIZE_TL * sizeof(uint32_t), NULL);
;;;688    
;;;689        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
00001c  b90e              CBNZ     r6,|L66.34|
00001e  2000              MOVS     r0,#0
                  |L66.32|
;;;690    }
000020  bdf8              POP      {r3-r7,pc}
                  |L66.34|
000022  200e              MOVS     r0,#0xe               ;689
000024  e7fc              B        |L66.32|
;;;691    
                          ENDP

000026  0000              DCW      0x0000
                  |L66.40|
                          DCD      m_fs

                          AREA ||i.record_header_write_finalize||, CODE, READONLY, ALIGN=2

                  record_header_write_finalize PROC
;;;707    
;;;708    static ret_code_t record_header_write_finalize(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;709    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;710        ret_code_t ret;
;;;711    
;;;712        // If this is a simple write operation, then this is the last step.
;;;713        // If this is an update instead, delete the old record next.
;;;714        p_op->write.step = (p_op->op_code == FDS_OP_UPDATE) ? FDS_OP_WRITE_FLAG_DIRTY :
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d101              BNE      |L67.16|
00000c  2105              MOVS     r1,#5
00000e  e000              B        |L67.18|
                  |L67.16|
;;;715                                                              FDS_OP_WRITE_DONE;
000010  2106              MOVS     r1,#6
                  |L67.18|
000012  75a1              STRB     r1,[r4,#0x16]
;;;716    
;;;717        ret = nrf_fstorage_write(&m_fs, (uint32_t)(p_addr + FDS_OFFSET_IC),
000014  2000              MOVS     r0,#0
000016  2304              MOVS     r3,#4
000018  f1040208          ADD      r2,r4,#8
00001c  1d31              ADDS     r1,r6,#4
00001e  9000              STR      r0,[sp,#0]
000020  4804              LDR      r0,|L67.52|
000022  f7fffffe          BL       nrf_fstorage_write
000026  4605              MOV      r5,r0
;;;718            &p_op->write.header.file_id, FDS_HEADER_SIZE_IC * sizeof(uint32_t), NULL);
;;;719    
;;;720        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000028  b90d              CBNZ     r5,|L67.46|
00002a  2000              MOVS     r0,#0
                  |L67.44|
;;;721    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L67.46|
00002e  200e              MOVS     r0,#0xe               ;720
000030  e7fc              B        |L67.44|
;;;722    
                          ENDP

000032  0000              DCW      0x0000
                  |L67.52|
                          DCD      m_fs

                          AREA ||i.record_header_write_id||, CODE, READONLY, ALIGN=2

                  record_header_write_id PROC
;;;692    
;;;693    static ret_code_t record_header_write_id(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;694    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;695        ret_code_t ret;
;;;696        // If this record has no data, write the last part of the header directly.
;;;697        // Otherwise, write the record data next.
;;;698        p_op->write.step = (p_op->write.p_data != NULL) ? FDS_OP_WRITE_DATA :
000006  6920              LDR      r0,[r4,#0x10]
000008  b108              CBZ      r0,|L68.14|
00000a  2103              MOVS     r1,#3
00000c  e000              B        |L68.16|
                  |L68.14|
;;;699                                                          FDS_OP_WRITE_HEADER_FINALIZE;
00000e  2101              MOVS     r1,#1
                  |L68.16|
000010  75a1              STRB     r1,[r4,#0x16]
;;;700    
;;;701        ret = nrf_fstorage_write(&m_fs, (uint32_t)(p_addr + FDS_OFFSET_ID),
000012  2000              MOVS     r0,#0
000014  2304              MOVS     r3,#4
000016  f104020c          ADD      r2,r4,#0xc
00001a  f1060108          ADD      r1,r6,#8
00001e  9000              STR      r0,[sp,#0]
000020  4804              LDR      r0,|L68.52|
000022  f7fffffe          BL       nrf_fstorage_write
000026  4605              MOV      r5,r0
;;;702            &p_op->write.header.record_id, FDS_HEADER_SIZE_ID * sizeof(uint32_t), NULL);
;;;703    
;;;704        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000028  b90d              CBNZ     r5,|L68.46|
00002a  2000              MOVS     r0,#0
                  |L68.44|
;;;705    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L68.46|
00002e  200e              MOVS     r0,#0xe               ;704
000030  e7fc              B        |L68.44|
;;;706    
                          ENDP

000032  0000              DCW      0x0000
                  |L68.52|
                          DCD      m_fs

                          AREA ||i.record_id_new||, CODE, READONLY, ALIGN=2

                  record_id_new PROC
;;;367    
;;;368    static uint32_t record_id_new(void)
000000  4803              LDR      r0,|L69.16|
;;;369    {
;;;370        CRITICAL_SECTION_ENTER();
;;;371        m_latest_rec_id++;
000002  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
000004  1c40              ADDS     r0,r0,#1
000006  4902              LDR      r1,|L69.16|
000008  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
;;;372        CRITICAL_SECTION_EXIT();
;;;373        return m_latest_rec_id;
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
;;;374    }
00000e  4770              BX       lr
;;;375    
                          ENDP

                  |L69.16|
                          DCD      m_latest_rec_id

                          AREA ||i.record_write_data||, CODE, READONLY, ALIGN=2

                  record_write_data PROC
;;;805    // Writes record data to flash.
;;;806    static ret_code_t record_write_data(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;807    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;808        ret_code_t ret;
;;;809    
;;;810        p_op->write.step = FDS_OP_WRITE_HEADER_FINALIZE;
000006  2101              MOVS     r1,#1
000008  75a1              STRB     r1,[r4,#0x16]
;;;811    
;;;812        ret = nrf_fstorage_write(&m_fs, (uint32_t)(p_addr + FDS_OFFSET_DATA),
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  88e0              LDRH     r0,[r4,#6]
000010  0083              LSLS     r3,r0,#2
000012  f105010c          ADD      r1,r5,#0xc
000016  4805              LDR      r0,|L70.44|
000018  6922              LDR      r2,[r4,#0x10]
00001a  f7fffffe          BL       nrf_fstorage_write
00001e  4606              MOV      r6,r0
;;;813                                 p_op->write.p_data,  p_op->write.header.length_words * sizeof(uint32_t), NULL);
;;;814    
;;;815        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000020  b90e              CBNZ     r6,|L70.38|
000022  2000              MOVS     r0,#0
                  |L70.36|
;;;816    }
000024  bdf8              POP      {r3-r7,pc}
                  |L70.38|
000026  200e              MOVS     r0,#0xe               ;815
000028  e7fc              B        |L70.36|
;;;817    
                          ENDP

00002a  0000              DCW      0x0000
                  |L70.44|
                          DCD      m_fs

                          AREA ||i.write_enqueue||, CODE, READONLY, ALIGN=2

                  write_enqueue PROC
;;;1403   // Enqueues write and update operations.
;;;1404   static ret_code_t write_enqueue(fds_record_desc_t         * const p_desc,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1405                                   fds_record_t        const * const p_record,
;;;1406                                   fds_reserve_token_t const * const p_tok,
;;;1407                                   fds_op_code_t                     op_code)
;;;1408   {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;1409       ret_code_t ret;
;;;1410       fds_op_t   op;
;;;1411       uint16_t   page;
;;;1412       uint16_t   crc          = 0;
00000e  f04f0a00          MOV      r10,#0
;;;1413       uint16_t   length_words = 0;
000012  46d1              MOV      r9,r10
;;;1414   
;;;1415       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       flag_is_set
00001a  b918              CBNZ     r0,|L71.36|
;;;1416       {
;;;1417           return FDS_ERR_NOT_INITIALIZED;
00001c  2002              MOVS     r0,#2
                  |L71.30|
;;;1418       }
;;;1419   
;;;1420       if (p_record == NULL)
;;;1421       {
;;;1422           return FDS_ERR_NULL_ARG;
;;;1423       }
;;;1424   
;;;1425       if ((p_record->file_id == FDS_FILE_ID_INVALID) ||
;;;1426           (p_record->key     == FDS_RECORD_KEY_DIRTY))
;;;1427       {
;;;1428           return FDS_ERR_INVALID_ARG;
;;;1429       }
;;;1430   
;;;1431       if (!is_word_aligned(p_record->data.p_data))
;;;1432       {
;;;1433           return FDS_ERR_UNALIGNED_ADDR;
;;;1434       }
;;;1435   
;;;1436       // No space was previously reserved for this operation.
;;;1437       if (p_tok == NULL)
;;;1438       {
;;;1439           // Find a page where to write data.
;;;1440           length_words = p_record->data.length_words;
;;;1441           ret = write_space_reserve(length_words, &page);
;;;1442   
;;;1443           if (ret != FDS_SUCCESS)
;;;1444           {
;;;1445               // There is either not enough space in flash (FDS_ERR_NO_SPACE_IN_FLASH) or
;;;1446               // the record exceeds the size of virtual page (FDS_ERR_RECORD_TOO_LARGE).
;;;1447               return ret;
;;;1448           }
;;;1449       }
;;;1450       else
;;;1451       {
;;;1452           page         = p_tok->page;
;;;1453           length_words = p_tok->length_words;
;;;1454       }
;;;1455   
;;;1456       // Initialize the operation.
;;;1457       op.op_code                   = op_code;
;;;1458       op.write.step                = FDS_OP_WRITE_HEADER_BEGIN;
;;;1459       op.write.page                = page;
;;;1460       op.write.p_data              = p_record->data.p_data;
;;;1461       op.write.header.record_id    = record_id_new();
;;;1462       op.write.header.file_id      = p_record->file_id;
;;;1463       op.write.header.record_key   = p_record->key;
;;;1464       op.write.header.length_words = length_words;
;;;1465   
;;;1466       if (op_code == FDS_OP_UPDATE)
;;;1467       {
;;;1468           op.write.step             = FDS_OP_WRITE_FIND_RECORD;
;;;1469           // Save the record ID of the record to be updated.
;;;1470           op.write.record_to_delete = p_desc->record_id;
;;;1471       }
;;;1472   
;;;1473   #if (FDS_CRC_CHECK_ON_READ)
;;;1474       // First, compute the CRC for the first 6 bytes of the header which contain the
;;;1475       // record key, length and file ID, then, compute the CRC of the record ID (4 bytes).
;;;1476       crc = crc16_compute((uint8_t*)&op.write.header,           6, NULL);
;;;1477       crc = crc16_compute((uint8_t*)&op.write.header.record_id, 4, &crc);
;;;1478   
;;;1479       // Compute the CRC for the record data.
;;;1480       crc = crc16_compute((uint8_t*)p_record->data.p_data,
;;;1481                           p_record->data.length_words * sizeof(uint32_t), &crc);
;;;1482   #endif
;;;1483   
;;;1484       op.write.header.crc16 = crc;
;;;1485   
;;;1486       // Attempt to enqueue the operation.
;;;1487       if (!op_enqueue(&op))
;;;1488       {
;;;1489           // No space availble in the queues. Cancel the reservation of flash space.
;;;1490           CRITICAL_SECTION_ENTER();
;;;1491           write_space_free(length_words, page);
;;;1492           CRITICAL_SECTION_EXIT();
;;;1493   
;;;1494           return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1495       }
;;;1496   
;;;1497        // Initialize the record descriptor, if provided.
;;;1498       if (p_desc != NULL)
;;;1499       {
;;;1500           p_desc->p_record       = NULL;
;;;1501           // Don't invoke record_id_new() again !
;;;1502           p_desc->record_id      = op.write.header.record_id;
;;;1503           p_desc->record_is_open = false;
;;;1504           p_desc->gc_run_count   = m_gc.run_count;
;;;1505       }
;;;1506   
;;;1507       // Start processing the queue, if necessary.
;;;1508       queue_start();
;;;1509   
;;;1510       return FDS_SUCCESS;
;;;1511   }
00001e  b008              ADD      sp,sp,#0x20
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L71.36|
000024  b90c              CBNZ     r4,|L71.42|
000026  2005              MOVS     r0,#5                 ;1422
000028  e7f9              B        |L71.30|
                  |L71.42|
00002a  8820              LDRH     r0,[r4,#0]            ;1425
00002c  f64f71ff          MOV      r1,#0xffff            ;1425
000030  4288              CMP      r0,r1                 ;1425
000032  d001              BEQ      |L71.56|
000034  8860              LDRH     r0,[r4,#2]            ;1426
000036  b908              CBNZ     r0,|L71.60|
                  |L71.56|
000038  2004              MOVS     r0,#4                 ;1428
00003a  e7f0              B        |L71.30|
                  |L71.60|
00003c  6860              LDR      r0,[r4,#4]            ;1431
00003e  f7fffffe          BL       is_word_aligned
000042  b908              CBNZ     r0,|L71.72|
000044  2003              MOVS     r0,#3                 ;1433
000046  e7ea              B        |L71.30|
                  |L71.72|
000048  b966              CBNZ     r6,|L71.100|
00004a  8920              LDRH     r0,[r4,#8]            ;1440
00004c  fa1ff980          UXTH     r9,r0                 ;1440
000050  4669              MOV      r1,sp                 ;1441
000052  4648              MOV      r0,r9                 ;1441
000054  f7fffffe          BL       write_space_reserve
000058  4680              MOV      r8,r0                 ;1441
00005a  f1b80f00          CMP      r8,#0                 ;1443
00005e  d005              BEQ      |L71.108|
000060  4640              MOV      r0,r8                 ;1447
000062  e7dc              B        |L71.30|
                  |L71.100|
000064  8830              LDRH     r0,[r6,#0]            ;1452
000066  9000              STR      r0,[sp,#0]            ;1452
000068  f8b69002          LDRH     r9,[r6,#2]            ;1453
                  |L71.108|
00006c  f88d7004          STRB     r7,[sp,#4]            ;1457
000070  2100              MOVS     r1,#0                 ;1458
000072  f88d101a          STRB     r1,[sp,#0x1a]         ;1458
000076  f8bd1000          LDRH     r1,[sp,#0]            ;1459
00007a  f8ad1018          STRH     r1,[sp,#0x18]         ;1459
00007e  6861              LDR      r1,[r4,#4]            ;1460
000080  9105              STR      r1,[sp,#0x14]         ;1460
000082  f7fffffe          BL       record_id_new
000086  9004              STR      r0,[sp,#0x10]         ;1461
000088  8821              LDRH     r1,[r4,#0]            ;1462
00008a  f8ad100c          STRH     r1,[sp,#0xc]          ;1462
00008e  8860              LDRH     r0,[r4,#2]            ;1463
000090  f8ad0008          STRH     r0,[sp,#8]            ;1463
000094  f8ad900a          STRH     r9,[sp,#0xa]          ;1464
000098  2f03              CMP      r7,#3                 ;1466
00009a  d104              BNE      |L71.166|
00009c  2104              MOVS     r1,#4                 ;1468
00009e  f88d101a          STRB     r1,[sp,#0x1a]         ;1468
0000a2  6829              LDR      r1,[r5,#0]            ;1470
0000a4  9107              STR      r1,[sp,#0x1c]         ;1470
                  |L71.166|
0000a6  f8ada00e          STRH     r10,[sp,#0xe]         ;1484
0000aa  a801              ADD      r0,sp,#4              ;1487
0000ac  f7fffffe          BL       op_enqueue
0000b0  b930              CBNZ     r0,|L71.192|
0000b2  f8bd1000          LDRH     r1,[sp,#0]            ;1491
0000b6  4648              MOV      r0,r9                 ;1491
0000b8  f7fffffe          BL       write_space_free
0000bc  2008              MOVS     r0,#8                 ;1494
0000be  e7ae              B        |L71.30|
                  |L71.192|
0000c0  b145              CBZ      r5,|L71.212|
0000c2  2000              MOVS     r0,#0                 ;1500
0000c4  6068              STR      r0,[r5,#4]            ;1500
0000c6  9804              LDR      r0,[sp,#0x10]         ;1502
0000c8  6028              STR      r0,[r5,#0]            ;1502
0000ca  2000              MOVS     r0,#0                 ;1503
0000cc  72a8              STRB     r0,[r5,#0xa]          ;1503
0000ce  4803              LDR      r0,|L71.220|
0000d0  8900              LDRH     r0,[r0,#8]            ;1504  ; m_gc
0000d2  8128              STRH     r0,[r5,#8]            ;1504
                  |L71.212|
0000d4  f7fffffe          BL       queue_start
0000d8  2000              MOVS     r0,#0                 ;1510
0000da  e7a0              B        |L71.30|
;;;1512   
                          ENDP

                  |L71.220|
                          DCD      m_gc

                          AREA ||i.write_execute||, CODE, READONLY, ALIGN=2

                  write_execute PROC
;;;1136   // Executes write and update operations.
;;;1137   static ret_code_t write_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1138   {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1139       ret_code_t         ret;
;;;1140       uint32_t   *       p_write_addr;
;;;1141       fds_page_t * const p_page = &m_pages[p_op->write.page];
000008  8aa8              LDRH     r0,[r5,#0x14]
00000a  492a              LDR      r1,|L72.180|
00000c  eb011600          ADD      r6,r1,r0,LSL #4
;;;1142   
;;;1143       // This must persist across calls.
;;;1144       static fds_record_desc_t desc = {0};
;;;1145       // When a record is updated, this variable will hold the page where the old
;;;1146       // copy was stored. This will be used to set the can_gc flag when the header is
;;;1147       // invalidated (FDS_OP_WRITE_FLAG_DIRTY).
;;;1148       static uint16_t page;
;;;1149   
;;;1150       if (prev_ret != NRF_SUCCESS)
000010  b137              CBZ      r7,|L72.32|
;;;1151       {
;;;1152           // The previous operation has timed out, update offsets.
;;;1153           page_offsets_update(p_page, p_op->write.header.length_words);
000012  88e9              LDRH     r1,[r5,#6]
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       page_offsets_update
;;;1154           return FDS_ERR_OPERATION_TIMEOUT;
00001a  2001              MOVS     r0,#1
                  |L72.28|
;;;1155       }
;;;1156   
;;;1157       // Compute the address where to write data.
;;;1158       p_write_addr = (uint32_t*)(p_page->p_addr + p_page->write_offset);
;;;1159   
;;;1160       // Execute the current step of the operation, and set one to be executed next.
;;;1161       switch (p_op->write.step)
;;;1162       {
;;;1163           case FDS_OP_WRITE_FIND_RECORD:
;;;1164           {
;;;1165               // The first step of updating a record constists of locating the copy to be deleted.
;;;1166               // If the old copy couldn't be found for any reason then the update should fail.
;;;1167               // This prevents duplicates when queuing multiple updates of the same record.
;;;1168               desc.p_record  = NULL;
;;;1169               desc.record_id = p_op->write.record_to_delete;
;;;1170   
;;;1171               if (!record_find_by_desc(&desc, &page))
;;;1172               {
;;;1173                   return FDS_ERR_NOT_FOUND;
;;;1174               }
;;;1175               // Setting the step is redundant since we are falling through.
;;;1176           }
;;;1177           // Fallthrough to FDS_OP_WRITE_HEADER_BEGIN.
;;;1178   
;;;1179           case FDS_OP_WRITE_HEADER_BEGIN:
;;;1180               ret = record_header_write_begin(p_op, p_write_addr);
;;;1181               break;
;;;1182   
;;;1183           case FDS_OP_WRITE_RECORD_ID:
;;;1184               ret = record_header_write_id(p_op, p_write_addr);
;;;1185               break;
;;;1186   
;;;1187           case FDS_OP_WRITE_DATA:
;;;1188               ret = record_write_data(p_op, p_write_addr);
;;;1189               break;
;;;1190   
;;;1191           case FDS_OP_WRITE_HEADER_FINALIZE:
;;;1192               ret = record_header_write_finalize(p_op, p_write_addr);
;;;1193               break;
;;;1194   
;;;1195           case FDS_OP_WRITE_FLAG_DIRTY:
;;;1196               ret = record_header_flag_dirty((uint32_t*)desc.p_record, page);
;;;1197               p_op->write.step = FDS_OP_WRITE_DONE;
;;;1198               break;
;;;1199   
;;;1200           case FDS_OP_WRITE_DONE:
;;;1201               ret = FDS_OP_COMPLETED;
;;;1202   
;;;1203   #if (FDS_CRC_CHECK_ON_WRITE)
;;;1204               if (!crc_verify_success(p_op->write.header.crc16,
;;;1205                                       p_op->write.header.length_words,
;;;1206                                       p_write_addr))
;;;1207               {
;;;1208                   ret = FDS_ERR_CRC_CHECK_FAILED;
;;;1209               }
;;;1210   #endif
;;;1211               break;
;;;1212   
;;;1213           default:
;;;1214               ret = FDS_ERR_INTERNAL;
;;;1215               break;
;;;1216       }
;;;1217   
;;;1218       // An operation has either completed or failed. It may have failed because fstorage
;;;1219       // ran out of memory, or because the user tried to delete a record which did not exist.
;;;1220       if (ret != FDS_OP_EXECUTING)
;;;1221       {
;;;1222           // There won't be another callback for this operation, so update the page offset now.
;;;1223           page_offsets_update(p_page, p_op->write.header.length_words);
;;;1224       }
;;;1225   
;;;1226       return ret;
;;;1227   }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L72.32|
000020  8931              LDRH     r1,[r6,#8]            ;1158
000022  6870              LDR      r0,[r6,#4]            ;1158
000024  eb000881          ADD      r8,r0,r1,LSL #2       ;1158
000028  7da8              LDRB     r0,[r5,#0x16]         ;1161
00002a  2807              CMP      r0,#7                 ;1161
00002c  d237              BCS      |L72.158|
00002e  e8dff000          TBB      [pc,r0]               ;1161
000032  1123              DCB      0x11,0x23
000034  171d0429          DCB      0x17,0x1d,0x04,0x29
000038  3300              DCB      0x33,0x00
00003a  2000              MOVS     r0,#0                 ;1168
00003c  491e              LDR      r1,|L72.184|
00003e  6048              STR      r0,[r1,#4]            ;1168  ; desc
000040  69a8              LDR      r0,[r5,#0x18]         ;1169
000042  6008              STR      r0,[r1,#0]            ;1169  ; desc
000044  491d              LDR      r1,|L72.188|
000046  481c              LDR      r0,|L72.184|
000048  f7fffffe          BL       record_find_by_desc
00004c  b908              CBNZ     r0,|L72.82|
00004e  200a              MOVS     r0,#0xa               ;1173
000050  e7e4              B        |L72.28|
                  |L72.82|
000052  bf00              NOP                            ;1179
000054  4641              MOV      r1,r8                 ;1180
000056  4628              MOV      r0,r5                 ;1180
000058  f7fffffe          BL       record_header_write_begin
00005c  4604              MOV      r4,r0                 ;1180
00005e  e020              B        |L72.162|
000060  4641              MOV      r1,r8                 ;1184
000062  4628              MOV      r0,r5                 ;1184
000064  f7fffffe          BL       record_header_write_id
000068  4604              MOV      r4,r0                 ;1184
00006a  e01a              B        |L72.162|
00006c  4641              MOV      r1,r8                 ;1188
00006e  4628              MOV      r0,r5                 ;1188
000070  f7fffffe          BL       record_write_data
000074  4604              MOV      r4,r0                 ;1188
000076  e014              B        |L72.162|
000078  4641              MOV      r1,r8                 ;1192
00007a  4628              MOV      r0,r5                 ;1192
00007c  f7fffffe          BL       record_header_write_finalize
000080  4604              MOV      r4,r0                 ;1192
000082  e00e              B        |L72.162|
000084  490c              LDR      r1,|L72.184|
000086  6848              LDR      r0,[r1,#4]            ;1196  ; desc
000088  490c              LDR      r1,|L72.188|
00008a  8809              LDRH     r1,[r1,#0]            ;1196  ; page
00008c  f7fffffe          BL       record_header_flag_dirty
000090  4604              MOV      r4,r0                 ;1196
000092  2106              MOVS     r1,#6                 ;1197
000094  75a9              STRB     r1,[r5,#0x16]         ;1197
000096  e004              B        |L72.162|
000098  f641541d          MOV      r4,#0x1d1d            ;1201
00009c  e001              B        |L72.162|
                  |L72.158|
00009e  240f              MOVS     r4,#0xf               ;1214
0000a0  bf00              NOP                            ;1215
                  |L72.162|
0000a2  bf00              NOP                            ;1181
0000a4  b11c              CBZ      r4,|L72.174|
0000a6  88e9              LDRH     r1,[r5,#6]            ;1223
0000a8  4630              MOV      r0,r6                 ;1223
0000aa  f7fffffe          BL       page_offsets_update
                  |L72.174|
0000ae  4620              MOV      r0,r4                 ;1226
0000b0  e7b4              B        |L72.28|
;;;1228   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L72.180|
                          DCD      m_pages
                  |L72.184|
                          DCD      desc
                  |L72.188|
                          DCD      page

                          AREA ||i.write_space_free||, CODE, READONLY, ALIGN=2

                  write_space_free PROC
;;;361    // NOTE: Must be called within a critical section.
;;;362    static void write_space_free(uint16_t length_words, uint16_t page)
000000  4a05              LDR      r2,|L73.24|
;;;363    {
;;;364        m_pages[page].words_reserved -= (length_words + FDS_HEADER_SIZE);
000002  eb021201          ADD      r2,r2,r1,LSL #4
000006  8953              LDRH     r3,[r2,#0xa]
000008  1cc2              ADDS     r2,r0,#3
00000a  1a9a              SUBS     r2,r3,r2
00000c  4b02              LDR      r3,|L73.24|
00000e  eb031301          ADD      r3,r3,r1,LSL #4
000012  815a              STRH     r2,[r3,#0xa]
;;;365    }
000014  4770              BX       lr
;;;366    
                          ENDP

000016  0000              DCW      0x0000
                  |L73.24|
                          DCD      m_pages

                          AREA ||i.write_space_reserve||, CODE, READONLY, ALIGN=2

                  write_space_reserve PROC
;;;330    // NOTE: this function takes into the account the space required for the record header.
;;;331    static ret_code_t write_space_reserve(uint16_t length_words, uint16_t * p_page)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;332    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;333        bool           space_reserved  = false;
000008  f04f0800          MOV      r8,#0
;;;334        uint16_t const total_len_words = length_words + FDS_HEADER_SIZE;
00000c  1cf8              ADDS     r0,r7,#3
00000e  b285              UXTH     r5,r0
;;;335    
;;;336        if (total_len_words >= FDS_PAGE_SIZE - FDS_PAGE_TAG_SIZE)
000010  f24030fe          MOV      r0,#0x3fe
000014  4285              CMP      r5,r0
000016  db02              BLT      |L74.30|
;;;337        {
;;;338            return FDS_ERR_RECORD_TOO_LARGE;
000018  2009              MOVS     r0,#9
                  |L74.26|
;;;339        }
;;;340    
;;;341        CRITICAL_SECTION_ENTER();
;;;342        for (uint16_t page = 0; page < FDS_DATA_PAGES; page++)
;;;343        {
;;;344            if ((m_pages[page].page_type == FDS_PAGE_DATA) &&
;;;345                (page_has_space(page, total_len_words)))
;;;346            {
;;;347                space_reserved = true;
;;;348                *p_page        = page;
;;;349    
;;;350                m_pages[page].words_reserved += total_len_words;
;;;351                break;
;;;352            }
;;;353        }
;;;354        CRITICAL_SECTION_EXIT();
;;;355    
;;;356        return (space_reserved) ? FDS_SUCCESS : FDS_ERR_NO_SPACE_IN_FLASH;
;;;357    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L74.30|
00001e  2400              MOVS     r4,#0                 ;342
000020  e018              B        |L74.84|
                  |L74.34|
000022  4811              LDR      r0,|L74.104|
000024  eb001004          ADD      r0,r0,r4,LSL #4       ;344
000028  7800              LDRB     r0,[r0,#0]            ;344
00002a  b988              CBNZ     r0,|L74.80|
00002c  4629              MOV      r1,r5                 ;345
00002e  4620              MOV      r0,r4                 ;345
000030  f7fffffe          BL       page_has_space
000034  b160              CBZ      r0,|L74.80|
000036  f04f0801          MOV      r8,#1                 ;347
00003a  8034              STRH     r4,[r6,#0]            ;348
00003c  480a              LDR      r0,|L74.104|
00003e  eb001004          ADD      r0,r0,r4,LSL #4       ;350
000042  8940              LDRH     r0,[r0,#0xa]          ;350
000044  4428              ADD      r0,r0,r5              ;350
000046  4908              LDR      r1,|L74.104|
000048  eb011104          ADD      r1,r1,r4,LSL #4       ;350
00004c  8148              STRH     r0,[r1,#0xa]          ;350
00004e  e003              B        |L74.88|
                  |L74.80|
000050  1c60              ADDS     r0,r4,#1              ;342
000052  b284              UXTH     r4,r0                 ;342
                  |L74.84|
000054  2c02              CMP      r4,#2                 ;342
000056  dbe4              BLT      |L74.34|
                  |L74.88|
000058  bf00              NOP                            ;351
00005a  f1b80f00          CMP      r8,#0                 ;356
00005e  d001              BEQ      |L74.100|
000060  2000              MOVS     r0,#0                 ;356
000062  e7da              B        |L74.26|
                  |L74.100|
000064  2007              MOVS     r0,#7                 ;356
000066  e7d8              B        |L74.26|
;;;358    
                          ENDP

                  |L74.104|
                          DCD      m_pages

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb_table
                          %        16
                  m_op_queue
                          %        120
                  m_pages
                          %        32
                  m_gc
                          %        16
                  desc
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  page_tag_swap
                          DCD      0xdeadc0de
                          DCD      0xf11e01ff
                  page_tag_data
                          DCD      0xdeadc0de
                          DCD      0xf11e01fe
                  dirty_header
                          DCD      0xffff0000

                          AREA ||.data||, DATA, ALIGN=2

                  m_flags
000000  00                DCB      0x00
                  m_users
000001  000000            DCB      0x00,0x00,0x00
                  m_latest_rec_id
                          DCD      0x00000000
                  m_swap_page
                          %        8
                  tok
                          DCD      0x00000000
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
                  page
000018  0000              DCB      0x00,0x00

                          AREA fs_data, DATA, ALIGN=2

                  m_fs
                  ||__tagsym$$used||
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      fs_event_handler
                          DCD      0x00000000
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fds\\fds.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_m_fs____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_fds_c_m_fs____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_m_fs____REVSH|
#line 402
|__asm___5_fds_c_m_fs____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_m_fs____RRX|
#line 587
|__asm___5_fds_c_m_fs____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
