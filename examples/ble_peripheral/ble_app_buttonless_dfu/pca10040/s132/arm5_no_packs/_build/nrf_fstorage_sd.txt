; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_fstorage_sd.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_fstorage_sd.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_fstorage_sd.crf ..\..\..\..\..\..\components\libraries\fstorage\nrf_fstorage_sd.c]
                          THUMB

                          AREA ||i.erase||, CODE, READONLY, ALIGN=2

                  erase PROC
;;;468    
;;;469    static ret_code_t erase(nrf_fstorage_t const * p_fs,
000000  b5f8              PUSH     {r3-r7,lr}
;;;470                            uint32_t               page_addr,
;;;471                            uint32_t               len,
;;;472                            void                 * p_param)
;;;473    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
000008  461e              MOV      r6,r3
;;;474        nrf_fstorage_sd_op_t * p_op;
;;;475    
;;;476        if (m_flags.paused)
00000a  480f              LDR      r0,|L1.72|
00000c  7880              LDRB     r0,[r0,#2]  ; m_flags
00000e  b108              CBZ      r0,|L1.20|
;;;477        {
;;;478            return NRF_ERROR_INVALID_STATE;
000010  2008              MOVS     r0,#8
                  |L1.18|
;;;479        }
;;;480    
;;;481        if (!queue_get_next_free(&p_op))
;;;482        {
;;;483            return NRF_ERROR_NO_MEM;
;;;484        }
;;;485    
;;;486        /* Initialize the operation. */
;;;487        p_op->op_code              = NRF_FSTORAGE_OP_ERASE;
;;;488        p_op->p_fs                 = p_fs;
;;;489        p_op->p_param              = p_param;
;;;490        p_op->erase.page           = (page_addr / m_flash_info.erase_unit);
;;;491        p_op->erase.pages_to_erase = len;
;;;492    
;;;493        queue_start();
;;;494    
;;;495        return NRF_SUCCESS;
;;;496    }
000012  bdf8              POP      {r3-r7,pc}
                  |L1.20|
000014  4668              MOV      r0,sp                 ;481
000016  f7fffffe          BL       queue_get_next_free
00001a  b908              CBNZ     r0,|L1.32|
00001c  2004              MOVS     r0,#4                 ;483
00001e  e7f8              B        |L1.18|
                  |L1.32|
000020  2001              MOVS     r0,#1                 ;487
000022  9900              LDR      r1,[sp,#0]            ;487
000024  7108              STRB     r0,[r1,#4]            ;487
000026  9800              LDR      r0,[sp,#0]            ;488
000028  6004              STR      r4,[r0,#0]            ;488
00002a  9800              LDR      r0,[sp,#0]            ;489
00002c  6086              STR      r6,[r0,#8]            ;489
00002e  4807              LDR      r0,|L1.76|
000030  6800              LDR      r0,[r0,#0]            ;490  ; m_flash_info
000032  fbb5f0f0          UDIV     r0,r5,r0              ;490
000036  9900              LDR      r1,[sp,#0]            ;490
000038  60c8              STR      r0,[r1,#0xc]          ;490
00003a  9800              LDR      r0,[sp,#0]            ;491
00003c  6147              STR      r7,[r0,#0x14]         ;491
00003e  f7fffffe          BL       queue_start
000042  2000              MOVS     r0,#0                 ;495
000044  e7e5              B        |L1.18|
;;;497    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      m_flags
                  |L1.76|
                          DCD      m_flash_info

                          AREA ||i.erase_execute||, CODE, READONLY, ALIGN=1

                  erase_execute PROC
;;;228    /* Erase flash page(s). */
;;;229    static uint32_t erase_execute(nrf_fstorage_sd_op_t const * p_op)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231        return sd_flash_page_erase(p_op->erase.page + p_op->erase.progress);
000004  e9d42103          LDRD     r2,r1,[r4,#0xc]
000008  1850              ADDS     r0,r2,r1
00000a  df28              SVC      #0x28
;;;232    }
00000c  bd10              POP      {r4,pc}
;;;233    
                          ENDP


                          AREA ||i.event_send||, CODE, READONLY, ALIGN=2

                  event_send PROC
;;;174    /* Sends events to the application. */
;;;175    static void event_send(nrf_fstorage_sd_op_t const * p_op, ret_code_t result)
000000  b530              PUSH     {r4,r5,lr}
;;;176    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;177        if (p_op->p_fs->evt_handler == NULL)
000008  6820              LDR      r0,[r4,#0]
00000a  6880              LDR      r0,[r0,#8]
00000c  b908              CBNZ     r0,|L3.18|
                  |L3.14|
;;;178        {
;;;179            /* Nothing to do. */
;;;180            return;
;;;181        }
;;;182    
;;;183        nrf_fstorage_evt_t evt;
;;;184        memset(&evt, 0x00, sizeof(evt));
;;;185    
;;;186        evt.result  = result;
;;;187        evt.p_param = p_op->p_param;
;;;188    
;;;189        switch (p_op->op_code)
;;;190        {
;;;191            case NRF_FSTORAGE_OP_WRITE:
;;;192                evt.id   = NRF_FSTORAGE_EVT_WRITE_RESULT;
;;;193                evt.addr = p_op->write.dest;
;;;194                evt.len  = p_op->write.len;
;;;195                break;
;;;196    
;;;197            case NRF_FSTORAGE_OP_ERASE:
;;;198                evt.id   = NRF_FSTORAGE_EVT_ERASE_RESULT;
;;;199                evt.addr = (p_op->erase.page * m_flash_info.erase_unit);
;;;200                evt.len  = p_op->erase.pages_to_erase;
;;;201                break;
;;;202    
;;;203            default:
;;;204                /* Should not happen. */
;;;205                break;
;;;206        }
;;;207    
;;;208        p_op->p_fs->evt_handler(&evt);
;;;209    }
00000e  b005              ADD      sp,sp,#0x14
000010  bd30              POP      {r4,r5,pc}
                  |L3.18|
000012  2114              MOVS     r1,#0x14              ;184
000014  4668              MOV      r0,sp                 ;184
000016  f7fffffe          BL       __aeabi_memclr4
00001a  9501              STR      r5,[sp,#4]            ;186
00001c  68a0              LDR      r0,[r4,#8]            ;187
00001e  9004              STR      r0,[sp,#0x10]         ;187
000020  7920              LDRB     r0,[r4,#4]            ;189
000022  b110              CBZ      r0,|L3.42|
000024  2801              CMP      r0,#1                 ;189
000026  d113              BNE      |L3.80|
000028  e007              B        |L3.58|
                  |L3.42|
00002a  2001              MOVS     r0,#1                 ;192
00002c  f88d0000          STRB     r0,[sp,#0]            ;192
000030  6920              LDR      r0,[r4,#0x10]         ;193
000032  9002              STR      r0,[sp,#8]            ;193
000034  6960              LDR      r0,[r4,#0x14]         ;194
000036  9003              STR      r0,[sp,#0xc]          ;194
000038  e00b              B        |L3.82|
                  |L3.58|
00003a  2002              MOVS     r0,#2                 ;198
00003c  f88d0000          STRB     r0,[sp,#0]            ;198
000040  4907              LDR      r1,|L3.96|
000042  68e0              LDR      r0,[r4,#0xc]          ;199
000044  6809              LDR      r1,[r1,#0]            ;199  ; m_flash_info
000046  4348              MULS     r0,r1,r0              ;199
000048  9002              STR      r0,[sp,#8]            ;199
00004a  6960              LDR      r0,[r4,#0x14]         ;200
00004c  9003              STR      r0,[sp,#0xc]          ;200
00004e  e000              B        |L3.82|
                  |L3.80|
000050  bf00              NOP                            ;205
                  |L3.82|
000052  bf00              NOP                            ;195
000054  6820              LDR      r0,[r4,#0]            ;208
000056  6881              LDR      r1,[r0,#8]            ;208
000058  4668              MOV      r0,sp                 ;208
00005a  4788              BLX      r1                    ;208
00005c  bf00              NOP      
00005e  e7d6              B        |L3.14|
;;;210    
                          ENDP

                  |L3.96|
                          DCD      m_flash_info

                          AREA ||i.init||, CODE, READONLY, ALIGN=2

                  init PROC
;;;397    
;;;398    static ret_code_t init(nrf_fstorage_t * p_fs, void * p_param)
000000  b570              PUSH     {r4-r6,lr}
;;;399    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;400        (void) p_param;
;;;401    
;;;402        p_fs->p_flash_info = &m_flash_info;
000006  4809              LDR      r0,|L4.44|
000008  6060              STR      r0,[r4,#4]
;;;403    
;;;404        memset(&m_flags, 0x00, sizeof(m_flags));
00000a  4809              LDR      r0,|L4.48|
00000c  2100              MOVS     r1,#0
00000e  6001              STR      r1,[r0,#0]  ; m_flags
;;;405    
;;;406        #if (defined(NRF_SDH_ENABLED) && NRF_SDH_ENABLED)
;;;407            m_flags.sd_enabled = nrf_sdh_is_enabled();
000010  f7fffffe          BL       nrf_sdh_is_enabled
000014  4906              LDR      r1,|L4.48|
000016  70c8              STRB     r0,[r1,#3]
;;;408        #endif
;;;409    
;;;410        /* Reset the queue. */
;;;411        memset(m_queue.op, 0x00, ARRAY_SIZE(m_queue.op));
000018  4806              LDR      r0,|L4.52|
00001a  2100              MOVS     r1,#0
00001c  6001              STR      r1,[r0,#0]  ; m_queue
;;;412        m_queue.rp  = 0;
00001e  2000              MOVS     r0,#0
000020  4904              LDR      r1,|L4.52|
000022  6708              STR      r0,[r1,#0x70]  ; m_queue
;;;413        m_queue.cnt = 0;
000024  6748              STR      r0,[r1,#0x74]  ; m_queue
;;;414    
;;;415        m_retry_cnt = 0;
000026  4904              LDR      r1,|L4.56|
000028  6008              STR      r0,[r1,#0]  ; m_retry_cnt
;;;416    
;;;417        return NRF_SUCCESS;
;;;418    }
00002a  bd70              POP      {r4-r6,pc}
;;;419    
                          ENDP

                  |L4.44|
                          DCD      m_flash_info
                  |L4.48|
                          DCD      m_flags
                  |L4.52|
                          DCD      m_queue
                  |L4.56|
                          DCD      m_retry_cnt

                          AREA ||i.is_busy||, CODE, READONLY, ALIGN=2

                  is_busy PROC
;;;498    
;;;499    static bool is_busy(nrf_fstorage_t const * p_fs)
000000  4601              MOV      r1,r0
;;;500    {
;;;501        return (m_queue.cnt != 0);
000002  4803              LDR      r0,|L5.16|
000004  6f40              LDR      r0,[r0,#0x74]  ; m_queue
000006  b108              CBZ      r0,|L5.12|
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;502    }
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;501
00000e  e7fc              B        |L5.10|
;;;503    
                          ENDP

                  |L5.16|
                          DCD      m_queue

                          AREA ||i.nrf_fstorage_sdh_req_handler||, CODE, READONLY, ALIGN=2

                  nrf_fstorage_sdh_req_handler PROC
;;;561    
;;;562    bool nrf_fstorage_sdh_req_handler(nrf_sdh_req_evt_t req, void * p_context)
000000  4602              MOV      r2,r0
;;;563    {
;;;564        switch (req)
000002  b112              CBZ      r2,|L6.10|
000004  2a01              CMP      r2,#1
000006  d10d              BNE      |L6.36|
000008  e000              B        |L6.12|
                  |L6.10|
;;;565        {
;;;566            case NRF_SDH_EVT_ENABLE_REQUEST:
;;;567            case NRF_SDH_EVT_DISABLE_REQUEST:
00000a  bf00              NOP      
                  |L6.12|
;;;568            {
;;;569                m_flags.paused = true;
00000c  2001              MOVS     r0,#1
00000e  4b07              LDR      r3,|L6.44|
000010  7098              STRB     r0,[r3,#2]
;;;570    
;;;571                /* If there are any operations ongoing, pause the SoftDevice state change.
;;;572                 * Otherwise, go through with it. */
;;;573                if (m_flags.flash_operation_ongoing || m_flags.flash_operation_pending)
000012  4618              MOV      r0,r3
000014  7800              LDRB     r0,[r0,#0]  ; m_flags
000016  b910              CBNZ     r0,|L6.30|
000018  4618              MOV      r0,r3
00001a  7840              LDRB     r0,[r0,#1]  ; m_flags
00001c  b108              CBZ      r0,|L6.34|
                  |L6.30|
;;;574                {
;;;575                    return false;
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;576                }
;;;577            } break;
;;;578    
;;;579            default:
;;;580                break;
;;;581        }
;;;582    
;;;583        return true;
;;;584    }
000020  4770              BX       lr
                  |L6.34|
000022  e000              B        |L6.38|
                  |L6.36|
000024  bf00              NOP                            ;580
                  |L6.38|
000026  bf00              NOP                            ;577
000028  2001              MOVS     r0,#1                 ;583
00002a  e7f9              B        |L6.32|
;;;585    
                          ENDP

                  |L6.44|
                          DCD      m_flags

                          AREA ||i.nrf_fstorage_sdh_state_handler||, CODE, READONLY, ALIGN=2

                  nrf_fstorage_sdh_state_handler PROC
;;;586    
;;;587    void nrf_fstorage_sdh_state_handler(nrf_sdh_state_evt_t state, void * p_context)
000000  b570              PUSH     {r4-r6,lr}
;;;588    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;589        switch (state)
000006  2c01              CMP      r4,#1
000008  d002              BEQ      |L7.16|
00000a  2c03              CMP      r4,#3
00000c  d10e              BNE      |L7.44|
00000e  e000              B        |L7.18|
                  |L7.16|
;;;590        {
;;;591            case NRF_SDH_EVT_STATE_ENABLED:
;;;592                /* Fallthrough. */
;;;593            case NRF_SDH_EVT_STATE_DISABLED:
000010  bf00              NOP      
                  |L7.18|
;;;594            {
;;;595                m_flags.paused     = false;
000012  2000              MOVS     r0,#0
000014  4907              LDR      r1,|L7.52|
000016  7088              STRB     r0,[r1,#2]
;;;596                m_flags.sd_enabled = (state == NRF_SDH_EVT_STATE_ENABLED);
000018  2c01              CMP      r4,#1
00001a  d101              BNE      |L7.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L7.34|
                  |L7.32|
000020  2000              MOVS     r0,#0
                  |L7.34|
000022  4904              LDR      r1,|L7.52|
000024  70c8              STRB     r0,[r1,#3]
;;;597                // Execute any operations still in the queue.
;;;598                queue_process();
000026  f7fffffe          BL       queue_process
;;;599            } break;
00002a  e000              B        |L7.46|
                  |L7.44|
;;;600    
;;;601            default:
;;;602                break;
00002c  bf00              NOP      
                  |L7.46|
00002e  bf00              NOP                            ;599
;;;603        }
;;;604    }
000030  bd70              POP      {r4-r6,pc}
;;;605    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      m_flags

                          AREA ||i.nrf_fstorage_sys_evt_handler||, CODE, READONLY, ALIGN=2

                  nrf_fstorage_sys_evt_handler PROC
;;;504    
;;;505    void nrf_fstorage_sys_evt_handler(uint32_t sys_evt, void * p_context)
000000  b5f0              PUSH     {r4-r7,lr}
;;;506    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;507        (void) p_context;
;;;508    
;;;509        if (m_flags.flash_operation_ongoing)
000008  481f              LDR      r0,|L8.136|
00000a  7800              LDRB     r0,[r0,#0]  ; m_flags
00000c  b360              CBZ      r0,|L8.104|
;;;510        {
;;;511            /* Handle the result of a flash operation initiated by this module. */
;;;512            bool operation_finished = false;
00000e  2600              MOVS     r6,#0
;;;513            nrf_fstorage_sd_op_t * p_op = &m_queue.op[m_queue.rp];
000010  481e              LDR      r0,|L8.140|
000012  6f00              LDR      r0,[r0,#0x70]  ; m_queue
000014  ebc000c0          RSB      r0,r0,r0,LSL #3
000018  491c              LDR      r1,|L8.140|
00001a  eb010580          ADD      r5,r1,r0,LSL #2
;;;514    
;;;515            switch (sys_evt)
00001e  2c02              CMP      r4,#2
000020  d002              BEQ      |L8.40|
000022  2c03              CMP      r4,#3
000024  d10a              BNE      |L8.60|
000026  e004              B        |L8.50|
                  |L8.40|
;;;516            {
;;;517                case NRF_EVT_FLASH_OPERATION_SUCCESS:
;;;518                    operation_finished = on_operation_success(p_op);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       on_operation_success
00002e  4606              MOV      r6,r0
;;;519                    break;
000030  e004              B        |L8.60|
                  |L8.50|
;;;520    
;;;521                case NRF_EVT_FLASH_OPERATION_ERROR:
;;;522                    operation_finished = on_operation_failure(p_op);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       on_operation_failure
000038  4606              MOV      r6,r0
;;;523                    break;
00003a  bf00              NOP      
                  |L8.60|
00003c  bf00              NOP                            ;519
;;;524            }
;;;525    
;;;526            if (operation_finished)
00003e  b196              CBZ      r6,|L8.102|
;;;527            {
;;;528                nrf_fstorage_sd_op_t op;
;;;529    
;;;530                /* Copy the current operation, to allow the queue element to be re-used. */
;;;531                memcpy(&op, p_op, sizeof(op));
000040  221c              MOVS     r2,#0x1c
000042  4629              MOV      r1,r5
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       __aeabi_memcpy4
;;;532                /* Free the queue element, so that new operations can be queued.*/
;;;533                queue_advance();
00004a  f7fffffe          BL       queue_advance
;;;534    
;;;535                m_flags.flash_operation_ongoing = false;
00004e  2000              MOVS     r0,#0
000050  490d              LDR      r1,|L8.136|
000052  7008              STRB     r0,[r1,#0]
;;;536    
;;;537                event_send(&op, (sys_evt == NRF_EVT_FLASH_OPERATION_SUCCESS) ?
000054  2c02              CMP      r4,#2
000056  d100              BNE      |L8.90|
;;;538                                NRF_SUCCESS : NRF_ERROR_TIMEOUT);
000058  e000              B        |L8.92|
                  |L8.90|
00005a  200d              MOVS     r0,#0xd
                  |L8.92|
00005c  4601              MOV      r1,r0
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       event_send
;;;539            }
000064  bf00              NOP      
                  |L8.102|
;;;540        }
000066  e005              B        |L8.116|
                  |L8.104|
;;;541        else if (m_flags.flash_operation_pending)
000068  4807              LDR      r0,|L8.136|
00006a  7840              LDRB     r0,[r0,#1]  ; m_flags
00006c  b110              CBZ      r0,|L8.116|
;;;542        {
;;;543            /* A flash operation was initiated outside this module.
;;;544             * A callback which indicates that it has finished was received. */
;;;545            m_flags.flash_operation_pending = false;
00006e  2000              MOVS     r0,#0
000070  4905              LDR      r1,|L8.136|
000072  7048              STRB     r0,[r1,#1]
                  |L8.116|
;;;546        }
;;;547    
;;;548        if (!m_flags.paused)
000074  4804              LDR      r0,|L8.136|
000076  7880              LDRB     r0,[r0,#2]  ; m_flags
000078  b910              CBNZ     r0,|L8.128|
;;;549        {
;;;550            /* Resume processing the queue, if necessary. */
;;;551            queue_process();
00007a  f7fffffe          BL       queue_process
00007e  e001              B        |L8.132|
                  |L8.128|
;;;552        }
;;;553        else
;;;554        {
;;;555            /* Flash operation has completed.
;;;556             * Allow the SoftDevice to change state. */
;;;557             (void) nrf_sdh_request_continue();
000080  f7fffffe          BL       nrf_sdh_request_continue
                  |L8.132|
;;;558        }
;;;559    }
000084  b007              ADD      sp,sp,#0x1c
000086  bdf0              POP      {r4-r7,pc}
;;;560    
                          ENDP

                  |L8.136|
                          DCD      m_flags
                  |L8.140|
                          DCD      m_queue

                          AREA ||i.on_operation_failure||, CODE, READONLY, ALIGN=2

                  on_operation_failure PROC
;;;362     * been reached, send an event and advance the queue. */
;;;363    static bool on_operation_failure(nrf_fstorage_sd_op_t const * p_op)
000000  4601              MOV      r1,r0
;;;364    {
;;;365        if (++m_retry_cnt > NRF_FSTORAGE_SD_MAX_RETRIES)
000002  4806              LDR      r0,|L9.28|
000004  6800              LDR      r0,[r0,#0]  ; m_retry_cnt
000006  1c40              ADDS     r0,r0,#1
000008  4a04              LDR      r2,|L9.28|
00000a  6010              STR      r0,[r2,#0]  ; m_retry_cnt
00000c  2808              CMP      r0,#8
00000e  d903              BLS      |L9.24|
;;;366        {
;;;367            m_retry_cnt = 0;
000010  2000              MOVS     r0,#0
000012  6010              STR      r0,[r2,#0]  ; m_retry_cnt
;;;368            return true;
000014  2001              MOVS     r0,#1
                  |L9.22|
;;;369        }
;;;370    
;;;371        return false;
;;;372    }
000016  4770              BX       lr
                  |L9.24|
000018  2000              MOVS     r0,#0                 ;371
00001a  e7fc              B        |L9.22|
;;;373    
                          ENDP

                  |L9.28|
                          DCD      m_retry_cnt

                          AREA ||i.on_operation_success||, CODE, READONLY, ALIGN=2

                  on_operation_success PROC
;;;317     * If it has finished, advance the queue and send an event. */
;;;318    static bool on_operation_success(nrf_fstorage_sd_op_t * p_op)
000000  4601              MOV      r1,r0
;;;319    {
;;;320        /* Reset the retry counter on success. */
;;;321        m_retry_cnt = 0;
000002  2000              MOVS     r0,#0
000004  4a15              LDR      r2,|L10.92|
000006  6010              STR      r0,[r2,#0]  ; m_retry_cnt
;;;322    
;;;323        switch (p_op->op_code)
000008  7908              LDRB     r0,[r1,#4]
00000a  b110              CBZ      r0,|L10.18|
00000c  2801              CMP      r0,#1
00000e  d121              BNE      |L10.84|
000010  e016              B        |L10.64|
                  |L10.18|
;;;324        {
;;;325            case NRF_FSTORAGE_OP_WRITE:
;;;326            {
;;;327                /* The offset is updated only if the operation is successful
;;;328                 * so that it can be retried in case it times out instead. */
;;;329                uint32_t const chunk_len = MIN(p_op->write.len - p_op->write.offset,
000012  e9d13005          LDRD     r3,r0,[r1,#0x14]
000016  1a18              SUBS     r0,r3,r0
000018  f5b05f80          CMP      r0,#0x1000
00001c  d203              BCS      |L10.38|
00001e  e9d13005          LDRD     r3,r0,[r1,#0x14]
000022  1a18              SUBS     r0,r3,r0
000024  e001              B        |L10.42|
                  |L10.38|
000026  f44f5080          MOV      r0,#0x1000
                  |L10.42|
00002a  4602              MOV      r2,r0
;;;330                                               NRF_FSTORAGE_SD_MAX_WRITE_SIZE);
;;;331    
;;;332                p_op->write.offset += chunk_len;
00002c  6988              LDR      r0,[r1,#0x18]
00002e  1883              ADDS     r3,r0,r2
000030  618b              STR      r3,[r1,#0x18]
;;;333    
;;;334                if (p_op->write.offset == p_op->write.len)
000032  e9d10305          LDRD     r0,r3,[r1,#0x14]
000036  4283              CMP      r3,r0
000038  d101              BNE      |L10.62|
;;;335                {
;;;336                    return true;
00003a  2001              MOVS     r0,#1
                  |L10.60|
;;;337                }
;;;338            }
;;;339            break;
;;;340    
;;;341            case NRF_FSTORAGE_OP_ERASE:
;;;342            {
;;;343                p_op->erase.progress++;
;;;344    
;;;345                if (p_op->erase.progress == p_op->erase.pages_to_erase)
;;;346                {
;;;347                    return true;
;;;348                }
;;;349            }
;;;350            break;
;;;351    
;;;352            default:
;;;353                /* Should not happen. */
;;;354                break;
;;;355        }
;;;356    
;;;357        return false;
;;;358    }
00003c  4770              BX       lr
                  |L10.62|
00003e  e00a              B        |L10.86|
                  |L10.64|
000040  6908              LDR      r0,[r1,#0x10]         ;343
000042  1c40              ADDS     r0,r0,#1              ;343
000044  6108              STR      r0,[r1,#0x10]         ;343
000046  e9d12004          LDRD     r2,r0,[r1,#0x10]      ;345
00004a  4282              CMP      r2,r0                 ;345
00004c  d101              BNE      |L10.82|
00004e  2001              MOVS     r0,#1                 ;347
000050  e7f4              B        |L10.60|
                  |L10.82|
000052  e000              B        |L10.86|
                  |L10.84|
000054  bf00              NOP                            ;354
                  |L10.86|
000056  bf00              NOP                            ;339
000058  2000              MOVS     r0,#0                 ;357
00005a  e7ef              B        |L10.60|
;;;359    
                          ENDP

                  |L10.92|
                          DCD      m_retry_cnt

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;235    /* Advance the queue, wrapping around if necessary. */
;;;236    static void queue_advance()
000000  4807              LDR      r0,|L11.32|
;;;237    {
;;;238        m_queue.cnt--;
000002  6f40              LDR      r0,[r0,#0x74]  ; m_queue
000004  1e40              SUBS     r0,r0,#1
000006  4906              LDR      r1,|L11.32|
000008  6748              STR      r0,[r1,#0x74]  ; m_queue
;;;239        m_queue.rp++;
00000a  4608              MOV      r0,r1
00000c  6f00              LDR      r0,[r0,#0x70]  ; m_queue
00000e  1c40              ADDS     r0,r0,#1
000010  6708              STR      r0,[r1,#0x70]  ; m_queue
;;;240    
;;;241        if (m_queue.rp == NRF_FSTORAGE_SD_QUEUE_SIZE)
000012  4608              MOV      r0,r1
000014  6f00              LDR      r0,[r0,#0x70]  ; m_queue
000016  2804              CMP      r0,#4
000018  d101              BNE      |L11.30|
;;;242        {
;;;243            m_queue.rp = 0;
00001a  2000              MOVS     r0,#0
00001c  6708              STR      r0,[r1,#0x70]  ; m_queue
                  |L11.30|
;;;244        }
;;;245    }
00001e  4770              BX       lr
;;;246    
                          ENDP

                  |L11.32|
                          DCD      m_queue

                          AREA ||i.queue_get_next_free||, CODE, READONLY, ALIGN=2

                  queue_get_next_free PROC
;;;375    /* Retrieves a pointer to the next free element in the queue. */
;;;376    static bool queue_get_next_free(nrf_fstorage_sd_op_t ** p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;377    {
000002  4604              MOV      r4,r0
;;;378        uint32_t idx;
;;;379    
;;;380        if (m_queue.cnt == NRF_FSTORAGE_SD_QUEUE_SIZE)
000004  4817              LDR      r0,|L12.100|
000006  6f40              LDR      r0,[r0,#0x74]  ; m_queue
000008  2804              CMP      r0,#4
00000a  d101              BNE      |L12.16|
;;;381        {
;;;382            return false;
00000c  2000              MOVS     r0,#0
                  |L12.14|
;;;383        }
;;;384    
;;;385        idx = ((m_queue.rp + m_queue.cnt) < NRF_FSTORAGE_SD_QUEUE_SIZE) ?
;;;386               (m_queue.rp + m_queue.cnt) :
;;;387               (m_queue.rp + m_queue.cnt) - NRF_FSTORAGE_SD_QUEUE_SIZE;
;;;388    
;;;389        m_queue.cnt++;
;;;390    
;;;391        memset((void*)&m_queue.op[idx], 0x00, sizeof(nrf_fstorage_sd_op_t));
;;;392        *p_op = &m_queue.op[idx];
;;;393    
;;;394        return true;
;;;395    }
00000e  bd70              POP      {r4-r6,pc}
                  |L12.16|
000010  4814              LDR      r0,|L12.100|
000012  6f00              LDR      r0,[r0,#0x70]         ;385  ; m_queue
000014  4913              LDR      r1,|L12.100|
000016  6f49              LDR      r1,[r1,#0x74]         ;385  ; m_queue
000018  4408              ADD      r0,r0,r1              ;385
00001a  2804              CMP      r0,#4                 ;385
00001c  d205              BCS      |L12.42|
00001e  4811              LDR      r0,|L12.100|
000020  6f00              LDR      r0,[r0,#0x70]         ;386  ; m_queue
000022  4910              LDR      r1,|L12.100|
000024  6f49              LDR      r1,[r1,#0x74]         ;386  ; m_queue
000026  4408              ADD      r0,r0,r1              ;386
000028  e005              B        |L12.54|
                  |L12.42|
00002a  480e              LDR      r0,|L12.100|
00002c  6f00              LDR      r0,[r0,#0x70]         ;387  ; m_queue
00002e  490d              LDR      r1,|L12.100|
000030  6f49              LDR      r1,[r1,#0x74]         ;387  ; m_queue
000032  4408              ADD      r0,r0,r1              ;387
000034  1f00              SUBS     r0,r0,#4              ;387
                  |L12.54|
000036  4605              MOV      r5,r0                 ;387
000038  480a              LDR      r0,|L12.100|
00003a  6f40              LDR      r0,[r0,#0x74]         ;389  ; m_queue
00003c  1c40              ADDS     r0,r0,#1              ;389
00003e  4909              LDR      r1,|L12.100|
000040  6748              STR      r0,[r1,#0x74]         ;389  ; m_queue
000042  ebc501c5          RSB      r1,r5,r5,LSL #3       ;391
000046  4a07              LDR      r2,|L12.100|
000048  eb020081          ADD      r0,r2,r1,LSL #2       ;391
00004c  211c              MOVS     r1,#0x1c              ;391
00004e  f7fffffe          BL       __aeabi_memclr4
000052  ebc500c5          RSB      r0,r5,r5,LSL #3       ;392
000056  4903              LDR      r1,|L12.100|
000058  eb010080          ADD      r0,r1,r0,LSL #2       ;392
00005c  6020              STR      r0,[r4,#0]            ;392
00005e  2001              MOVS     r0,#1                 ;394
000060  e7d5              B        |L12.14|
;;;396    
                          ENDP

000062  0000              DCW      0x0000
                  |L12.100|
                          DCD      m_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;248    /* Execute the current operation in the queue. */
;;;249    static void queue_process()
000000  b570              PUSH     {r4-r6,lr}
;;;250    {
;;;251        if (m_queue.cnt == 0)
000002  481c              LDR      r0,|L13.116|
000004  6f40              LDR      r0,[r0,#0x74]  ; m_queue
000006  b900              CBNZ     r0,|L13.10|
                  |L13.8|
;;;252        {
;;;253            /* Nothing to do. */
;;;254            return;
;;;255        }
;;;256    
;;;257        /* Get the current operation from the queue and execute it. */
;;;258        nrf_fstorage_sd_op_t * const p_op = &m_queue.op[m_queue.rp];
;;;259        m_flags.flash_operation_ongoing = true;
;;;260    
;;;261        uint32_t rc;
;;;262        switch (p_op->op_code)
;;;263        {
;;;264            case NRF_FSTORAGE_OP_WRITE:
;;;265                rc = write_execute(p_op);
;;;266                break;
;;;267    
;;;268            case NRF_FSTORAGE_OP_ERASE:
;;;269                rc = erase_execute(p_op);
;;;270                break;
;;;271    
;;;272             default:
;;;273                rc = NRF_ERROR_INTERNAL;
;;;274                break;
;;;275        }
;;;276    
;;;277        switch (rc)
;;;278        {
;;;279            case NRF_ERROR_BUSY:
;;;280                /* There is a pending flash operation which was not initiated by this module.
;;;281                 * Stop processing the queue until a system event is received. */
;;;282                m_flags.flash_operation_ongoing = false;
;;;283                m_flags.flash_operation_pending = true;
;;;284                break;
;;;285    
;;;286            case NRF_SUCCESS:
;;;287                /* The operation was accepted by the SoftDevice.
;;;288                 * If the SOftDevice is enabled, wait for a system event.
;;;289                 * Otherwise, the SoftDevice call is synchronous and will not send an event. */
;;;290                if (!m_flags.sd_enabled)
;;;291                {
;;;292                    nrf_fstorage_sys_evt_handler(NRF_EVT_FLASH_OPERATION_SUCCESS, NULL);
;;;293                }
;;;294                break;
;;;295    
;;;296            default:
;;;297                /* Another error has occurred. */
;;;298                event_send(p_op, NRF_ERROR_INTERNAL);
;;;299                break;
;;;300        }
;;;301    }
000008  bd70              POP      {r4-r6,pc}
                  |L13.10|
00000a  481a              LDR      r0,|L13.116|
00000c  6f00              LDR      r0,[r0,#0x70]         ;258  ; m_queue
00000e  ebc000c0          RSB      r0,r0,r0,LSL #3       ;258
000012  4918              LDR      r1,|L13.116|
000014  eb010580          ADD      r5,r1,r0,LSL #2       ;258
000018  2001              MOVS     r0,#1                 ;259
00001a  4917              LDR      r1,|L13.120|
00001c  7008              STRB     r0,[r1,#0]            ;259
00001e  7928              LDRB     r0,[r5,#4]            ;262
000020  b110              CBZ      r0,|L13.40|
000022  2801              CMP      r0,#1                 ;262
000024  d10a              BNE      |L13.60|
000026  e004              B        |L13.50|
                  |L13.40|
000028  4628              MOV      r0,r5                 ;265
00002a  f7fffffe          BL       write_execute
00002e  4604              MOV      r4,r0                 ;265
000030  e006              B        |L13.64|
                  |L13.50|
000032  4628              MOV      r0,r5                 ;269
000034  f7fffffe          BL       erase_execute
000038  4604              MOV      r4,r0                 ;269
00003a  e001              B        |L13.64|
                  |L13.60|
00003c  2403              MOVS     r4,#3                 ;273
00003e  bf00              NOP                            ;274
                  |L13.64|
000040  bf00              NOP                            ;266
000042  b13c              CBZ      r4,|L13.84|
000044  2c11              CMP      r4,#0x11              ;277
000046  d10d              BNE      |L13.100|
000048  2000              MOVS     r0,#0                 ;282
00004a  490b              LDR      r1,|L13.120|
00004c  7008              STRB     r0,[r1,#0]            ;282
00004e  2001              MOVS     r0,#1                 ;283
000050  7048              STRB     r0,[r1,#1]            ;283
000052  e00c              B        |L13.110|
                  |L13.84|
000054  4808              LDR      r0,|L13.120|
000056  78c0              LDRB     r0,[r0,#3]            ;290  ; m_flags
000058  b918              CBNZ     r0,|L13.98|
00005a  2100              MOVS     r1,#0                 ;292
00005c  2002              MOVS     r0,#2                 ;292
00005e  f7fffffe          BL       nrf_fstorage_sys_evt_handler
                  |L13.98|
000062  e004              B        |L13.110|
                  |L13.100|
000064  2103              MOVS     r1,#3                 ;298
000066  4628              MOV      r0,r5                 ;298
000068  f7fffffe          BL       event_send
00006c  bf00              NOP                            ;299
                  |L13.110|
00006e  bf00              NOP                            ;284
000070  bf00              NOP      
000072  e7c9              B        |L13.8|
;;;302    
                          ENDP

                  |L13.116|
                          DCD      m_queue
                  |L13.120|
                          DCD      m_flags

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=2

                  queue_start PROC
;;;305     * both inside and outside this module. */
;;;306    static void queue_start()
000000  b510              PUSH     {r4,lr}
;;;307    {
;;;308        if ((!m_flags.flash_operation_ongoing) &&
000002  4804              LDR      r0,|L14.20|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  b920              CBNZ     r0,|L14.18|
;;;309            (!m_flags.flash_operation_pending))
000008  4802              LDR      r0,|L14.20|
00000a  7840              LDRB     r0,[r0,#1]  ; m_flags
00000c  b908              CBNZ     r0,|L14.18|
;;;310        {
;;;311            queue_process();
00000e  f7fffffe          BL       queue_process
                  |L14.18|
;;;312        }
;;;313    }
000012  bd10              POP      {r4,pc}
;;;314    
                          ENDP

                  |L14.20|
                          DCD      m_flags

                          AREA ||i.read||, CODE, READONLY, ALIGN=1

                  read PROC
;;;460    
;;;461    static ret_code_t read(nrf_fstorage_t const * p_fs, uint32_t src, void * p_dest, uint32_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;462    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;463        memcpy(p_dest, (uint32_t*)src, len);
00000c  462a              MOV      r2,r5
00000e  4631              MOV      r1,r6
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       __aeabi_memcpy
;;;464    
;;;465        return NRF_SUCCESS;
000016  2000              MOVS     r0,#0
;;;466    }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;467    
                          ENDP


                          AREA ||i.uninit||, CODE, READONLY, ALIGN=1

                  uninit PROC
;;;420    
;;;421    static ret_code_t uninit(nrf_fstorage_t * p_fs, void * p_param)
000000  4602              MOV      r2,r0
;;;422    {
;;;423        (void) p_param;
;;;424    
;;;425        /* The state is re-initialized upon init().
;;;426         * The common uninitialization code is run by the caller.
;;;427         * Nothing to do.
;;;428         */
;;;429    
;;;430        return NRF_SUCCESS;
000002  2000              MOVS     r0,#0
;;;431    }
000004  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.write||, CODE, READONLY, ALIGN=1

                  write PROC
;;;433    
;;;434    static ret_code_t write(nrf_fstorage_t const * p_fs,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;435                            uint32_t               dest,
;;;436                            void           const * p_src,
;;;437                            uint32_t               len,
;;;438                            void                 * p_param)
;;;439    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;440        nrf_fstorage_sd_op_t * p_op;
;;;441    
;;;442        if (!queue_get_next_free(&p_op))
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       queue_get_next_free
000016  b910              CBNZ     r0,|L17.30|
;;;443        {
;;;444            return NRF_ERROR_NO_MEM;
000018  2004              MOVS     r0,#4
                  |L17.26|
;;;445        }
;;;446    
;;;447        /* Initialize the operation. */
;;;448        p_op->op_code     = NRF_FSTORAGE_OP_WRITE;
;;;449        p_op->p_fs        = p_fs;
;;;450        p_op->p_param     = p_param;
;;;451        p_op->write.dest  = dest;
;;;452        p_op->write.p_src = p_src;
;;;453        p_op->write.len   = len;
;;;454    
;;;455        queue_start();
;;;456    
;;;457        return NRF_SUCCESS;
;;;458    }
00001a  e8bd83f8          POP      {r3-r9,pc}
                  |L17.30|
00001e  2000              MOVS     r0,#0                 ;448
000020  9900              LDR      r1,[sp,#0]            ;448
000022  7108              STRB     r0,[r1,#4]            ;448
000024  9800              LDR      r0,[sp,#0]            ;449
000026  6004              STR      r4,[r0,#0]            ;449
000028  9800              LDR      r0,[sp,#0]            ;450
00002a  f8c08008          STR      r8,[r0,#8]            ;450
00002e  9800              LDR      r0,[sp,#0]            ;451
000030  6105              STR      r5,[r0,#0x10]         ;451
000032  9800              LDR      r0,[sp,#0]            ;452
000034  60c6              STR      r6,[r0,#0xc]          ;452
000036  9800              LDR      r0,[sp,#0]            ;453
000038  6147              STR      r7,[r0,#0x14]         ;453
00003a  f7fffffe          BL       queue_start
00003e  2000              MOVS     r0,#0                 ;457
000040  e7eb              B        |L17.26|
;;;459    
                          ENDP


                          AREA ||i.write_execute||, CODE, READONLY, ALIGN=2

                  write_execute PROC
;;;212    /* Write to flash. */
;;;213    static uint32_t write_execute(nrf_fstorage_sd_op_t const * p_op)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;214    {
000004  4604              MOV      r4,r0
;;;215        uint32_t chunk_len;
;;;216    
;;;217        chunk_len = MIN(p_op->write.len - p_op->write.offset, NRF_FSTORAGE_SD_MAX_WRITE_SIZE);
000006  e9d41005          LDRD     r1,r0,[r4,#0x14]
00000a  1a08              SUBS     r0,r1,r0
00000c  f5b05f80          CMP      r0,#0x1000
000010  d203              BCS      |L18.26|
000012  e9d41005          LDRD     r1,r0,[r4,#0x14]
000016  1a08              SUBS     r0,r1,r0
000018  e001              B        |L18.30|
                  |L18.26|
00001a  f44f5080          MOV      r0,#0x1000
                  |L18.30|
00001e  4605              MOV      r5,r0
;;;218        chunk_len = MAX(1, chunk_len / m_flash_info.program_unit);
000020  480c              LDR      r0,|L18.84|
000022  6840              LDR      r0,[r0,#4]  ; m_flash_info
000024  fbb5f0f0          UDIV     r0,r5,r0
000028  2801              CMP      r0,#1
00002a  d904              BLS      |L18.54|
00002c  4809              LDR      r0,|L18.84|
00002e  6840              LDR      r0,[r0,#4]  ; m_flash_info
000030  fbb5f0f0          UDIV     r0,r5,r0
000034  e000              B        |L18.56|
                  |L18.54|
000036  2001              MOVS     r0,#1
                  |L18.56|
000038  4605              MOV      r5,r0
;;;219    
;;;220        /* Cast to p_src to uint32_t to perform arithmetic. */
;;;221        uint32_t       * p_dest = (uint32_t*)(p_op->write.dest + p_op->write.offset);
00003a  6921              LDR      r1,[r4,#0x10]
00003c  69a0              LDR      r0,[r4,#0x18]
00003e  180e              ADDS     r6,r1,r0
;;;222        uint32_t const * p_src  = (uint32_t*)((uint32_t)p_op->write.p_src + p_op->write.offset);
000040  68e1              LDR      r1,[r4,#0xc]
000042  69a0              LDR      r0,[r4,#0x18]
000044  180f              ADDS     r7,r1,r0
;;;223    
;;;224        return sd_flash_write(p_dest, p_src, chunk_len);
000046  462a              MOV      r2,r5
000048  4639              MOV      r1,r7
00004a  4630              MOV      r0,r6
00004c  df29              SVC      #0x29
;;;225    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;226    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      m_flash_info

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_queue
                          %        120

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_flash_info
                          DCD      0x00001000
                          DCD      0x00000004
                  nrf_fstorage_sd
                          DCD      init
                          DCD      uninit
                          DCD      read
                          DCD      write
                          DCD      erase
                          DCD      is_busy

                          AREA ||.data||, DATA, ALIGN=2

                  m_flags
                          DCD      0x00000000
                  m_retry_cnt
                          DCD      0x00000000

                          AREA sdh_req_observers0, DATA, READONLY, ALIGN=2

                  m_req_obs
                  ||__tagsym$$used||
                          DCD      nrf_fstorage_sdh_req_handler
                          DCD      0x00000000

                          AREA sdh_soc_observers0, DATA, READONLY, ALIGN=2

                  m_sys_obs
                  |symbol_number.159|
                          DCD      nrf_fstorage_sys_evt_handler
                          DCD      0x00000000

                          AREA sdh_state_observers0, DATA, READONLY, ALIGN=2

                  m_state_obs
                  |symbol_number.161|
                          DCD      nrf_fstorage_sdh_state_handler
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fstorage\\nrf_fstorage_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_nrf_fstorage_sd_c_6e7dbfe9____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_nrf_fstorage_sd_c_6e7dbfe9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_nrf_fstorage_sd_c_6e7dbfe9____REVSH|
#line 402
|__asm___17_nrf_fstorage_sd_c_6e7dbfe9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_nrf_fstorage_sd_c_6e7dbfe9____RRX|
#line 587
|__asm___17_nrf_fstorage_sd_c_6e7dbfe9____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
