; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\ble_advdata.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\ble_advdata.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\ble_advdata.crf ..\..\..\..\..\..\components\ble\common\ble_advdata.c]
                          THUMB

                          AREA ||i.advdata_check||, CODE, READONLY, ALIGN=1

                  advdata_check PROC
;;;634    
;;;635    static uint32_t advdata_check(const ble_advdata_t * p_advdata)
000000  4601              MOV      r1,r0
;;;636    {
;;;637        // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
;;;638        if (
000002  78c8              LDRB     r0,[r1,#3]
000004  f0000004          AND      r0,r0,#4
000008  b908              CBNZ     r0,|L1.14|
;;;639            ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
;;;640           )
;;;641        {
;;;642            return NRF_ERROR_INVALID_PARAM;
00000a  2007              MOVS     r0,#7
                  |L1.12|
;;;643        }
;;;644    
;;;645        return NRF_SUCCESS;
;;;646    }
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0                 ;645
000010  e7fc              B        |L1.12|
;;;647    
                          ENDP


                          AREA ||i.appearance_encode||, CODE, READONLY, ALIGN=1

                  appearance_encode PROC
;;;192    
;;;193    static uint32_t appearance_encode(uint8_t  * p_encoded_data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;194                                      uint16_t * p_offset,
;;;195                                      uint16_t   max_size)
;;;196    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;197        uint32_t err_code;
;;;198        uint16_t appearance;
;;;199    
;;;200        // Check for buffer overflow.
;;;201        if (((*p_offset) + AD_TYPE_APPEARANCE_SIZE) > max_size)
000008  8820              LDRH     r0,[r4,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  42b8              CMP      r0,r7
00000e  d901              BLS      |L2.20|
;;;202        {
;;;203            return NRF_ERROR_DATA_SIZE;
000010  200c              MOVS     r0,#0xc
                  |L2.18|
;;;204        }
;;;205    
;;;206        // Get GAP appearance field.
;;;207        err_code = sd_ble_gap_appearance_get(&appearance);
;;;208        VERIFY_SUCCESS(err_code);
;;;209    
;;;210        // Encode Length, AD Type and Appearance.
;;;211        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_APPEARANCE_DATA_SIZE);
;;;212        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;213        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_APPEARANCE;
;;;214        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;215        *p_offset                 += uint16_encode(appearance, &p_encoded_data[*p_offset]);
;;;216    
;;;217        return NRF_SUCCESS;
;;;218    }
000012  bdf8              POP      {r3-r7,pc}
                  |L2.20|
000014  4668              MOV      r0,sp                 ;207
000016  df79              SVC      #0x79                 ;207
000018  4606              MOV      r6,r0                 ;207
00001a  bf00              NOP                            ;208
00001c  b10e              CBZ      r6,|L2.34|
00001e  4630              MOV      r0,r6                 ;208
000020  e7f7              B        |L2.18|
                  |L2.34|
000022  bf00              NOP                            ;208
000024  2003              MOVS     r0,#3                 ;211
000026  8821              LDRH     r1,[r4,#0]            ;211
000028  5468              STRB     r0,[r5,r1]            ;211
00002a  8820              LDRH     r0,[r4,#0]            ;212
00002c  1c40              ADDS     r0,r0,#1              ;212
00002e  8020              STRH     r0,[r4,#0]            ;212
000030  2019              MOVS     r0,#0x19              ;213
000032  8821              LDRH     r1,[r4,#0]            ;213
000034  5468              STRB     r0,[r5,r1]            ;213
000036  8820              LDRH     r0,[r4,#0]            ;214
000038  1c40              ADDS     r0,r0,#1              ;214
00003a  8020              STRH     r0,[r4,#0]            ;214
00003c  8820              LDRH     r0,[r4,#0]            ;215
00003e  1941              ADDS     r1,r0,r5              ;215
000040  f8bd0000          LDRH     r0,[sp,#0]            ;215
000044  f7fffffe          BL       uint16_encode
000048  8821              LDRH     r1,[r4,#0]            ;215
00004a  4408              ADD      r0,r0,r1              ;215
00004c  8020              STRH     r0,[r4,#0]            ;215
00004e  2000              MOVS     r0,#0                 ;217
000050  e7df              B        |L2.18|
;;;219    
                          ENDP


                          AREA ||i.ble_advdata_encode||, CODE, READONLY, ALIGN=1

                  ble_advdata_encode PROC
;;;524    
;;;525    uint32_t ble_advdata_encode(ble_advdata_t const * const p_advdata,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;526                                uint8_t             * const p_encoded_data,
;;;527                                uint16_t            * const p_len)
;;;528    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;529        uint32_t err_code = NRF_SUCCESS;
00000a  2500              MOVS     r5,#0
;;;530        uint16_t max_size = *p_len;
00000c  8837              LDRH     r7,[r6,#0]
;;;531        *p_len = 0;
00000e  2000              MOVS     r0,#0
000010  8030              STRH     r0,[r6,#0]
;;;532    
;;;533        // Encode LE Bluetooth Device Address
;;;534        if (p_advdata->include_ble_device_addr)
000012  f894002d          LDRB     r0,[r4,#0x2d]
000016  b158              CBZ      r0,|L3.48|
;;;535        {
;;;536            err_code = ble_device_addr_encode(p_encoded_data, p_len, max_size);
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       ble_device_addr_encode
000022  4605              MOV      r5,r0
;;;537            VERIFY_SUCCESS(err_code);
000024  bf00              NOP      
000026  b115              CBZ      r5,|L3.46|
000028  4628              MOV      r0,r5
                  |L3.42|
;;;538        }
;;;539    
;;;540        // Encode appearance.
;;;541        if (p_advdata->include_appearance)
;;;542        {
;;;543            err_code = appearance_encode(p_encoded_data, p_len, max_size);
;;;544            VERIFY_SUCCESS(err_code);
;;;545        }
;;;546    
;;;547        //Encode Flags
;;;548        if (p_advdata->flags != 0 )
;;;549        {
;;;550            err_code = flags_encode(p_advdata->flags, p_encoded_data, p_len, max_size);
;;;551            VERIFY_SUCCESS(err_code);
;;;552        }
;;;553    
;;;554        // Encode TX power level.
;;;555        if (p_advdata->p_tx_power_level != NULL)
;;;556        {
;;;557            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level,
;;;558                                             p_encoded_data,
;;;559                                             p_len,
;;;560                                             max_size);
;;;561            VERIFY_SUCCESS(err_code);
;;;562        }
;;;563    
;;;564        // Encode 'more available' uuid list.
;;;565        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;566        {
;;;567            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;568                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;569                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;570                                        p_encoded_data,
;;;571                                        p_len,
;;;572                                        max_size);
;;;573            VERIFY_SUCCESS(err_code);
;;;574        }
;;;575    
;;;576        // Encode 'complete' uuid list.
;;;577        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;578        {
;;;579            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;580                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;581                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;582                                        p_encoded_data,
;;;583                                        p_len,
;;;584                                        max_size);
;;;585            VERIFY_SUCCESS(err_code);
;;;586        }
;;;587    
;;;588        // Encode 'solicited service' uuid list.
;;;589        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;590        {
;;;591            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;592                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;593                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;594                                        p_encoded_data,
;;;595                                        p_len,
;;;596                                        max_size);
;;;597            VERIFY_SUCCESS(err_code);
;;;598        }
;;;599    
;;;600        // Encode Slave Connection Interval Range.
;;;601        if (p_advdata->p_slave_conn_int != NULL)
;;;602        {
;;;603            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len, max_size);
;;;604            VERIFY_SUCCESS(err_code);
;;;605        }
;;;606    
;;;607        // Encode Manufacturer Specific Data.
;;;608        if (p_advdata->p_manuf_specific_data != NULL)
;;;609        {
;;;610            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;611                                                  p_encoded_data,
;;;612                                                  p_len,
;;;613                                                  max_size);
;;;614            VERIFY_SUCCESS(err_code);
;;;615        }
;;;616    
;;;617        // Encode Service Data.
;;;618        if (p_advdata->service_data_count > 0)
;;;619        {
;;;620            err_code = service_data_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;621            VERIFY_SUCCESS(err_code);
;;;622        }
;;;623    
;;;624        // Encode name. WARNING: it is encoded last on purpose since too long device name is truncated.
;;;625        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
;;;626        {
;;;627            err_code = name_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;628            VERIFY_SUCCESS(err_code);
;;;629        }
;;;630    
;;;631        return err_code;
;;;632    }
00002a  e8bd81fc          POP      {r2-r8,pc}
                  |L3.46|
00002e  bf00              NOP                            ;537
                  |L3.48|
000030  78a0              LDRB     r0,[r4,#2]            ;541
000032  b150              CBZ      r0,|L3.74|
000034  463a              MOV      r2,r7                 ;543
000036  4631              MOV      r1,r6                 ;543
000038  4640              MOV      r0,r8                 ;543
00003a  f7fffffe          BL       appearance_encode
00003e  4605              MOV      r5,r0                 ;543
000040  bf00              NOP                            ;544
000042  b10d              CBZ      r5,|L3.72|
000044  4628              MOV      r0,r5                 ;544
000046  e7f0              B        |L3.42|
                  |L3.72|
000048  bf00              NOP                            ;544
                  |L3.74|
00004a  78e0              LDRB     r0,[r4,#3]            ;548
00004c  b160              CBZ      r0,|L3.104|
00004e  78e1              LDRB     r1,[r4,#3]            ;550
000050  b248              SXTB     r0,r1                 ;550
000052  463b              MOV      r3,r7                 ;550
000054  4632              MOV      r2,r6                 ;550
000056  4641              MOV      r1,r8                 ;550
000058  f7fffffe          BL       flags_encode
00005c  4605              MOV      r5,r0                 ;550
00005e  bf00              NOP                            ;551
000060  b10d              CBZ      r5,|L3.102|
000062  4628              MOV      r0,r5                 ;551
000064  e7e1              B        |L3.42|
                  |L3.102|
000066  bf00              NOP                            ;551
                  |L3.104|
000068  6860              LDR      r0,[r4,#4]            ;555
00006a  b168              CBZ      r0,|L3.136|
00006c  6861              LDR      r1,[r4,#4]            ;557
00006e  f9910000          LDRSB    r0,[r1,#0]            ;557
000072  463b              MOV      r3,r7                 ;557
000074  4632              MOV      r2,r6                 ;557
000076  4641              MOV      r1,r8                 ;557
000078  f7fffffe          BL       tx_power_level_encode
00007c  4605              MOV      r5,r0                 ;557
00007e  bf00              NOP                            ;561
000080  b10d              CBZ      r5,|L3.134|
000082  4628              MOV      r0,r5                 ;561
000084  e7d1              B        |L3.42|
                  |L3.134|
000086  bf00              NOP                            ;561
                  |L3.136|
000088  8920              LDRH     r0,[r4,#8]            ;565
00008a  2800              CMP      r0,#0                 ;565
00008c  dd0e              BLE      |L3.172|
00008e  4643              MOV      r3,r8                 ;567
000090  2206              MOVS     r2,#6                 ;567
000092  2102              MOVS     r1,#2                 ;567
000094  f1040008          ADD      r0,r4,#8              ;567
000098  e9cd6700          STRD     r6,r7,[sp,#0]         ;567
00009c  f7fffffe          BL       uuid_list_encode
0000a0  4605              MOV      r5,r0                 ;567
0000a2  bf00              NOP                            ;573
0000a4  b10d              CBZ      r5,|L3.170|
0000a6  4628              MOV      r0,r5                 ;573
0000a8  e7bf              B        |L3.42|
                  |L3.170|
0000aa  bf00              NOP                            ;573
                  |L3.172|
0000ac  8a20              LDRH     r0,[r4,#0x10]         ;577
0000ae  2800              CMP      r0,#0                 ;577
0000b0  dd0e              BLE      |L3.208|
0000b2  4643              MOV      r3,r8                 ;579
0000b4  2207              MOVS     r2,#7                 ;579
0000b6  2103              MOVS     r1,#3                 ;579
0000b8  f1040010          ADD      r0,r4,#0x10           ;579
0000bc  e9cd6700          STRD     r6,r7,[sp,#0]         ;579
0000c0  f7fffffe          BL       uuid_list_encode
0000c4  4605              MOV      r5,r0                 ;579
0000c6  bf00              NOP                            ;585
0000c8  b10d              CBZ      r5,|L3.206|
0000ca  4628              MOV      r0,r5                 ;585
0000cc  e7ad              B        |L3.42|
                  |L3.206|
0000ce  bf00              NOP                            ;585
                  |L3.208|
0000d0  8b20              LDRH     r0,[r4,#0x18]         ;589
0000d2  2800              CMP      r0,#0                 ;589
0000d4  dd0e              BLE      |L3.244|
0000d6  4643              MOV      r3,r8                 ;591
0000d8  2215              MOVS     r2,#0x15              ;591
0000da  2114              MOVS     r1,#0x14              ;591
0000dc  f1040018          ADD      r0,r4,#0x18           ;591
0000e0  e9cd6700          STRD     r6,r7,[sp,#0]         ;591
0000e4  f7fffffe          BL       uuid_list_encode
0000e8  4605              MOV      r5,r0                 ;591
0000ea  bf00              NOP                            ;597
0000ec  b10d              CBZ      r5,|L3.242|
0000ee  4628              MOV      r0,r5                 ;597
0000f0  e79b              B        |L3.42|
                  |L3.242|
0000f2  bf00              NOP                            ;597
                  |L3.244|
0000f4  6a20              LDR      r0,[r4,#0x20]         ;601
0000f6  b158              CBZ      r0,|L3.272|
0000f8  463b              MOV      r3,r7                 ;603
0000fa  4632              MOV      r2,r6                 ;603
0000fc  4641              MOV      r1,r8                 ;603
0000fe  6a20              LDR      r0,[r4,#0x20]         ;603
000100  f7fffffe          BL       conn_int_encode
000104  4605              MOV      r5,r0                 ;603
000106  bf00              NOP                            ;604
000108  b10d              CBZ      r5,|L3.270|
00010a  4628              MOV      r0,r5                 ;604
00010c  e78d              B        |L3.42|
                  |L3.270|
00010e  bf00              NOP                            ;604
                  |L3.272|
000110  6a60              LDR      r0,[r4,#0x24]         ;608
000112  b158              CBZ      r0,|L3.300|
000114  463b              MOV      r3,r7                 ;610
000116  4632              MOV      r2,r6                 ;610
000118  4641              MOV      r1,r8                 ;610
00011a  6a60              LDR      r0,[r4,#0x24]         ;610
00011c  f7fffffe          BL       manuf_specific_data_encode
000120  4605              MOV      r5,r0                 ;610
000122  bf00              NOP                            ;614
000124  b10d              CBZ      r5,|L3.298|
000126  4628              MOV      r0,r5                 ;614
000128  e77f              B        |L3.42|
                  |L3.298|
00012a  bf00              NOP                            ;614
                  |L3.300|
00012c  f894002c          LDRB     r0,[r4,#0x2c]         ;618
000130  2800              CMP      r0,#0                 ;618
000132  dd0b              BLE      |L3.332|
000134  463b              MOV      r3,r7                 ;620
000136  4632              MOV      r2,r6                 ;620
000138  4641              MOV      r1,r8                 ;620
00013a  4620              MOV      r0,r4                 ;620
00013c  f7fffffe          BL       service_data_encode
000140  4605              MOV      r5,r0                 ;620
000142  bf00              NOP                            ;621
000144  b10d              CBZ      r5,|L3.330|
000146  4628              MOV      r0,r5                 ;621
000148  e76f              B        |L3.42|
                  |L3.330|
00014a  bf00              NOP                            ;621
                  |L3.332|
00014c  7820              LDRB     r0,[r4,#0]            ;625
00014e  b158              CBZ      r0,|L3.360|
000150  463b              MOV      r3,r7                 ;627
000152  4632              MOV      r2,r6                 ;627
000154  4641              MOV      r1,r8                 ;627
000156  4620              MOV      r0,r4                 ;627
000158  f7fffffe          BL       name_encode
00015c  4605              MOV      r5,r0                 ;627
00015e  bf00              NOP                            ;628
000160  b10d              CBZ      r5,|L3.358|
000162  4628              MOV      r0,r5                 ;628
000164  e761              B        |L3.42|
                  |L3.358|
000166  bf00              NOP                            ;628
                  |L3.360|
000168  4628              MOV      r0,r5                 ;631
00016a  e75e              B        |L3.42|
;;;633    
                          ENDP


                          AREA ||i.ble_advdata_set||, CODE, READONLY, ALIGN=1

                  ble_advdata_set PROC
;;;660    
;;;661    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;662    {
000004  b092              SUB      sp,sp,#0x48
000006  4680              MOV      r8,r0
000008  460d              MOV      r5,r1
;;;663        uint32_t  err_code;
;;;664        uint16_t  len_advdata = BLE_GAP_ADV_MAX_SIZE;
00000a  201f              MOVS     r0,#0x1f
00000c  9011              STR      r0,[sp,#0x44]
;;;665        uint16_t  len_srdata  = BLE_GAP_ADV_MAX_SIZE;
00000e  9010              STR      r0,[sp,#0x40]
;;;666        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;667        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;668        uint8_t * p_encoded_advdata;
;;;669        uint8_t * p_encoded_srdata;
;;;670    
;;;671        // Encode advertising data (if supplied).
;;;672        if (p_advdata != NULL)
000010  f1b80f00          CMP      r8,#0
000014  d017              BEQ      |L4.70|
;;;673        {
;;;674            err_code = advdata_check(p_advdata);
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       advdata_check
00001c  4604              MOV      r4,r0
;;;675            VERIFY_SUCCESS(err_code);
00001e  bf00              NOP      
000020  b11c              CBZ      r4,|L4.42|
000022  4620              MOV      r0,r4
                  |L4.36|
;;;676    
;;;677            err_code = ble_advdata_encode(p_advdata, encoded_advdata, &len_advdata);
;;;678            VERIFY_SUCCESS(err_code);
;;;679            p_encoded_advdata = encoded_advdata;
;;;680        }
;;;681        else
;;;682        {
;;;683            p_encoded_advdata = NULL;
;;;684            len_advdata = 0;
;;;685        }
;;;686    
;;;687        // Encode scan response data (if supplied).
;;;688        if (p_srdata != NULL)
;;;689        {
;;;690            err_code = srdata_check(p_srdata);
;;;691            VERIFY_SUCCESS(err_code);
;;;692    
;;;693            err_code = ble_advdata_encode(p_srdata, encoded_srdata, &len_srdata);
;;;694            VERIFY_SUCCESS(err_code);
;;;695            p_encoded_srdata = encoded_srdata;
;;;696        }
;;;697        else
;;;698        {
;;;699            p_encoded_srdata = NULL;
;;;700            len_srdata = 0;
;;;701        }
;;;702    
;;;703        // Pass encoded advertising data and/or scan response data to the stack.
;;;704        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;705    }
000024  b012              ADD      sp,sp,#0x48
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L4.42|
00002a  bf00              NOP                            ;675
00002c  aa11              ADD      r2,sp,#0x44           ;677
00002e  a908              ADD      r1,sp,#0x20           ;677
000030  4640              MOV      r0,r8                 ;677
000032  f7fffffe          BL       ble_advdata_encode
000036  4604              MOV      r4,r0                 ;677
000038  bf00              NOP                            ;678
00003a  b10c              CBZ      r4,|L4.64|
00003c  4620              MOV      r0,r4                 ;678
00003e  e7f1              B        |L4.36|
                  |L4.64|
000040  bf00              NOP                            ;678
000042  ae08              ADD      r6,sp,#0x20           ;679
000044  e002              B        |L4.76|
                  |L4.70|
000046  2600              MOVS     r6,#0                 ;683
000048  2000              MOVS     r0,#0                 ;684
00004a  9011              STR      r0,[sp,#0x44]         ;684
                  |L4.76|
00004c  b1ad              CBZ      r5,|L4.122|
00004e  4628              MOV      r0,r5                 ;690
000050  f7fffffe          BL       srdata_check
000054  4604              MOV      r4,r0                 ;690
000056  bf00              NOP                            ;691
000058  b10c              CBZ      r4,|L4.94|
00005a  4620              MOV      r0,r4                 ;691
00005c  e7e2              B        |L4.36|
                  |L4.94|
00005e  bf00              NOP                            ;691
000060  aa10              ADD      r2,sp,#0x40           ;693
000062  4669              MOV      r1,sp                 ;693
000064  4628              MOV      r0,r5                 ;693
000066  f7fffffe          BL       ble_advdata_encode
00006a  4604              MOV      r4,r0                 ;693
00006c  bf00              NOP                            ;694
00006e  b10c              CBZ      r4,|L4.116|
000070  4620              MOV      r0,r4                 ;694
000072  e7d7              B        |L4.36|
                  |L4.116|
000074  bf00              NOP                            ;694
000076  466f              MOV      r7,sp                 ;695
000078  e002              B        |L4.128|
                  |L4.122|
00007a  2700              MOVS     r7,#0                 ;699
00007c  2000              MOVS     r0,#0                 ;700
00007e  9010              STR      r0,[sp,#0x40]         ;700
                  |L4.128|
000080  f8bd0040          LDRH     r0,[sp,#0x40]         ;704
000084  b2c3              UXTB     r3,r0                 ;704
000086  f8bd0044          LDRH     r0,[sp,#0x44]         ;704
00008a  b2c1              UXTB     r1,r0                 ;704
00008c  463a              MOV      r2,r7                 ;704
00008e  4630              MOV      r0,r6                 ;704
000090  df72              SVC      #0x72                 ;704
000092  e7c7              B        |L4.36|
                          ENDP


                          AREA ||i.ble_device_addr_encode||, CODE, READONLY, ALIGN=1

                  ble_device_addr_encode PROC
;;;74     
;;;75     static uint32_t ble_device_addr_encode(uint8_t  * p_encoded_data,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;76                                            uint16_t * p_offset,
;;;77                                            uint16_t   max_size)
;;;78     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;79         uint32_t err_code;
;;;80         ble_gap_addr_t device_addr;
;;;81     
;;;82         // Check for buffer overflow.
;;;83         if (((*p_offset) + AD_TYPE_BLE_DEVICE_ADDR_SIZE) > max_size)
00000a  8820              LDRH     r0,[r4,#0]
00000c  3009              ADDS     r0,r0,#9
00000e  42b8              CMP      r0,r7
000010  d902              BLS      |L5.24|
;;;84         {
;;;85             return NRF_ERROR_DATA_SIZE;
000012  200c              MOVS     r0,#0xc
                  |L5.20|
;;;86         }
;;;87     
;;;88         // Get BLE address.
;;;89         #if (NRF_SD_BLE_API_VERSION >= 3)
;;;90             err_code = sd_ble_gap_addr_get(&device_addr);
;;;91         #else
;;;92             err_code = sd_ble_gap_address_get(&device_addr);
;;;93         #endif
;;;94         VERIFY_SUCCESS(err_code);
;;;95     
;;;96         // Encode LE Bluetooth Device Address.
;;;97         p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
;;;98                                                    AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE);
;;;99         *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;100        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS;
;;;101        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;102        memcpy(&p_encoded_data[*p_offset], &device_addr.addr[0], BLE_GAP_ADDR_LEN);
;;;103        *p_offset                 += BLE_GAP_ADDR_LEN;
;;;104        if (BLE_GAP_ADDR_TYPE_PUBLIC == device_addr.addr_type)
;;;105        {
;;;106            p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_PUBLIC;
;;;107        }
;;;108        else
;;;109        {
;;;110            p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM;
;;;111        }
;;;112        *p_offset += AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE;
;;;113    
;;;114        return NRF_SUCCESS;
;;;115    }
000014  e8bd81fc          POP      {r2-r8,pc}
                  |L5.24|
000018  4668              MOV      r0,sp                 ;90
00001a  df6d              SVC      #0x6d                 ;90
00001c  4606              MOV      r6,r0                 ;90
00001e  bf00              NOP                            ;94
000020  b10e              CBZ      r6,|L5.38|
000022  4630              MOV      r0,r6                 ;94
000024  e7f6              B        |L5.20|
                  |L5.38|
000026  bf00              NOP                            ;94
000028  2008              MOVS     r0,#8                 ;97
00002a  8821              LDRH     r1,[r4,#0]            ;97
00002c  5468              STRB     r0,[r5,r1]            ;97
00002e  8820              LDRH     r0,[r4,#0]            ;99
000030  1c40              ADDS     r0,r0,#1              ;99
000032  8020              STRH     r0,[r4,#0]            ;99
000034  201b              MOVS     r0,#0x1b              ;100
000036  8821              LDRH     r1,[r4,#0]            ;100
000038  5468              STRB     r0,[r5,r1]            ;100
00003a  8820              LDRH     r0,[r4,#0]            ;101
00003c  1c40              ADDS     r0,r0,#1              ;101
00003e  8020              STRH     r0,[r4,#0]            ;101
000040  8820              LDRH     r0,[r4,#0]            ;102
000042  4428              ADD      r0,r0,r5              ;102
000044  f8dd1001          LDR      r1,[sp,#1]            ;102
000048  6001              STR      r1,[r0,#0]            ;102
00004a  f8bd1005          LDRH     r1,[sp,#5]            ;102
00004e  8081              STRH     r1,[r0,#4]            ;102
000050  8820              LDRH     r0,[r4,#0]            ;103
000052  1d80              ADDS     r0,r0,#6              ;103
000054  8020              STRH     r0,[r4,#0]            ;103
000056  f89d0000          LDRB     r0,[sp,#0]            ;104
00005a  0840              LSRS     r0,r0,#1              ;104
00005c  b918              CBNZ     r0,|L5.102|
00005e  2000              MOVS     r0,#0                 ;106
000060  8821              LDRH     r1,[r4,#0]            ;106
000062  5468              STRB     r0,[r5,r1]            ;106
000064  e002              B        |L5.108|
                  |L5.102|
000066  2001              MOVS     r0,#1                 ;110
000068  8821              LDRH     r1,[r4,#0]            ;110
00006a  5468              STRB     r0,[r5,r1]            ;110
                  |L5.108|
00006c  8820              LDRH     r0,[r4,#0]            ;112
00006e  1c40              ADDS     r0,r0,#1              ;112
000070  8020              STRH     r0,[r4,#0]            ;112
000072  2000              MOVS     r0,#0                 ;114
000074  e7ce              B        |L5.20|
;;;116    
                          ENDP


                          AREA ||i.conn_int_check||, CODE, READONLY, ALIGN=1

                  conn_int_check PROC
;;;361    
;;;362    static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
000000  4601              MOV      r1,r0
;;;363    {
;;;364        // Check Minimum Connection Interval.
;;;365        if ((p_conn_int->min_conn_interval < 0x0006) ||
000002  8808              LDRH     r0,[r1,#0]
000004  2806              CMP      r0,#6
000006  db08              BLT      |L6.26|
;;;366            (
;;;367                (p_conn_int->min_conn_interval > 0x0c80) &&
000008  8808              LDRH     r0,[r1,#0]
00000a  f5b06f48          CMP      r0,#0xc80
00000e  dd06              BLE      |L6.30|
;;;368                (p_conn_int->min_conn_interval != 0xffff)
000010  8808              LDRH     r0,[r1,#0]
000012  f64f72ff          MOV      r2,#0xffff
000016  4290              CMP      r0,r2
000018  d001              BEQ      |L6.30|
                  |L6.26|
;;;369            )
;;;370           )
;;;371        {
;;;372            return NRF_ERROR_INVALID_PARAM;
00001a  2007              MOVS     r0,#7
                  |L6.28|
;;;373        }
;;;374    
;;;375        // Check Maximum Connection Interval.
;;;376        if ((p_conn_int->max_conn_interval < 0x0006) ||
;;;377            (
;;;378                (p_conn_int->max_conn_interval > 0x0c80) &&
;;;379                (p_conn_int->max_conn_interval != 0xffff)
;;;380            )
;;;381           )
;;;382        {
;;;383            return NRF_ERROR_INVALID_PARAM;
;;;384        }
;;;385    
;;;386        // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
;;;387        if ((p_conn_int->min_conn_interval != 0xffff) &&
;;;388            (p_conn_int->max_conn_interval != 0xffff) &&
;;;389            (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
;;;390            )
;;;391        {
;;;392            return NRF_ERROR_INVALID_PARAM;
;;;393        }
;;;394    
;;;395        return NRF_SUCCESS;
;;;396    }
00001c  4770              BX       lr
                  |L6.30|
00001e  8848              LDRH     r0,[r1,#2]            ;376
000020  2806              CMP      r0,#6                 ;376
000022  db08              BLT      |L6.54|
000024  8848              LDRH     r0,[r1,#2]            ;378
000026  f5b06f48          CMP      r0,#0xc80             ;378
00002a  dd06              BLE      |L6.58|
00002c  8848              LDRH     r0,[r1,#2]            ;379
00002e  f64f72ff          MOV      r2,#0xffff            ;379
000032  4290              CMP      r0,r2                 ;379
000034  d001              BEQ      |L6.58|
                  |L6.54|
000036  2007              MOVS     r0,#7                 ;383
000038  e7f0              B        |L6.28|
                  |L6.58|
00003a  8808              LDRH     r0,[r1,#0]            ;387
00003c  f64f72ff          MOV      r2,#0xffff            ;387
000040  4290              CMP      r0,r2                 ;387
000042  d008              BEQ      |L6.86|
000044  8848              LDRH     r0,[r1,#2]            ;388
000046  4290              CMP      r0,r2                 ;388
000048  d005              BEQ      |L6.86|
00004a  8808              LDRH     r0,[r1,#0]            ;389
00004c  884a              LDRH     r2,[r1,#2]            ;389
00004e  4290              CMP      r0,r2                 ;389
000050  dd01              BLE      |L6.86|
000052  2007              MOVS     r0,#7                 ;392
000054  e7e2              B        |L6.28|
                  |L6.86|
000056  2000              MOVS     r0,#0                 ;395
000058  e7e0              B        |L6.28|
;;;397    
                          ENDP


                          AREA ||i.conn_int_encode||, CODE, READONLY, ALIGN=1

                  conn_int_encode PROC
;;;398    
;;;399    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;400                                    uint8_t                      * p_encoded_data,
;;;401                                    uint16_t                     * p_offset,
;;;402                                    uint16_t                       max_size)
;;;403    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;404        uint32_t err_code;
;;;405    
;;;406        // Check for buffer overflow.
;;;407        if (((*p_offset) + AD_TYPE_CONN_INT_SIZE) > max_size)
00000c  8820              LDRH     r0,[r4,#0]
00000e  1d80              ADDS     r0,r0,#6
000010  4540              CMP      r0,r8
000012  d902              BLS      |L7.26|
;;;408        {
;;;409            return NRF_ERROR_DATA_SIZE;
000014  200c              MOVS     r0,#0xc
                  |L7.22|
;;;410        }
;;;411    
;;;412        // Check parameters.
;;;413        err_code = conn_int_check(p_conn_int);
;;;414        VERIFY_SUCCESS(err_code);
;;;415    
;;;416        // Encode Length and AD Type.
;;;417        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_CONN_INT_DATA_SIZE);
;;;418        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;419        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;420        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;421    
;;;422        // Encode Minimum and Maximum Connection Intervals.
;;;423        *p_offset += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_offset]);
;;;424        *p_offset += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_offset]);
;;;425    
;;;426        return NRF_SUCCESS;
;;;427    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L7.26|
00001a  4630              MOV      r0,r6                 ;413
00001c  f7fffffe          BL       conn_int_check
000020  4607              MOV      r7,r0                 ;413
000022  bf00              NOP                            ;414
000024  b10f              CBZ      r7,|L7.42|
000026  4638              MOV      r0,r7                 ;414
000028  e7f5              B        |L7.22|
                  |L7.42|
00002a  bf00              NOP                            ;414
00002c  2005              MOVS     r0,#5                 ;417
00002e  8821              LDRH     r1,[r4,#0]            ;417
000030  5468              STRB     r0,[r5,r1]            ;417
000032  8820              LDRH     r0,[r4,#0]            ;418
000034  1c40              ADDS     r0,r0,#1              ;418
000036  8020              STRH     r0,[r4,#0]            ;418
000038  2012              MOVS     r0,#0x12              ;419
00003a  8821              LDRH     r1,[r4,#0]            ;419
00003c  5468              STRB     r0,[r5,r1]            ;419
00003e  8820              LDRH     r0,[r4,#0]            ;420
000040  1c40              ADDS     r0,r0,#1              ;420
000042  8020              STRH     r0,[r4,#0]            ;420
000044  8822              LDRH     r2,[r4,#0]            ;423
000046  1951              ADDS     r1,r2,r5              ;423
000048  8830              LDRH     r0,[r6,#0]            ;423
00004a  f7fffffe          BL       uint16_encode
00004e  8821              LDRH     r1,[r4,#0]            ;423
000050  4408              ADD      r0,r0,r1              ;423
000052  8020              STRH     r0,[r4,#0]            ;423
000054  8822              LDRH     r2,[r4,#0]            ;424
000056  1951              ADDS     r1,r2,r5              ;424
000058  8870              LDRH     r0,[r6,#2]            ;424
00005a  f7fffffe          BL       uint16_encode
00005e  8821              LDRH     r1,[r4,#0]            ;424
000060  4408              ADD      r0,r0,r1              ;424
000062  8020              STRH     r0,[r4,#0]            ;424
000064  2000              MOVS     r0,#0                 ;426
000066  e7d6              B        |L7.22|
;;;428    
                          ENDP


                          AREA ||i.flags_encode||, CODE, READONLY, ALIGN=1

                  flags_encode PROC
;;;219    
;;;220    static uint32_t flags_encode(int8_t     flags,
000000  b530              PUSH     {r4,r5,lr}
;;;221                                 uint8_t  * p_encoded_data,
;;;222                                 uint16_t * p_offset,
;;;223                                 uint16_t   max_size)
;;;224    {
000002  4604              MOV      r4,r0
;;;225        // Check for buffer overflow.
;;;226        if (((*p_offset) + AD_TYPE_FLAGS_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L8.16|
;;;227        {
;;;228            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L8.14|
;;;229        }
;;;230    
;;;231        // Encode flags.
;;;232        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + AD_TYPE_FLAGS_DATA_SIZE);
;;;233        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;234        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_FLAGS;
;;;235        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;236        p_encoded_data[*p_offset]  = flags;
;;;237        *p_offset                 += AD_TYPE_FLAGS_DATA_SIZE;
;;;238    
;;;239        return NRF_SUCCESS;
;;;240    }
00000e  bd30              POP      {r4,r5,pc}
                  |L8.16|
000010  2002              MOVS     r0,#2                 ;232
000012  8815              LDRH     r5,[r2,#0]            ;232
000014  5548              STRB     r0,[r1,r5]            ;232
000016  8810              LDRH     r0,[r2,#0]            ;233
000018  1c40              ADDS     r0,r0,#1              ;233
00001a  8010              STRH     r0,[r2,#0]            ;233
00001c  2001              MOVS     r0,#1                 ;234
00001e  8815              LDRH     r5,[r2,#0]            ;234
000020  5548              STRB     r0,[r1,r5]            ;234
000022  8810              LDRH     r0,[r2,#0]            ;235
000024  1c40              ADDS     r0,r0,#1              ;235
000026  8010              STRH     r0,[r2,#0]            ;235
000028  8815              LDRH     r5,[r2,#0]            ;236
00002a  554c              STRB     r4,[r1,r5]            ;236
00002c  8810              LDRH     r0,[r2,#0]            ;237
00002e  1c40              ADDS     r0,r0,#1              ;237
000030  8010              STRH     r0,[r2,#0]            ;237
000032  2000              MOVS     r0,#0                 ;239
000034  e7eb              B        |L8.14|
;;;241    
                          ENDP


                          AREA ||i.manuf_specific_data_encode||, CODE, READONLY, ALIGN=1

                  manuf_specific_data_encode PROC
;;;429    
;;;430    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;431                                               uint8_t                        * p_encoded_data,
;;;432                                               uint16_t                       * p_offset,
;;;433                                               uint16_t                         max_size)
;;;434    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;435        uint32_t data_size = AD_TYPE_MANUF_SPEC_DATA_ID_SIZE + p_manuf_sp_data->data.size;
00000c  88a8              LDRH     r0,[r5,#4]
00000e  1c87              ADDS     r7,r0,#2
;;;436    
;;;437        // Check for buffer overflow.
;;;438        if (((*p_offset) + AD_DATA_OFFSET + data_size) > max_size)
000010  8820              LDRH     r0,[r4,#0]
000012  1c80              ADDS     r0,r0,#2
000014  4438              ADD      r0,r0,r7
000016  4540              CMP      r0,r8
000018  d902              BLS      |L9.32|
;;;439        {
;;;440            return NRF_ERROR_DATA_SIZE;
00001a  200c              MOVS     r0,#0xc
                  |L9.28|
;;;441        }
;;;442    
;;;443        // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
;;;444        if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
;;;445        {
;;;446            return NRF_ERROR_DATA_SIZE;
;;;447        }
;;;448    
;;;449        // Encode Length and AD Type.
;;;450        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
;;;451        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;452        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;453        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;454    
;;;455        // Encode Company Identifier.
;;;456        *p_offset += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_offset]);
;;;457    
;;;458        // Encode additional manufacturer specific data.
;;;459        if (p_manuf_sp_data->data.size > 0)
;;;460        {
;;;461            if (p_manuf_sp_data->data.p_data == NULL)
;;;462            {
;;;463                return NRF_ERROR_INVALID_PARAM;
;;;464            }
;;;465            memcpy(&p_encoded_data[*p_offset], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;466            *p_offset += p_manuf_sp_data->data.size;
;;;467        }
;;;468    
;;;469        return NRF_SUCCESS;
;;;470    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L9.32|
000020  2ffe              CMP      r7,#0xfe              ;444
000022  d901              BLS      |L9.40|
000024  200c              MOVS     r0,#0xc               ;446
000026  e7f9              B        |L9.28|
                  |L9.40|
000028  1c78              ADDS     r0,r7,#1              ;450
00002a  8821              LDRH     r1,[r4,#0]            ;450
00002c  5470              STRB     r0,[r6,r1]            ;450
00002e  8820              LDRH     r0,[r4,#0]            ;451
000030  1c40              ADDS     r0,r0,#1              ;451
000032  8020              STRH     r0,[r4,#0]            ;451
000034  20ff              MOVS     r0,#0xff              ;452
000036  8821              LDRH     r1,[r4,#0]            ;452
000038  5470              STRB     r0,[r6,r1]            ;452
00003a  8820              LDRH     r0,[r4,#0]            ;453
00003c  1c40              ADDS     r0,r0,#1              ;453
00003e  8020              STRH     r0,[r4,#0]            ;453
000040  8822              LDRH     r2,[r4,#0]            ;456
000042  1991              ADDS     r1,r2,r6              ;456
000044  8828              LDRH     r0,[r5,#0]            ;456
000046  f7fffffe          BL       uint16_encode
00004a  8821              LDRH     r1,[r4,#0]            ;456
00004c  4408              ADD      r0,r0,r1              ;456
00004e  8020              STRH     r0,[r4,#0]            ;456
000050  88a8              LDRH     r0,[r5,#4]            ;459
000052  2800              CMP      r0,#0                 ;459
000054  dd0d              BLE      |L9.114|
000056  68a8              LDR      r0,[r5,#8]            ;461
000058  b908              CBNZ     r0,|L9.94|
00005a  2007              MOVS     r0,#7                 ;463
00005c  e7de              B        |L9.28|
                  |L9.94|
00005e  88aa              LDRH     r2,[r5,#4]            ;465
000060  8823              LDRH     r3,[r4,#0]            ;465
000062  1998              ADDS     r0,r3,r6              ;465
000064  68a9              LDR      r1,[r5,#8]            ;465
000066  f7fffffe          BL       __aeabi_memcpy
00006a  8820              LDRH     r0,[r4,#0]            ;466
00006c  88a9              LDRH     r1,[r5,#4]            ;466
00006e  4408              ADD      r0,r0,r1              ;466
000070  8020              STRH     r0,[r4,#0]            ;466
                  |L9.114|
000072  2000              MOVS     r0,#0                 ;469
000074  e7d2              B        |L9.28|
;;;471    
                          ENDP


                          AREA ||i.name_encode||, CODE, READONLY, ALIGN=1

                  name_encode PROC
;;;116    
;;;117    static uint32_t name_encode(const ble_advdata_t * p_advdata,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;118                                uint8_t             * p_encoded_data,
;;;119                                uint16_t            * p_offset,
;;;120                                uint16_t              max_size)
;;;121    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;122        uint32_t err_code;
;;;123        uint16_t rem_adv_data_len;
;;;124        uint16_t actual_length;
;;;125        uint8_t  adv_data_format;
;;;126    
;;;127    
;;;128        // Validate parameters
;;;129        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) && (0 == p_advdata->short_name_len))
00000c  7828              LDRB     r0,[r5,#0]
00000e  2801              CMP      r0,#1
000010  d104              BNE      |L10.28|
000012  7868              LDRB     r0,[r5,#1]
000014  b910              CBNZ     r0,|L10.28|
;;;130        {
;;;131            return NRF_ERROR_INVALID_PARAM;
000016  2007              MOVS     r0,#7
                  |L10.24|
;;;132        }
;;;133    
;;;134        // Check for buffer overflow.
;;;135        if ( (((*p_offset) + AD_DATA_OFFSET) > max_size) ||
;;;136             ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;137               (((*p_offset) + AD_DATA_OFFSET + p_advdata->short_name_len) > max_size)))
;;;138        {
;;;139            return NRF_ERROR_DATA_SIZE;
;;;140        }
;;;141    
;;;142        rem_adv_data_len = max_size - (*p_offset) - AD_DATA_OFFSET;
;;;143        actual_length    = rem_adv_data_len;
;;;144    
;;;145        // Get GAP device name and length
;;;146        err_code = sd_ble_gap_device_name_get(&p_encoded_data[(*p_offset) + AD_DATA_OFFSET],
;;;147                                              &actual_length);
;;;148        VERIFY_SUCCESS(err_code);
;;;149    
;;;150        // Check if device intend to use short name and it can fit available data size.
;;;151        if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
;;;152        {
;;;153            // Complete device name can fit, setting Complete Name in Adv Data.
;;;154            adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;155        }
;;;156        else
;;;157        {
;;;158            // Else short name needs to be used. Or application has requested use of short name.
;;;159            adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;160    
;;;161            // If application has set a preference on the short name size, it needs to be considered,
;;;162            // else fit what can be fit.
;;;163            if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;164                    (p_advdata->short_name_len <= rem_adv_data_len))
;;;165            {
;;;166                // Short name fits available size.
;;;167                actual_length = p_advdata->short_name_len;
;;;168            }
;;;169            // Else whatever can fit the data buffer will be packed.
;;;170            else
;;;171            {
;;;172                actual_length = rem_adv_data_len;
;;;173            }
;;;174        }
;;;175    
;;;176        // There is only 1 byte intended to encode length which is (actual_length + AD_TYPE_FIELD_SIZE)
;;;177        if (actual_length > (0x00FF - AD_TYPE_FIELD_SIZE))
;;;178        {
;;;179            return NRF_ERROR_DATA_SIZE;
;;;180        }
;;;181    
;;;182        // Complete name field in encoded data.
;;;183        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + actual_length);
;;;184        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;185        p_encoded_data[*p_offset]  = adv_data_format;
;;;186        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;187        *p_offset                 += actual_length;
;;;188    
;;;189        return NRF_SUCCESS;
;;;190    }
000018  e8bd8ff8          POP      {r3-r11,pc}
                  |L10.28|
00001c  8820              LDRH     r0,[r4,#0]            ;135
00001e  1c80              ADDS     r0,r0,#2              ;135
000020  4540              CMP      r0,r8                 ;135
000022  d808              BHI      |L10.54|
000024  7828              LDRB     r0,[r5,#0]            ;136
000026  2801              CMP      r0,#1                 ;136
000028  d107              BNE      |L10.58|
00002a  8820              LDRH     r0,[r4,#0]            ;137
00002c  1c80              ADDS     r0,r0,#2              ;137
00002e  7869              LDRB     r1,[r5,#1]            ;137
000030  4408              ADD      r0,r0,r1              ;137
000032  4540              CMP      r0,r8                 ;137
000034  d901              BLS      |L10.58|
                  |L10.54|
000036  200c              MOVS     r0,#0xc               ;139
000038  e7ee              B        |L10.24|
                  |L10.58|
00003a  8820              LDRH     r0,[r4,#0]            ;142
00003c  eba80000          SUB      r0,r8,r0              ;142
000040  1e80              SUBS     r0,r0,#2              ;142
000042  b286              UXTH     r6,r0                 ;142
000044  9600              STR      r6,[sp,#0]            ;143
000046  8821              LDRH     r1,[r4,#0]            ;146
000048  1c89              ADDS     r1,r1,#2              ;146
00004a  19c8              ADDS     r0,r1,r7              ;146
00004c  4669              MOV      r1,sp                 ;146
00004e  df7d              SVC      #0x7d                 ;146
000050  4681              MOV      r9,r0                 ;146
000052  bf00              NOP                            ;148
000054  f1b90f00          CMP      r9,#0                 ;148
000058  d001              BEQ      |L10.94|
00005a  4648              MOV      r0,r9                 ;148
00005c  e7dc              B        |L10.24|
                  |L10.94|
00005e  bf00              NOP                            ;148
000060  7828              LDRB     r0,[r5,#0]            ;151
000062  2802              CMP      r0,#2                 ;151
000064  d106              BNE      |L10.116|
000066  f8bd0000          LDRH     r0,[sp,#0]            ;151
00006a  42b0              CMP      r0,r6                 ;151
00006c  dc02              BGT      |L10.116|
00006e  f04f0a09          MOV      r10,#9                ;154
000072  e00b              B        |L10.140|
                  |L10.116|
000074  f04f0a08          MOV      r10,#8                ;159
000078  7828              LDRB     r0,[r5,#0]            ;163
00007a  2801              CMP      r0,#1                 ;163
00007c  d105              BNE      |L10.138|
00007e  7868              LDRB     r0,[r5,#1]            ;164
000080  42b0              CMP      r0,r6                 ;164
000082  dc02              BGT      |L10.138|
000084  7868              LDRB     r0,[r5,#1]            ;167
000086  9000              STR      r0,[sp,#0]            ;167
000088  e000              B        |L10.140|
                  |L10.138|
00008a  9600              STR      r6,[sp,#0]            ;172
                  |L10.140|
00008c  f8bd0000          LDRH     r0,[sp,#0]            ;177
000090  28fe              CMP      r0,#0xfe              ;177
000092  d901              BLS      |L10.152|
000094  200c              MOVS     r0,#0xc               ;179
000096  e7bf              B        |L10.24|
                  |L10.152|
000098  f8bd0000          LDRH     r0,[sp,#0]            ;183
00009c  1c40              ADDS     r0,r0,#1              ;183
00009e  8821              LDRH     r1,[r4,#0]            ;183
0000a0  5478              STRB     r0,[r7,r1]            ;183
0000a2  8820              LDRH     r0,[r4,#0]            ;184
0000a4  1c40              ADDS     r0,r0,#1              ;184
0000a6  8020              STRH     r0,[r4,#0]            ;184
0000a8  8820              LDRH     r0,[r4,#0]            ;185
0000aa  f807a000          STRB     r10,[r7,r0]           ;185
0000ae  8820              LDRH     r0,[r4,#0]            ;186
0000b0  1c40              ADDS     r0,r0,#1              ;186
0000b2  8020              STRH     r0,[r4,#0]            ;186
0000b4  8820              LDRH     r0,[r4,#0]            ;187
0000b6  f8bd1000          LDRH     r1,[sp,#0]            ;187
0000ba  4408              ADD      r0,r0,r1              ;187
0000bc  8020              STRH     r0,[r4,#0]            ;187
0000be  2000              MOVS     r0,#0                 ;189
0000c0  e7aa              B        |L10.24|
;;;191    
                          ENDP


                          AREA ||i.service_data_encode||, CODE, READONLY, ALIGN=1

                  service_data_encode PROC
;;;472    // Implemented only for 16-bit UUIDs
;;;473    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;474                                        uint8_t             * p_encoded_data,
;;;475                                        uint16_t            * p_offset,
;;;476                                        uint16_t              max_size)
;;;477    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  469a              MOV      r10,r3
;;;478        uint8_t i;
;;;479    
;;;480        // Check parameter consistency.
;;;481        if (p_advdata->p_service_data_array == NULL)
00000c  6ab8              LDR      r0,[r7,#0x28]
00000e  b910              CBNZ     r0,|L11.22|
;;;482        {
;;;483            return NRF_ERROR_INVALID_PARAM;
000010  2007              MOVS     r0,#7
                  |L11.18|
;;;484        }
;;;485    
;;;486        for (i = 0; i < p_advdata->service_data_count; i++)
;;;487        {
;;;488            ble_advdata_service_data_t * p_service_data;
;;;489            uint32_t                     data_size;
;;;490    
;;;491            p_service_data = &p_advdata->p_service_data_array[i];
;;;492            // For now implemented only for 16-bit UUIDs
;;;493            data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;
;;;494    
;;;495            // There is only 1 byte intended to encode length which is (data_size + AD_TYPE_FIELD_SIZE)
;;;496            if (data_size > (0x00FF - AD_TYPE_FIELD_SIZE))
;;;497            {
;;;498                return NRF_ERROR_DATA_SIZE;
;;;499            }
;;;500    
;;;501            // Encode Length and AD Type.
;;;502            p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE + data_size);
;;;503            *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;504            p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;
;;;505            *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;506    
;;;507            // Encode service 16-bit UUID.
;;;508            *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);
;;;509    
;;;510            // Encode additional service data.
;;;511            if (p_service_data->data.size > 0)
;;;512            {
;;;513                if (p_service_data->data.p_data == NULL)
;;;514                {
;;;515                    return NRF_ERROR_INVALID_PARAM;
;;;516                }
;;;517                memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);
;;;518                *p_offset += p_service_data->data.size;
;;;519            }
;;;520        }
;;;521    
;;;522        return NRF_SUCCESS;
;;;523    }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L11.22|
000016  f04f0800          MOV      r8,#0                 ;486
00001a  e036              B        |L11.138|
                  |L11.28|
00001c  eb080148          ADD      r1,r8,r8,LSL #1       ;491
000020  6ab8              LDR      r0,[r7,#0x28]         ;491
000022  eb000581          ADD      r5,r0,r1,LSL #2       ;491
000026  88a8              LDRH     r0,[r5,#4]            ;493
000028  f1000902          ADD      r9,r0,#2              ;493
00002c  f1b90ffe          CMP      r9,#0xfe              ;496
000030  d901              BLS      |L11.54|
000032  200c              MOVS     r0,#0xc               ;498
000034  e7ed              B        |L11.18|
                  |L11.54|
000036  f1090001          ADD      r0,r9,#1              ;502
00003a  8821              LDRH     r1,[r4,#0]            ;502
00003c  5470              STRB     r0,[r6,r1]            ;502
00003e  8820              LDRH     r0,[r4,#0]            ;503
000040  1c40              ADDS     r0,r0,#1              ;503
000042  8020              STRH     r0,[r4,#0]            ;503
000044  2016              MOVS     r0,#0x16              ;504
000046  8821              LDRH     r1,[r4,#0]            ;504
000048  5470              STRB     r0,[r6,r1]            ;504
00004a  8820              LDRH     r0,[r4,#0]            ;505
00004c  1c40              ADDS     r0,r0,#1              ;505
00004e  8020              STRH     r0,[r4,#0]            ;505
000050  8822              LDRH     r2,[r4,#0]            ;508
000052  1991              ADDS     r1,r2,r6              ;508
000054  8828              LDRH     r0,[r5,#0]            ;508
000056  f7fffffe          BL       uint16_encode
00005a  8821              LDRH     r1,[r4,#0]            ;508
00005c  4408              ADD      r0,r0,r1              ;508
00005e  8020              STRH     r0,[r4,#0]            ;508
000060  88a8              LDRH     r0,[r5,#4]            ;511
000062  2800              CMP      r0,#0                 ;511
000064  dd0d              BLE      |L11.130|
000066  68a8              LDR      r0,[r5,#8]            ;513
000068  b908              CBNZ     r0,|L11.110|
00006a  2007              MOVS     r0,#7                 ;515
00006c  e7d1              B        |L11.18|
                  |L11.110|
00006e  88aa              LDRH     r2,[r5,#4]            ;517
000070  8823              LDRH     r3,[r4,#0]            ;517
000072  1998              ADDS     r0,r3,r6              ;517
000074  68a9              LDR      r1,[r5,#8]            ;517
000076  f7fffffe          BL       __aeabi_memcpy
00007a  8820              LDRH     r0,[r4,#0]            ;518
00007c  88a9              LDRH     r1,[r5,#4]            ;518
00007e  4408              ADD      r0,r0,r1              ;518
000080  8020              STRH     r0,[r4,#0]            ;518
                  |L11.130|
000082  f1080001          ADD      r0,r8,#1              ;486
000086  f00008ff          AND      r8,r0,#0xff           ;486
                  |L11.138|
00008a  f897002c          LDRB     r0,[r7,#0x2c]         ;486
00008e  4540              CMP      r0,r8                 ;486
000090  dcc4              BGT      |L11.28|
000092  2000              MOVS     r0,#0                 ;522
000094  e7bd              B        |L11.18|
;;;524    
                          ENDP


                          AREA ||i.srdata_check||, CODE, READONLY, ALIGN=1

                  srdata_check PROC
;;;648    
;;;649    static uint32_t srdata_check(const ble_advdata_t * p_srdata)
000000  4601              MOV      r1,r0
;;;650    {
;;;651        // Flags shall not be included in the scan response data.
;;;652        if (p_srdata->flags)
000002  78c8              LDRB     r0,[r1,#3]
000004  b108              CBZ      r0,|L12.10|
;;;653        {
;;;654            return NRF_ERROR_INVALID_PARAM;
000006  2007              MOVS     r0,#7
                  |L12.8|
;;;655        }
;;;656    
;;;657        return NRF_SUCCESS;
;;;658    }
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;657
00000c  e7fc              B        |L12.8|
;;;659    
                          ENDP


                          AREA ||i.tx_power_level_encode||, CODE, READONLY, ALIGN=1

                  tx_power_level_encode PROC
;;;241    
;;;242    static uint32_t tx_power_level_encode(int8_t     tx_power_level,
000000  b530              PUSH     {r4,r5,lr}
;;;243                                          uint8_t  * p_encoded_data,
;;;244                                          uint16_t * p_offset,
;;;245                                          uint16_t   max_size)
;;;246    {
000002  4604              MOV      r4,r0
;;;247        // Check for buffer overflow.
;;;248        if (((*p_offset) + AD_TYPE_TX_POWER_LEVEL_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L13.16|
;;;249        {
;;;250            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L13.14|
;;;251        }
;;;252    
;;;253        // Encode TX Power Level.
;;;254        p_encoded_data[*p_offset]  = (uint8_t)(AD_TYPE_FIELD_SIZE +
;;;255                                                      AD_TYPE_TX_POWER_LEVEL_DATA_SIZE);
;;;256        *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;257        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
;;;258        *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;259        p_encoded_data[*p_offset]  = tx_power_level;
;;;260        *p_offset                 += AD_TYPE_TX_POWER_LEVEL_DATA_SIZE;
;;;261    
;;;262        return NRF_SUCCESS;
;;;263    }
00000e  bd30              POP      {r4,r5,pc}
                  |L13.16|
000010  2002              MOVS     r0,#2                 ;254
000012  8815              LDRH     r5,[r2,#0]            ;254
000014  5548              STRB     r0,[r1,r5]            ;254
000016  8810              LDRH     r0,[r2,#0]            ;256
000018  1c40              ADDS     r0,r0,#1              ;256
00001a  8010              STRH     r0,[r2,#0]            ;256
00001c  200a              MOVS     r0,#0xa               ;257
00001e  8815              LDRH     r5,[r2,#0]            ;257
000020  5548              STRB     r0,[r1,r5]            ;257
000022  8810              LDRH     r0,[r2,#0]            ;258
000024  1c40              ADDS     r0,r0,#1              ;258
000026  8010              STRH     r0,[r2,#0]            ;258
000028  8815              LDRH     r5,[r2,#0]            ;259
00002a  554c              STRB     r4,[r1,r5]            ;259
00002c  8810              LDRH     r0,[r2,#0]            ;260
00002e  1c40              ADDS     r0,r0,#1              ;260
000030  8010              STRH     r0,[r2,#0]            ;260
000032  2000              MOVS     r0,#0                 ;262
000034  e7eb              B        |L13.14|
;;;264    
                          ENDP


                          AREA ||i.uint16_encode||, CODE, READONLY, ALIGN=1

                  uint16_encode PROC
;;;803     */
;;;804    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
000000  4602              MOV      r2,r0
;;;805    {
;;;806        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
000002  700a              STRB     r2,[r1,#0]
;;;807        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
000004  0a10              LSRS     r0,r2,#8
000006  7048              STRB     r0,[r1,#1]
;;;808        return sizeof(uint16_t);
000008  2002              MOVS     r0,#2
;;;809    }
00000a  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.uuid_list_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_encode PROC
;;;330    
;;;331    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;332                                     uint8_t                         adv_type_16,
;;;333                                     uint8_t                         adv_type_128,
;;;334                                     uint8_t                       * p_encoded_data,
;;;335                                     uint16_t                      * p_offset,
;;;336                                     uint16_t                        max_size)
;;;337    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  469a              MOV      r10,r3
00000c  e9dd670a          LDRD     r6,r7,[sp,#0x28]
;;;338        uint32_t err_code;
;;;339    
;;;340        // Encode 16 bit UUIDs.
;;;341        err_code = uuid_list_sized_encode(p_uuid_list,
000010  4653              MOV      r3,r10
000012  2202              MOVS     r2,#2
000014  4649              MOV      r1,r9
000016  4640              MOV      r0,r8
000018  e9cd6700          STRD     r6,r7,[sp,#0]
00001c  f7fffffe          BL       uuid_list_sized_encode
000020  4604              MOV      r4,r0
;;;342                                          adv_type_16,
;;;343                                          sizeof(uint16_le_t),
;;;344                                          p_encoded_data,
;;;345                                          p_offset,
;;;346                                          max_size);
;;;347        VERIFY_SUCCESS(err_code);
000022  bf00              NOP      
000024  b114              CBZ      r4,|L15.44|
000026  4620              MOV      r0,r4
                  |L15.40|
;;;348    
;;;349        // Encode 128 bit UUIDs.
;;;350        err_code = uuid_list_sized_encode(p_uuid_list,
;;;351                                          adv_type_128,
;;;352                                          sizeof(ble_uuid128_t),
;;;353                                          p_encoded_data,
;;;354                                          p_offset,
;;;355                                          max_size);
;;;356        VERIFY_SUCCESS(err_code);
;;;357    
;;;358        return NRF_SUCCESS;
;;;359    }
000028  e8bd87fc          POP      {r2-r10,pc}
                  |L15.44|
00002c  bf00              NOP                            ;347
00002e  4653              MOV      r3,r10                ;350
000030  2210              MOVS     r2,#0x10              ;350
000032  4629              MOV      r1,r5                 ;350
000034  4640              MOV      r0,r8                 ;350
000036  e9cd6700          STRD     r6,r7,[sp,#0]         ;350
00003a  f7fffffe          BL       uuid_list_sized_encode
00003e  4604              MOV      r4,r0                 ;350
000040  bf00              NOP                            ;356
000042  b10c              CBZ      r4,|L15.72|
000044  4620              MOV      r0,r4                 ;356
000046  e7ef              B        |L15.40|
                  |L15.72|
000048  bf00              NOP                            ;356
00004a  2000              MOVS     r0,#0                 ;358
00004c  e7ec              B        |L15.40|
;;;360    
                          ENDP


                          AREA ||i.uuid_list_sized_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_sized_encode PROC
;;;265    
;;;266    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;267                                           uint8_t                         adv_type,
;;;268                                           uint8_t                         uuid_size,
;;;269                                           uint8_t                       * p_encoded_data,
;;;270                                           uint16_t                      * p_offset,
;;;271                                           uint16_t                        max_size)
;;;272    {
000004  4606              MOV      r6,r0
000006  468b              MOV      r11,r1
000008  4696              MOV      lr,r2
00000a  461d              MOV      r5,r3
00000c  9c0e              LDR      r4,[sp,#0x38]
;;;273        int      i;
;;;274        bool     is_heading_written = false;
00000e  f04f0800          MOV      r8,#0
;;;275        uint16_t start_pos          = *p_offset;
000012  8820              LDRH     r0,[r4,#0]
000014  9003              STR      r0,[sp,#0xc]
;;;276        uint16_t length;
;;;277    
;;;278        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
000016  2700              MOVS     r7,#0
000018  e04a              B        |L16.176|
                  |L16.26|
;;;279        {
;;;280            uint32_t   err_code;
;;;281            uint8_t    encoded_size;
;;;282            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
00001a  6870              LDR      r0,[r6,#4]
00001c  eb000087          ADD      r0,r0,r7,LSL #2
000020  6800              LDR      r0,[r0,#0]
000022  9001              STR      r0,[sp,#4]
;;;283    
;;;284            // Find encoded uuid size.
;;;285            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
000024  2200              MOVS     r2,#0
000026  a902              ADD      r1,sp,#8
000028  a801              ADD      r0,sp,#4
00002a  df64              SVC      #0x64
00002c  4682              MOV      r10,r0
;;;286            VERIFY_SUCCESS(err_code);
00002e  bf00              NOP      
000030  f1ba0f00          CMP      r10,#0
000034  d003              BEQ      |L16.62|
000036  4650              MOV      r0,r10
                  |L16.56|
;;;287    
;;;288            // Check size.
;;;289            if (encoded_size == uuid_size)
;;;290            {
;;;291                uint8_t heading_bytes = (is_heading_written) ? 0 : AD_DATA_OFFSET;
;;;292    
;;;293                // Check for buffer overflow
;;;294                if (((*p_offset) + encoded_size + heading_bytes) > max_size)
;;;295                {
;;;296                    return NRF_ERROR_DATA_SIZE;
;;;297                }
;;;298    
;;;299                if (!is_heading_written)
;;;300                {
;;;301                    // Write AD structure heading.
;;;302                    *p_offset                 += AD_LENGTH_FIELD_SIZE;
;;;303                    p_encoded_data[*p_offset]  = adv_type;
;;;304                    *p_offset                 += AD_TYPE_FIELD_SIZE;
;;;305                    is_heading_written         = true;
;;;306                }
;;;307    
;;;308                // Write UUID.
;;;309                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_offset]);
;;;310                VERIFY_SUCCESS(err_code);
;;;311                *p_offset += encoded_size;
;;;312            }
;;;313        }
;;;314    
;;;315        if (is_heading_written)
;;;316        {
;;;317            // Write length.
;;;318            length = (*p_offset) - (start_pos + AD_LENGTH_FIELD_SIZE);
;;;319            // There is only 1 byte intended to encode length
;;;320            if (length > 0x00FF)
;;;321            {
;;;322                return NRF_ERROR_DATA_SIZE;
;;;323            }
;;;324            p_encoded_data[start_pos] = (uint8_t)length;
;;;325        }
;;;326    
;;;327        return NRF_SUCCESS;
;;;328    }
000038  b004              ADD      sp,sp,#0x10
00003a  e8bd9ff0          POP      {r4-r12,pc}
                  |L16.62|
00003e  bf00              NOP                            ;286
000040  f89d0008          LDRB     r0,[sp,#8]            ;289
000044  4570              CMP      r0,lr                 ;289
000046  d132              BNE      |L16.174|
000048  f1b80f00          CMP      r8,#0                 ;291
00004c  d001              BEQ      |L16.82|
00004e  2000              MOVS     r0,#0                 ;291
000050  e000              B        |L16.84|
                  |L16.82|
000052  2002              MOVS     r0,#2                 ;291
                  |L16.84|
000054  9000              STR      r0,[sp,#0]            ;291
000056  8820              LDRH     r0,[r4,#0]            ;294
000058  f89d1008          LDRB     r1,[sp,#8]            ;294
00005c  4401              ADD      r1,r1,r0              ;294
00005e  9800              LDR      r0,[sp,#0]            ;294
000060  4401              ADD      r1,r1,r0              ;294
000062  980f              LDR      r0,[sp,#0x3c]         ;294
000064  4281              CMP      r1,r0                 ;294
000066  dd01              BLE      |L16.108|
000068  200c              MOVS     r0,#0xc               ;296
00006a  e7e5              B        |L16.56|
                  |L16.108|
00006c  f1b80f00          CMP      r8,#0                 ;299
000070  d10a              BNE      |L16.136|
000072  8820              LDRH     r0,[r4,#0]            ;302
000074  1c40              ADDS     r0,r0,#1              ;302
000076  8020              STRH     r0,[r4,#0]            ;302
000078  8820              LDRH     r0,[r4,#0]            ;303
00007a  f805b000          STRB     r11,[r5,r0]           ;303
00007e  8820              LDRH     r0,[r4,#0]            ;304
000080  1c40              ADDS     r0,r0,#1              ;304
000082  8020              STRH     r0,[r4,#0]            ;304
000084  f04f0801          MOV      r8,#1                 ;305
                  |L16.136|
000088  8820              LDRH     r0,[r4,#0]            ;309
00008a  1942              ADDS     r2,r0,r5              ;309
00008c  a902              ADD      r1,sp,#8              ;309
00008e  a801              ADD      r0,sp,#4              ;309
000090  df64              SVC      #0x64                 ;309
000092  4682              MOV      r10,r0                ;309
000094  bf00              NOP                            ;310
000096  f1ba0f00          CMP      r10,#0                ;310
00009a  d001              BEQ      |L16.160|
00009c  4650              MOV      r0,r10                ;310
00009e  e7cb              B        |L16.56|
                  |L16.160|
0000a0  bf00              NOP                            ;310
0000a2  8820              LDRH     r0,[r4,#0]            ;311
0000a4  f89d1008          LDRB     r1,[sp,#8]            ;311
0000a8  4408              ADD      r0,r0,r1              ;311
0000aa  8020              STRH     r0,[r4,#0]            ;311
0000ac  bf00              NOP                            ;312
                  |L16.174|
0000ae  1c7f              ADDS     r7,r7,#1              ;278
                  |L16.176|
0000b0  8830              LDRH     r0,[r6,#0]            ;278
0000b2  42b8              CMP      r0,r7                 ;278
0000b4  dcb1              BGT      |L16.26|
0000b6  f1b80f00          CMP      r8,#0                 ;315
0000ba  d00d              BEQ      |L16.216|
0000bc  8821              LDRH     r1,[r4,#0]            ;318
0000be  9803              LDR      r0,[sp,#0xc]          ;318
0000c0  1c40              ADDS     r0,r0,#1              ;318
0000c2  1a08              SUBS     r0,r1,r0              ;318
0000c4  fa1ff980          UXTH     r9,r0                 ;318
0000c8  f1b90fff          CMP      r9,#0xff              ;320
0000cc  dd01              BLE      |L16.210|
0000ce  200c              MOVS     r0,#0xc               ;322
0000d0  e7b2              B        |L16.56|
                  |L16.210|
0000d2  9803              LDR      r0,[sp,#0xc]          ;324
0000d4  f8059000          STRB     r9,[r5,r0]            ;324
                  |L16.216|
0000d8  2000              MOVS     r0,#0                 ;327
0000da  e7ad              B        |L16.56|
;;;329    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\common\\ble_advdata.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7cce476b____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___13_ble_advdata_c_7cce476b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7cce476b____REVSH|
#line 402
|__asm___13_ble_advdata_c_7cce476b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7cce476b____RRX|
#line 587
|__asm___13_ble_advdata_c_7cce476b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
