; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\system_nrf52.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\system_nrf52.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\system_nrf52.crf RTE\Device\nRF52832_xxAA\system_nrf52.c]
                          THUMB

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;54     
;;;55     void SystemCoreClockUpdate(void)
000000  4801              LDR      r0,|L1.8|
;;;56     {
;;;57         SystemCoreClock = __SYSTEM_CLOCK_64M;
000002  4902              LDR      r1,|L1.12|
000004  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;58     }
000006  4770              BX       lr
;;;59     
                          ENDP

                  |L1.8|
                          DCD      0x03d09000
                  |L1.12|
                          DCD      SystemCoreClock

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;59     
;;;60     void SystemInit(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62         /* Enable SWO trace functionality. If ENABLE_SWO is not defined, SWO pin will be used as GPIO (see Product
;;;63            Specification to see which one). */
;;;64         #if defined (ENABLE_SWO)
;;;65             CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
;;;66             NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Serial << CLOCK_TRACECONFIG_TRACEMUX_Pos;
;;;67             NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;68         #endif
;;;69     
;;;70         /* Enable Trace functionality. If ENABLE_TRACE is not defined, TRACE pins will be used as GPIOs (see Product
;;;71            Specification to see which ones). */
;;;72         #if defined (ENABLE_TRACE)
;;;73             CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
;;;74             NRF_CLOCK->TRACECONFIG |= CLOCK_TRACECONFIG_TRACEMUX_Parallel << CLOCK_TRACECONFIG_TRACEMUX_Pos;
;;;75             NRF_P0->PIN_CNF[14] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;76             NRF_P0->PIN_CNF[15] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;77             NRF_P0->PIN_CNF[16] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;78             NRF_P0->PIN_CNF[18] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;79             NRF_P0->PIN_CNF[20] = (GPIO_PIN_CNF_DRIVE_H0H1 << GPIO_PIN_CNF_DRIVE_Pos) | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos) | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
;;;80         #endif
;;;81         
;;;82         /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
;;;83            for your device located at https://infocenter.nordicsemi.com/ */
;;;84         if (errata_12()){
000002  f7fffffe          BL       errata_12
000006  b128              CBZ      r0,|L2.20|
;;;85             *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
000008  488e              LDR      r0,|L2.580|
00000a  8800              LDRH     r0,[r0,#0]
00000c  f3c02004          UBFX     r0,r0,#8,#5
000010  498d              LDR      r1,|L2.584|
000012  6008              STR      r0,[r1,#0]
                  |L2.20|
;;;86         }
;;;87         
;;;88         /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
;;;89            for your device located at https://infocenter.nordicsemi.com/ */
;;;90         if (errata_16()){
000014  f7fffffe          BL       errata_16
000018  b110              CBZ      r0,|L2.32|
;;;91             *(volatile uint32_t *)0x4007C074 = 3131961357ul;
00001a  488c              LDR      r0,|L2.588|
00001c  498c              LDR      r1,|L2.592|
00001e  6748              STR      r0,[r1,#0x74]
                  |L2.32|
;;;92         }
;;;93     
;;;94         /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
;;;95            for your device located at https://infocenter.nordicsemi.com/ */
;;;96         if (errata_31()){
000020  f7fffffe          BL       errata_31
000024  b130              CBZ      r0,|L2.52|
;;;97             *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
000026  4887              LDR      r0,|L2.580|
000028  38e0              SUBS     r0,r0,#0xe0
00002a  6800              LDR      r0,[r0,#0]
00002c  f3c03042          UBFX     r0,r0,#13,#3
000030  4988              LDR      r1,|L2.596|
000032  6008              STR      r0,[r1,#0]
                  |L2.52|
;;;98         }
;;;99     
;;;100        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
;;;101           for your device located at https://infocenter.nordicsemi.com/ */
;;;102        if (errata_32()){
000034  f7fffffe          BL       errata_32
000038  b128              CBZ      r0,|L2.70|
;;;103            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
00003a  4887              LDR      r0,|L2.600|
00003c  6800              LDR      r0,[r0,#0]
00003e  f0207080          BIC      r0,r0,#0x1000000
000042  4985              LDR      r1,|L2.600|
000044  6008              STR      r0,[r1,#0]
                  |L2.70|
;;;104        }
;;;105    
;;;106        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
;;;107           for your device located at https://infocenter.nordicsemi.com/  */
;;;108        if (errata_36()){
000046  f7fffffe          BL       errata_36
00004a  b148              CBZ      r0,|L2.96|
;;;109            NRF_CLOCK->EVENTS_DONE = 0;
00004c  2000              MOVS     r0,#0
00004e  4983              LDR      r1,|L2.604|
000050  6008              STR      r0,[r1,#0]
;;;110            NRF_CLOCK->EVENTS_CTTO = 0;
000052  f04f4180          MOV      r1,#0x40000000
000056  f8c10110          STR      r0,[r1,#0x110]
;;;111            NRF_CLOCK->CTIV = 0;
00005a  497e              LDR      r1,|L2.596|
00005c  1f09              SUBS     r1,r1,#4
00005e  6008              STR      r0,[r1,#0]
                  |L2.96|
;;;112        }
;;;113    
;;;114        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
;;;115           for your device located at https://infocenter.nordicsemi.com/  */
;;;116        if (errata_37()){
000060  f7fffffe          BL       errata_37
000064  b118              CBZ      r0,|L2.110|
;;;117            *(volatile uint32_t *)0x400005A0 = 0x3;
000066  2003              MOVS     r0,#3
000068  497a              LDR      r1,|L2.596|
00006a  3164              ADDS     r1,r1,#0x64
00006c  6008              STR      r0,[r1,#0]
                  |L2.110|
;;;118        }
;;;119    
;;;120        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
;;;121           for your device located at https://infocenter.nordicsemi.com/  */
;;;122        if (errata_57()){
00006e  f7fffffe          BL       errata_57
000072  b168              CBZ      r0,|L2.144|
;;;123            *(volatile uint32_t *)0x40005610 = 0x00000005;
000074  2005              MOVS     r0,#5
000076  497a              LDR      r1,|L2.608|
000078  6008              STR      r0,[r1,#0]
;;;124            *(volatile uint32_t *)0x40005688 = 0x00000001;
00007a  2001              MOVS     r0,#1
00007c  4978              LDR      r1,|L2.608|
00007e  3178              ADDS     r1,r1,#0x78
000080  6008              STR      r0,[r1,#0]
;;;125            *(volatile uint32_t *)0x40005618 = 0x00000000;
000082  2000              MOVS     r0,#0
000084  4976              LDR      r1,|L2.608|
000086  3108              ADDS     r1,r1,#8
000088  6008              STR      r0,[r1,#0]
;;;126            *(volatile uint32_t *)0x40005614 = 0x0000003F;
00008a  203f              MOVS     r0,#0x3f
00008c  1f09              SUBS     r1,r1,#4
00008e  6008              STR      r0,[r1,#0]
                  |L2.144|
;;;127        }
;;;128    
;;;129        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
;;;130           for your device located at https://infocenter.nordicsemi.com/  */
;;;131        if (errata_66()){
000090  f7fffffe          BL       errata_66
000094  2800              CMP      r0,#0
000096  d055              BEQ      |L2.324|
;;;132            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
000098  486a              LDR      r0,|L2.580|
00009a  30e0              ADDS     r0,r0,#0xe0
00009c  6800              LDR      r0,[r0,#0]
00009e  4971              LDR      r1,|L2.612|
0000a0  6008              STR      r0,[r1,#0]
;;;133            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
0000a2  4868              LDR      r0,|L2.580|
0000a4  30e4              ADDS     r0,r0,#0xe4
0000a6  6800              LDR      r0,[r0,#0]
0000a8  1d09              ADDS     r1,r1,#4
0000aa  6008              STR      r0,[r1,#0]
;;;134            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
0000ac  4865              LDR      r0,|L2.580|
0000ae  30e8              ADDS     r0,r0,#0xe8
0000b0  6800              LDR      r0,[r0,#0]
0000b2  1d09              ADDS     r1,r1,#4
0000b4  6008              STR      r0,[r1,#0]
;;;135            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
0000b6  4863              LDR      r0,|L2.580|
0000b8  30ec              ADDS     r0,r0,#0xec
0000ba  6800              LDR      r0,[r0,#0]
0000bc  1d09              ADDS     r1,r1,#4
0000be  6008              STR      r0,[r1,#0]
;;;136            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
0000c0  4860              LDR      r0,|L2.580|
0000c2  30f0              ADDS     r0,r0,#0xf0
0000c4  6800              LDR      r0,[r0,#0]
0000c6  1d09              ADDS     r1,r1,#4
0000c8  6008              STR      r0,[r1,#0]
;;;137            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
0000ca  485e              LDR      r0,|L2.580|
0000cc  30f4              ADDS     r0,r0,#0xf4
0000ce  6800              LDR      r0,[r0,#0]
0000d0  1d09              ADDS     r1,r1,#4
0000d2  6008              STR      r0,[r1,#0]
;;;138            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
0000d4  485b              LDR      r0,|L2.580|
0000d6  30f8              ADDS     r0,r0,#0xf8
0000d8  6800              LDR      r0,[r0,#0]
0000da  4962              LDR      r1,|L2.612|
0000dc  3120              ADDS     r1,r1,#0x20
0000de  6008              STR      r0,[r1,#0]
;;;139            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
0000e0  4858              LDR      r0,|L2.580|
0000e2  30fc              ADDS     r0,r0,#0xfc
0000e4  6800              LDR      r0,[r0,#0]
0000e6  1d09              ADDS     r1,r1,#4
0000e8  6008              STR      r0,[r1,#0]
;;;140            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
0000ea  485f              LDR      r0,|L2.616|
0000ec  6800              LDR      r0,[r0,#0]
0000ee  1d09              ADDS     r1,r1,#4
0000f0  6008              STR      r0,[r1,#0]
;;;141            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
0000f2  485d              LDR      r0,|L2.616|
0000f4  1d00              ADDS     r0,r0,#4
0000f6  6800              LDR      r0,[r0,#0]
0000f8  1d09              ADDS     r1,r1,#4
0000fa  6008              STR      r0,[r1,#0]
;;;142            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
0000fc  485a              LDR      r0,|L2.616|
0000fe  3008              ADDS     r0,r0,#8
000100  6800              LDR      r0,[r0,#0]
000102  1d09              ADDS     r1,r1,#4
000104  6008              STR      r0,[r1,#0]
;;;143            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
000106  4858              LDR      r0,|L2.616|
000108  300c              ADDS     r0,r0,#0xc
00010a  6800              LDR      r0,[r0,#0]
00010c  1d09              ADDS     r1,r1,#4
00010e  6008              STR      r0,[r1,#0]
;;;144            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
000110  4855              LDR      r0,|L2.616|
000112  3010              ADDS     r0,r0,#0x10
000114  6800              LDR      r0,[r0,#0]
000116  4953              LDR      r1,|L2.612|
000118  3140              ADDS     r1,r1,#0x40
00011a  6008              STR      r0,[r1,#0]
;;;145            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
00011c  4852              LDR      r0,|L2.616|
00011e  3014              ADDS     r0,r0,#0x14
000120  6800              LDR      r0,[r0,#0]
000122  1d09              ADDS     r1,r1,#4
000124  6008              STR      r0,[r1,#0]
;;;146            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
000126  4850              LDR      r0,|L2.616|
000128  3018              ADDS     r0,r0,#0x18
00012a  6800              LDR      r0,[r0,#0]
00012c  1d09              ADDS     r1,r1,#4
00012e  6008              STR      r0,[r1,#0]
;;;147            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
000130  484d              LDR      r0,|L2.616|
000132  301c              ADDS     r0,r0,#0x1c
000134  6800              LDR      r0,[r0,#0]
000136  1d09              ADDS     r1,r1,#4
000138  6008              STR      r0,[r1,#0]
;;;148            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
00013a  484b              LDR      r0,|L2.616|
00013c  3020              ADDS     r0,r0,#0x20
00013e  6800              LDR      r0,[r0,#0]
000140  1d09              ADDS     r1,r1,#4
000142  6008              STR      r0,[r1,#0]
                  |L2.324|
;;;149        }
;;;150    
;;;151        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
;;;152           for your device located at https://infocenter.nordicsemi.com/  */
;;;153        if (errata_108()){
000144  f7fffffe          BL       errata_108
000148  b130              CBZ      r0,|L2.344|
;;;154            *(volatile uint32_t *)0x40000EE4 = *(volatile uint32_t *)0x10000258 & 0x0000004F;
00014a  483e              LDR      r0,|L2.580|
00014c  38cc              SUBS     r0,r0,#0xcc
00014e  6800              LDR      r0,[r0,#0]
000150  f000004f          AND      r0,r0,#0x4f
000154  4945              LDR      r1,|L2.620|
000156  6008              STR      r0,[r1,#0]
                  |L2.344|
;;;155        }
;;;156        
;;;157        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
;;;158           for your device located at https://infocenter.nordicsemi.com/  */
;;;159        if (errata_136()){
000158  f7fffffe          BL       errata_136
00015c  b140              CBZ      r0,|L2.368|
;;;160            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
00015e  4844              LDR      r0,|L2.624|
000160  6800              LDR      r0,[r0,#0]
000162  f0000001          AND      r0,r0,#1
000166  b118              CBZ      r0,|L2.368|
;;;161                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
000168  f06f0001          MVN      r0,#1
00016c  4940              LDR      r1,|L2.624|
00016e  6008              STR      r0,[r1,#0]
                  |L2.368|
;;;162            }
;;;163        }
;;;164        
;;;165        /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
;;;166         * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
;;;167         * operations are not used in your code. */
;;;168        #if (__FPU_USED == 1)
;;;169            SCB->CPACR |= (3UL << 20) | (3UL << 22);
000170  4839              LDR      r0,|L2.600|
000172  3874              SUBS     r0,r0,#0x74
000174  6800              LDR      r0,[r0,#0]
000176  f4400070          ORR      r0,r0,#0xf00000
00017a  4937              LDR      r1,|L2.600|
00017c  3974              SUBS     r1,r1,#0x74
00017e  6008              STR      r0,[r1,#0]
;;;170            __DSB();
000180  bf00              NOP      
000182  bf00              NOP      
000184  bf00              NOP      
000186  f3bf8f4f          DSB      
00018a  bf00              NOP      
00018c  bf00              NOP      
00018e  bf00              NOP      
;;;171            __ISB();
000190  bf00              NOP      
000192  bf00              NOP      
000194  bf00              NOP      
000196  f3bf8f6f          ISB      
00019a  bf00              NOP      
00019c  bf00              NOP      
00019e  bf00              NOP      
;;;172        #endif
;;;173    
;;;174        /* Configure NFCT pins as GPIOs if NFCT is not to be used in your code. If CONFIG_NFCT_PINS_AS_GPIOS is not defined,
;;;175           two GPIOs (see Product Specification to see which ones) will be reserved for NFC and will not be available as
;;;176           normal GPIOs. */
;;;177        #if defined (CONFIG_NFCT_PINS_AS_GPIOS)
;;;178            if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
;;;179                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
;;;180                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;181                NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
;;;182                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;183                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
;;;184                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
;;;185                NVIC_SystemReset();
;;;186            }
;;;187        #endif
;;;188    
;;;189        /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
;;;190          defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
;;;191          reserved for PinReset and not available as normal GPIO. */
;;;192        #if defined (CONFIG_GPIO_AS_PINRESET)
;;;193            if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
0001a0  4834              LDR      r0,|L2.628|
0001a2  6800              LDR      r0,[r0,#0]
0001a4  f0004000          AND      r0,r0,#0x80000000
0001a8  b928              CBNZ     r0,|L2.438|
;;;194                ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
0001aa  4832              LDR      r0,|L2.628|
0001ac  1d00              ADDS     r0,r0,#4
0001ae  6800              LDR      r0,[r0,#0]
0001b0  f0004000          AND      r0,r0,#0x80000000
0001b4  b3f0              CBZ      r0,|L2.564|
                  |L2.438|
;;;195                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
0001b6  2001              MOVS     r0,#1
0001b8  492f              LDR      r1,|L2.632|
0001ba  6008              STR      r0,[r1,#0]
;;;196                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001bc  bf00              NOP      
                  |L2.446|
0001be  482f              LDR      r0,|L2.636|
0001c0  6800              LDR      r0,[r0,#0]
0001c2  2800              CMP      r0,#0
0001c4  d0fb              BEQ      |L2.446|
;;;197                NRF_UICR->PSELRESET[0] = 21;
0001c6  2015              MOVS     r0,#0x15
0001c8  492a              LDR      r1,|L2.628|
0001ca  6008              STR      r0,[r1,#0]
;;;198                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001cc  bf00              NOP      
                  |L2.462|
0001ce  482b              LDR      r0,|L2.636|
0001d0  6800              LDR      r0,[r0,#0]
0001d2  2800              CMP      r0,#0
0001d4  d0fb              BEQ      |L2.462|
;;;199                NRF_UICR->PSELRESET[1] = 21;
0001d6  2115              MOVS     r1,#0x15
0001d8  4826              LDR      r0,|L2.628|
0001da  1d00              ADDS     r0,r0,#4
0001dc  6001              STR      r1,[r0,#0]
;;;200                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001de  bf00              NOP      
                  |L2.480|
0001e0  4826              LDR      r0,|L2.636|
0001e2  6800              LDR      r0,[r0,#0]
0001e4  2800              CMP      r0,#0
0001e6  d0fb              BEQ      |L2.480|
;;;201                NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
0001e8  2000              MOVS     r0,#0
0001ea  4923              LDR      r1,|L2.632|
0001ec  6008              STR      r0,[r1,#0]
;;;202                while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
0001ee  bf00              NOP      
                  |L2.496|
0001f0  4822              LDR      r0,|L2.636|
0001f2  6800              LDR      r0,[r0,#0]
0001f4  2800              CMP      r0,#0
0001f6  d0fb              BEQ      |L2.496|
;;;203                NVIC_SystemReset();
0001f8  bf00              NOP      
0001fa  bf00              NOP      
0001fc  bf00              NOP      
0001fe  bf00              NOP      
000200  bf00              NOP      
000202  f3bf8f4f          DSB      
000206  bf00              NOP      
000208  bf00              NOP      
00020a  bf00              NOP      
00020c  4812              LDR      r0,|L2.600|
00020e  38f0              SUBS     r0,r0,#0xf0
000210  6800              LDR      r0,[r0,#0]
000212  f40060e0          AND      r0,r0,#0x700
000216  491a              LDR      r1,|L2.640|
000218  4308              ORRS     r0,r0,r1
00021a  1d00              ADDS     r0,r0,#4
00021c  490e              LDR      r1,|L2.600|
00021e  39f0              SUBS     r1,r1,#0xf0
000220  6008              STR      r0,[r1,#0]
000222  bf00              NOP      
000224  bf00              NOP      
000226  bf00              NOP      
000228  f3bf8f4f          DSB      
00022c  bf00              NOP      
00022e  bf00              NOP      
000230  bf00              NOP      
000232  e000              B        |L2.566|
                  |L2.564|
000234  e002              B        |L2.572|
                  |L2.566|
000236  bf00              NOP      
                  |L2.568|
000238  bf00              NOP      
00023a  e7fd              B        |L2.568|
                  |L2.572|
;;;204            }
;;;205        #endif
;;;206    
;;;207        SystemCoreClockUpdate();
00023c  f7fffffe          BL       SystemCoreClockUpdate
;;;208    }
000240  bd10              POP      {r4,pc}
;;;209    
                          ENDP

000242  0000              DCW      0x0000
                  |L2.580|
                          DCD      0x10000324
                  |L2.584|
                          DCD      0x40013540
                  |L2.588|
                          DCD      0xbaadf00d
                  |L2.592|
                          DCD      0x4007c000
                  |L2.596|
                          DCD      0x4000053c
                  |L2.600|
                          DCD      0xe000edfc
                  |L2.604|
                          DCD      0x4000010c
                  |L2.608|
                          DCD      0x40005610
                  |L2.612|
                          DCD      0x4000c520
                  |L2.616|
                          DCD      0x10000424
                  |L2.620|
                          DCD      0x40000ee4
                  |L2.624|
                          DCD      0x40000400
                  |L2.628|
                          DCD      0x10001200
                  |L2.632|
                          DCD      0x4001e504
                  |L2.636|
                          DCD      0x4001e400
                  |L2.640|
                          DCD      0x05fa0000

                          AREA ||i.errata_108||, CODE, READONLY, ALIGN=2

                  errata_108 PROC
;;;317    
;;;318    static bool errata_108(void)
000000  4813              LDR      r0,|L3.80|
;;;319    {
;;;320        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L3.74|
000008  4811              LDR      r0,|L3.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L3.74|
;;;321            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L3.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L3.38|
;;;322                return true;
000022  2001              MOVS     r0,#1
                  |L3.36|
;;;323            }
;;;324            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;325                return true;
;;;326            }
;;;327            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;328                return true;
;;;329            }
;;;330        }
;;;331    
;;;332        return false;
;;;333    }
000024  4770              BX       lr
                  |L3.38|
000026  480a              LDR      r0,|L3.80|
000028  3008              ADDS     r0,r0,#8              ;324
00002a  7800              LDRB     r0,[r0,#0]            ;324
00002c  f00000f0          AND      r0,r0,#0xf0           ;324
000030  2840              CMP      r0,#0x40              ;324
000032  d101              BNE      |L3.56|
000034  2001              MOVS     r0,#1                 ;325
000036  e7f5              B        |L3.36|
                  |L3.56|
000038  4805              LDR      r0,|L3.80|
00003a  3008              ADDS     r0,r0,#8              ;327
00003c  7800              LDRB     r0,[r0,#0]            ;327
00003e  f00000f0          AND      r0,r0,#0xf0           ;327
000042  2850              CMP      r0,#0x50              ;327
000044  d101              BNE      |L3.74|
000046  2001              MOVS     r0,#1                 ;328
000048  e7ec              B        |L3.36|
                  |L3.74|
00004a  2000              MOVS     r0,#0                 ;332
00004c  e7ea              B        |L3.36|
;;;334    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_12||, CODE, READONLY, ALIGN=2

                  errata_12 PROC
;;;210    
;;;211    static bool errata_12(void)
000000  4813              LDR      r0,|L4.80|
;;;212    {
;;;213        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L4.74|
000008  4811              LDR      r0,|L4.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L4.74|
;;;214            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L4.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L4.38|
;;;215                return true;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;216            }
;;;217            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;218                return true;
;;;219            }
;;;220            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;221                return true;
;;;222            }
;;;223        }
;;;224    
;;;225        return false;
;;;226    }
000024  4770              BX       lr
                  |L4.38|
000026  480a              LDR      r0,|L4.80|
000028  3008              ADDS     r0,r0,#8              ;217
00002a  7800              LDRB     r0,[r0,#0]            ;217
00002c  f00000f0          AND      r0,r0,#0xf0           ;217
000030  2840              CMP      r0,#0x40              ;217
000032  d101              BNE      |L4.56|
000034  2001              MOVS     r0,#1                 ;218
000036  e7f5              B        |L4.36|
                  |L4.56|
000038  4805              LDR      r0,|L4.80|
00003a  3008              ADDS     r0,r0,#8              ;220
00003c  7800              LDRB     r0,[r0,#0]            ;220
00003e  f00000f0          AND      r0,r0,#0xf0           ;220
000042  2850              CMP      r0,#0x50              ;220
000044  d101              BNE      |L4.74|
000046  2001              MOVS     r0,#1                 ;221
000048  e7ec              B        |L4.36|
                  |L4.74|
00004a  2000              MOVS     r0,#0                 ;225
00004c  e7ea              B        |L4.36|
;;;227    
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_136||, CODE, READONLY, ALIGN=2

                  errata_136 PROC
;;;335    
;;;336    static bool errata_136(void)
000000  4813              LDR      r0,|L5.80|
;;;337    {
;;;338        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L5.74|
000008  4811              LDR      r0,|L5.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L5.74|
;;;339            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L5.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L5.38|
;;;340                return true;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;341            }
;;;342            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;343                return true;
;;;344            }
;;;345            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;346                return true;
;;;347            }
;;;348        }
;;;349    
;;;350        return false;
;;;351    }
000024  4770              BX       lr
                  |L5.38|
000026  480a              LDR      r0,|L5.80|
000028  3008              ADDS     r0,r0,#8              ;342
00002a  7800              LDRB     r0,[r0,#0]            ;342
00002c  f00000f0          AND      r0,r0,#0xf0           ;342
000030  2840              CMP      r0,#0x40              ;342
000032  d101              BNE      |L5.56|
000034  2001              MOVS     r0,#1                 ;343
000036  e7f5              B        |L5.36|
                  |L5.56|
000038  4805              LDR      r0,|L5.80|
00003a  3008              ADDS     r0,r0,#8              ;345
00003c  7800              LDRB     r0,[r0,#0]            ;345
00003e  f00000f0          AND      r0,r0,#0xf0           ;345
000042  2850              CMP      r0,#0x50              ;345
000044  d101              BNE      |L5.74|
000046  2001              MOVS     r0,#1                 ;346
000048  e7ec              B        |L5.36|
                  |L5.74|
00004a  2000              MOVS     r0,#0                 ;350
00004c  e7ea              B        |L5.36|
;;;352    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_16||, CODE, READONLY, ALIGN=2

                  errata_16 PROC
;;;227    
;;;228    static bool errata_16(void)
000000  480a              LDR      r0,|L6.44|
;;;229    {
;;;230        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L6.38|
000008  4808              LDR      r0,|L6.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L6.38|
;;;231            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L6.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L6.38|
;;;232                return true;
000022  2001              MOVS     r0,#1
                  |L6.36|
;;;233            }
;;;234        }
;;;235    
;;;236        return false;
;;;237    }
000024  4770              BX       lr
                  |L6.38|
000026  2000              MOVS     r0,#0                 ;236
000028  e7fc              B        |L6.36|
;;;238    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_31||, CODE, READONLY, ALIGN=2

                  errata_31 PROC
;;;238    
;;;239    static bool errata_31(void)
000000  4813              LDR      r0,|L7.80|
;;;240    {
;;;241        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L7.74|
000008  4811              LDR      r0,|L7.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L7.74|
;;;242            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L7.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L7.38|
;;;243                return true;
000022  2001              MOVS     r0,#1
                  |L7.36|
;;;244            }
;;;245            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;246                return true;
;;;247            }
;;;248            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;249                return true;
;;;250            }
;;;251        }
;;;252    
;;;253        return false;
;;;254    }
000024  4770              BX       lr
                  |L7.38|
000026  480a              LDR      r0,|L7.80|
000028  3008              ADDS     r0,r0,#8              ;245
00002a  7800              LDRB     r0,[r0,#0]            ;245
00002c  f00000f0          AND      r0,r0,#0xf0           ;245
000030  2840              CMP      r0,#0x40              ;245
000032  d101              BNE      |L7.56|
000034  2001              MOVS     r0,#1                 ;246
000036  e7f5              B        |L7.36|
                  |L7.56|
000038  4805              LDR      r0,|L7.80|
00003a  3008              ADDS     r0,r0,#8              ;248
00003c  7800              LDRB     r0,[r0,#0]            ;248
00003e  f00000f0          AND      r0,r0,#0xf0           ;248
000042  2850              CMP      r0,#0x50              ;248
000044  d101              BNE      |L7.74|
000046  2001              MOVS     r0,#1                 ;249
000048  e7ec              B        |L7.36|
                  |L7.74|
00004a  2000              MOVS     r0,#0                 ;253
00004c  e7ea              B        |L7.36|
;;;255    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_32||, CODE, READONLY, ALIGN=2

                  errata_32 PROC
;;;255    
;;;256    static bool errata_32(void)
000000  480a              LDR      r0,|L8.44|
;;;257    {
;;;258        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L8.38|
000008  4808              LDR      r0,|L8.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L8.38|
;;;259            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L8.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L8.38|
;;;260                return true;
000022  2001              MOVS     r0,#1
                  |L8.36|
;;;261            }
;;;262        }
;;;263    
;;;264        return false;
;;;265    }
000024  4770              BX       lr
                  |L8.38|
000026  2000              MOVS     r0,#0                 ;264
000028  e7fc              B        |L8.36|
;;;266    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_36||, CODE, READONLY, ALIGN=2

                  errata_36 PROC
;;;266    
;;;267    static bool errata_36(void)
000000  4813              LDR      r0,|L9.80|
;;;268    {
;;;269        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d120              BNE      |L9.74|
000008  4811              LDR      r0,|L9.80|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b9d0              CBNZ     r0,|L9.74|
;;;270            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  480e              LDR      r0,|L9.80|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L9.38|
;;;271                return true;
000022  2001              MOVS     r0,#1
                  |L9.36|
;;;272            }
;;;273            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
;;;274                return true;
;;;275            }
;;;276            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
;;;277                return true;
;;;278            }
;;;279        }
;;;280    
;;;281        return false;
;;;282    }
000024  4770              BX       lr
                  |L9.38|
000026  480a              LDR      r0,|L9.80|
000028  3008              ADDS     r0,r0,#8              ;273
00002a  7800              LDRB     r0,[r0,#0]            ;273
00002c  f00000f0          AND      r0,r0,#0xf0           ;273
000030  2840              CMP      r0,#0x40              ;273
000032  d101              BNE      |L9.56|
000034  2001              MOVS     r0,#1                 ;274
000036  e7f5              B        |L9.36|
                  |L9.56|
000038  4805              LDR      r0,|L9.80|
00003a  3008              ADDS     r0,r0,#8              ;276
00003c  7800              LDRB     r0,[r0,#0]            ;276
00003e  f00000f0          AND      r0,r0,#0xf0           ;276
000042  2850              CMP      r0,#0x50              ;276
000044  d101              BNE      |L9.74|
000046  2001              MOVS     r0,#1                 ;277
000048  e7ec              B        |L9.36|
                  |L9.74|
00004a  2000              MOVS     r0,#0                 ;281
00004c  e7ea              B        |L9.36|
;;;283    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      0xf0000fe0

                          AREA ||i.errata_37||, CODE, READONLY, ALIGN=2

                  errata_37 PROC
;;;283    
;;;284    static bool errata_37(void)
000000  480a              LDR      r0,|L10.44|
;;;285    {
;;;286        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L10.38|
000008  4808              LDR      r0,|L10.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L10.38|
;;;287            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L10.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L10.38|
;;;288                return true;
000022  2001              MOVS     r0,#1
                  |L10.36|
;;;289            }
;;;290        }
;;;291    
;;;292        return false;
;;;293    }
000024  4770              BX       lr
                  |L10.38|
000026  2000              MOVS     r0,#0                 ;292
000028  e7fc              B        |L10.36|
;;;294    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_57||, CODE, READONLY, ALIGN=2

                  errata_57 PROC
;;;294    
;;;295    static bool errata_57(void)
000000  480a              LDR      r0,|L11.44|
;;;296    {
;;;297        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L11.38|
000008  4808              LDR      r0,|L11.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L11.38|
;;;298            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
000014  4805              LDR      r0,|L11.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2830              CMP      r0,#0x30
000020  d101              BNE      |L11.38|
;;;299                return true;
000022  2001              MOVS     r0,#1
                  |L11.36|
;;;300            }
;;;301        }
;;;302    
;;;303        return false;
;;;304    }
000024  4770              BX       lr
                  |L11.38|
000026  2000              MOVS     r0,#0                 ;303
000028  e7fc              B        |L11.36|
;;;305    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0xf0000fe0

                          AREA ||i.errata_66||, CODE, READONLY, ALIGN=2

                  errata_66 PROC
;;;305    
;;;306    static bool errata_66(void)
000000  480a              LDR      r0,|L12.44|
;;;307    {
;;;308        if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
000002  7800              LDRB     r0,[r0,#0]
000004  2806              CMP      r0,#6
000006  d10e              BNE      |L12.38|
000008  4808              LDR      r0,|L12.44|
00000a  1d00              ADDS     r0,r0,#4
00000c  7800              LDRB     r0,[r0,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  b940              CBNZ     r0,|L12.38|
;;;309            if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
000014  4805              LDR      r0,|L12.44|
000016  3008              ADDS     r0,r0,#8
000018  7800              LDRB     r0,[r0,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  2850              CMP      r0,#0x50
000020  d101              BNE      |L12.38|
;;;310                return true;
000022  2001              MOVS     r0,#1
                  |L12.36|
;;;311            }
;;;312        }
;;;313    
;;;314        return false;
;;;315    }
000024  4770              BX       lr
                  |L12.38|
000026  2000              MOVS     r0,#0                 ;314
000028  e7fc              B        |L12.36|
;;;316    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0xf0000fe0

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                  ||__tagsym$$used||
                          DCD      0x03d09000

;*** Start embedded assembler ***

#line 1 "RTE\\Device\\nRF52832_xxAA\\system_nrf52.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_system_nrf52_c_5d646a67____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____REVSH|
#line 402
|__asm___14_system_nrf52_c_5d646a67____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_system_nrf52_c_5d646a67____RRX|
#line 587
|__asm___14_system_nrf52_c_5d646a67____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
