; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\ble_conn_params.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\ble_conn_params.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\ble_conn_params.crf ..\..\..\..\..\..\components\ble\common\ble_conn_params.c]
                          THUMB

                          AREA ||i.ble_conn_params_change_conn_params||, CODE, READONLY, ALIGN=2

                  ble_conn_params_change_conn_params PROC
;;;542    
;;;543    ret_code_t ble_conn_params_change_conn_params(uint16_t                conn_handle,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;544                                                  ble_gap_conn_params_t * p_new_params)
;;;545    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;546        ret_code_t                   err_code   = BLE_ERROR_INVALID_CONN_HANDLE;
000008  f2430602          MOV      r6,#0x3002
;;;547        ble_conn_params_instance_t * p_instance = instance_get(conn_handle);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       instance_get
000012  4604              MOV      r4,r0
;;;548    
;;;549        if (p_new_params == NULL)
000014  b905              CBNZ     r5,|L1.24|
;;;550        {
;;;551            p_new_params = &m_preferred_conn_params;
000016  4d0a              LDR      r5,|L1.64|
                  |L1.24|
;;;552        }
;;;553    
;;;554        if (p_instance != NULL)
000018  b174              CBZ      r4,|L1.56|
;;;555        {
;;;556            // Send request to central.
;;;557            err_code = sd_ble_gap_conn_param_update(conn_handle, p_new_params);
00001a  4629              MOV      r1,r5
00001c  4638              MOV      r0,r7
00001e  df75              SVC      #0x75
000020  4606              MOV      r6,r0
;;;558            if (err_code == NRF_SUCCESS)
000022  b94e              CBNZ     r6,|L1.56|
;;;559            {
;;;560                p_instance->params_ok             = false;
000024  2000              MOVS     r0,#0
000026  7260              STRB     r0,[r4,#9]
;;;561                p_instance->update_count          = 1;
000028  2001              MOVS     r0,#1
00002a  7220              STRB     r0,[r4,#8]
;;;562                p_instance->preferred_conn_params = *p_new_params;
00002c  6828              LDR      r0,[r5,#0]
00002e  f8c4000a          STR      r0,[r4,#0xa]
000032  6868              LDR      r0,[r5,#4]
000034  f8c4000e          STR      r0,[r4,#0xe]
                  |L1.56|
;;;563            }
;;;564        }
;;;565    
;;;566        return err_code;
000038  4630              MOV      r0,r6
;;;567    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;568    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      m_preferred_conn_params

                          AREA ||i.ble_conn_params_init||, CODE, READONLY, ALIGN=2

                  ble_conn_params_init PROC
;;;251    
;;;252    ret_code_t ble_conn_params_init(const ble_conn_params_init_t * p_init)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;253    {
000004  4604              MOV      r4,r0
;;;254        ret_code_t err_code;
;;;255    
;;;256        VERIFY_PARAM_NOT_NULL(p_init);
000006  bf00              NOP      
000008  b914              CBNZ     r4,|L2.16|
00000a  200e              MOVS     r0,#0xe
                  |L2.12|
;;;257    
;;;258        m_conn_params_config = *p_init;
;;;259        m_conn_params_config.p_conn_params = &m_preferred_conn_params;
;;;260    
;;;261        if (p_init->p_conn_params != NULL)
;;;262        {
;;;263            // Set the connection params in stack.
;;;264            err_code = sd_ble_gap_ppcp_set(p_init->p_conn_params);
;;;265            if (err_code != NRF_SUCCESS)
;;;266            {
;;;267                return err_code;
;;;268            }
;;;269            m_preferred_conn_params = *p_init->p_conn_params;
;;;270        }
;;;271        else
;;;272        {
;;;273            // Get the (default) connection params from stack.
;;;274            err_code = sd_ble_gap_ppcp_get(&m_preferred_conn_params);
;;;275            if (err_code != NRF_SUCCESS)
;;;276            {
;;;277                return err_code;
;;;278            }
;;;279        }
;;;280    
;;;281        //lint -save -e681 "Loop not entered" when NRF_BLE_CONN_PARAMS_N_INSTANCES is 0
;;;282        for (uint32_t i = 0; i < NRF_BLE_CONN_PARAMS_N_INSTANCES; i++)
;;;283        {
;;;284            ble_conn_params_instance_t * p_instance = &m_conn_params_instances[i];
;;;285    
;;;286            instance_free(p_instance);
;;;287            p_instance->timer_id = &m_timer_data[i];
;;;288    
;;;289            err_code = app_timer_create(&p_instance->timer_id,
;;;290                                APP_TIMER_MODE_SINGLE_SHOT,
;;;291                                update_timeout_handler);
;;;292            if (err_code != NRF_SUCCESS)
;;;293            {
;;;294                return NRF_ERROR_INTERNAL;
;;;295            }
;;;296        }
;;;297        //lint -restore
;;;298    
;;;299        return NRF_SUCCESS;
;;;300    }
00000c  e8bd81f0          POP      {r4-r8,pc}
                  |L2.16|
000010  bf00              NOP                            ;256
000012  221c              MOVS     r2,#0x1c              ;258
000014  4621              MOV      r1,r4                 ;258
000016  481c              LDR      r0,|L2.136|
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  481b              LDR      r0,|L2.140|
00001e  491a              LDR      r1,|L2.136|
000020  6008              STR      r0,[r1,#0]            ;259  ; m_conn_params_config
000022  6820              LDR      r0,[r4,#0]            ;261
000024  b160              CBZ      r0,|L2.64|
000026  6820              LDR      r0,[r4,#0]            ;264
000028  df7a              SVC      #0x7a                 ;264
00002a  4605              MOV      r5,r0                 ;264
00002c  b10d              CBZ      r5,|L2.50|
00002e  4628              MOV      r0,r5                 ;267
000030  e7ec              B        |L2.12|
                  |L2.50|
000032  4816              LDR      r0,|L2.140|
000034  6821              LDR      r1,[r4,#0]            ;269
000036  680a              LDR      r2,[r1,#0]            ;269
000038  6002              STR      r2,[r0,#0]            ;269  ; m_preferred_conn_params
00003a  6849              LDR      r1,[r1,#4]            ;269
00003c  6041              STR      r1,[r0,#4]            ;269  ; m_preferred_conn_params
00003e  e005              B        |L2.76|
                  |L2.64|
000040  4812              LDR      r0,|L2.140|
000042  df7b              SVC      #0x7b                 ;274
000044  4605              MOV      r5,r0                 ;274
000046  b10d              CBZ      r5,|L2.76|
000048  4628              MOV      r0,r5                 ;277
00004a  e7df              B        |L2.12|
                  |L2.76|
00004c  2600              MOVS     r6,#0                 ;282
00004e  e017              B        |L2.128|
                  |L2.80|
000050  eb060086          ADD      r0,r6,r6,LSL #2       ;284
000054  490e              LDR      r1,|L2.144|
000056  eb010780          ADD      r7,r1,r0,LSL #2       ;284
00005a  bf00              NOP                            ;286
00005c  f64f70ff          MOV      r0,#0xffff            ;286
000060  8038              STRH     r0,[r7,#0]            ;286
000062  bf00              NOP                            ;286
000064  480b              LDR      r0,|L2.148|
000066  eb001046          ADD      r0,r0,r6,LSL #5       ;287
00006a  6078              STR      r0,[r7,#4]            ;287
00006c  4a0a              LDR      r2,|L2.152|
00006e  2100              MOVS     r1,#0                 ;289
000070  1d38              ADDS     r0,r7,#4              ;289
000072  f7fffffe          BL       app_timer_create
000076  4605              MOV      r5,r0                 ;289
000078  b10d              CBZ      r5,|L2.126|
00007a  2003              MOVS     r0,#3                 ;294
00007c  e7c6              B        |L2.12|
                  |L2.126|
00007e  1c76              ADDS     r6,r6,#1              ;282
                  |L2.128|
000080  2e00              CMP      r6,#0                 ;282
000082  d0e5              BEQ      |L2.80|
000084  2000              MOVS     r0,#0                 ;299
000086  e7c1              B        |L2.12|
;;;301    
                          ENDP

                  |L2.136|
                          DCD      m_conn_params_config
                  |L2.140|
                          DCD      m_preferred_conn_params
                  |L2.144|
                          DCD      m_conn_params_instances
                  |L2.148|
                          DCD      m_timer_data
                  |L2.152|
                          DCD      update_timeout_handler

                          AREA ||i.ble_conn_params_stop||, CODE, READONLY, ALIGN=2

                  ble_conn_params_stop PROC
;;;302    
;;;303    ret_code_t ble_conn_params_stop(void)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
;;;305        ret_code_t err_code;
;;;306    
;;;307        //lint -save -e681 "Loop not entered" when NRF_BLE_CONN_PARAMS_N_INSTANCES is 0
;;;308        for (uint32_t i = 0; i < NRF_BLE_CONN_PARAMS_N_INSTANCES; i++)
000002  2500              MOVS     r5,#0
000004  e019              B        |L3.58|
                  |L3.6|
;;;309            {
;;;310            err_code = app_timer_stop(m_conn_params_instances[i].timer_id);
000006  eb050185          ADD      r1,r5,r5,LSL #2
00000a  4a0e              LDR      r2,|L3.68|
00000c  eb020181          ADD      r1,r2,r1,LSL #2
000010  6848              LDR      r0,[r1,#4]
000012  f7fffffe          BL       app_timer_stop
000016  4604              MOV      r4,r0
;;;311            switch (err_code)
000018  b134              CBZ      r4,|L3.40|
00001a  2c04              CMP      r4,#4
00001c  d006              BEQ      |L3.44|
00001e  2c07              CMP      r4,#7
000020  d007              BEQ      |L3.50|
000022  2c08              CMP      r4,#8
000024  d104              BNE      |L3.48|
000026  e000              B        |L3.42|
                  |L3.40|
;;;312                {
;;;313                case NRF_SUCCESS:
;;;314                    /* do nothing */
;;;315                    break;
000028  e005              B        |L3.54|
                  |L3.42|
;;;316    
;;;317                case NRF_ERROR_INVALID_STATE:
;;;318                    /* do nothing */
;;;319                    break;
00002a  e004              B        |L3.54|
                  |L3.44|
;;;320    
;;;321                case NRF_ERROR_NO_MEM:
;;;322                    return NRF_ERROR_BUSY;
00002c  2011              MOVS     r0,#0x11
                  |L3.46|
;;;323    
;;;324                case NRF_ERROR_INVALID_PARAM:
;;;325                    /* fallthrough */
;;;326                default:
;;;327                    return NRF_ERROR_INTERNAL;
;;;328                }
;;;329            }
;;;330        //lint -restore
;;;331        return NRF_SUCCESS;
;;;332    }
00002e  bd70              POP      {r4-r6,pc}
                  |L3.48|
000030  bf00              NOP                            ;324
                  |L3.50|
000032  2003              MOVS     r0,#3                 ;327
000034  e7fb              B        |L3.46|
                  |L3.54|
000036  bf00              NOP                            ;315
000038  1c6d              ADDS     r5,r5,#1              ;308
                  |L3.58|
00003a  2d00              CMP      r5,#0                 ;308
00003c  d0e3              BEQ      |L3.6|
00003e  2000              MOVS     r0,#0                 ;331
000040  e7f5              B        |L3.46|
;;;333    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      m_conn_params_instances

                          AREA ||i.ble_evt_handler||, CODE, READONLY, ALIGN=1

                  ble_evt_handler PROC
;;;515     */
;;;516    static void ble_evt_handler(ble_evt_t const * p_ble_evt, void * p_context)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;518        switch (p_ble_evt->header.evt_id)
000006  8820              LDRH     r0,[r4,#0]
000008  2810              CMP      r0,#0x10
00000a  d006              BEQ      |L4.26|
00000c  2811              CMP      r0,#0x11
00000e  d008              BEQ      |L4.34|
000010  2812              CMP      r0,#0x12
000012  d00e              BEQ      |L4.50|
000014  2850              CMP      r0,#0x50
000016  d110              BNE      |L4.58|
000018  e007              B        |L4.42|
                  |L4.26|
;;;519        {
;;;520            case BLE_GAP_EVT_CONNECTED:
;;;521                on_connect(p_ble_evt);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       on_connect
;;;522                break;
000020  e00c              B        |L4.60|
                  |L4.34|
;;;523    
;;;524            case BLE_GAP_EVT_DISCONNECTED:
;;;525                on_disconnect(p_ble_evt);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       on_disconnect
;;;526                break;
000028  e008              B        |L4.60|
                  |L4.42|
;;;527    
;;;528            case BLE_GATTS_EVT_WRITE:
;;;529                on_write(p_ble_evt);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       on_write
;;;530                break;
000030  e004              B        |L4.60|
                  |L4.50|
;;;531    
;;;532            case BLE_GAP_EVT_CONN_PARAM_UPDATE:
;;;533                on_conn_params_update(p_ble_evt);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       on_conn_params_update
;;;534                break;
000038  e000              B        |L4.60|
                  |L4.58|
;;;535    
;;;536            default:
;;;537                // No implementation needed.
;;;538                break;
00003a  bf00              NOP      
                  |L4.60|
00003c  bf00              NOP                            ;522
;;;539        }
;;;540    }
00003e  bd70              POP      {r4-r6,pc}
;;;541    
                          ENDP


                          AREA ||i.conn_params_negotiation||, CODE, READONLY, ALIGN=2

                  conn_params_negotiation PROC
;;;339     */
;;;340    static void conn_params_negotiation(uint16_t conn_handle, ble_conn_params_instance_t * p_instance)
000000  b5f8              PUSH     {r3-r7,lr}
;;;341            {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;342        // Start negotiation if the received connection parameters are not acceptable
;;;343        if (!p_instance->params_ok)
000006  7a60              LDRB     r0,[r4,#9]
000008  b988              CBNZ     r0,|L5.46|
;;;344                {
;;;345            ret_code_t err_code;
;;;346            uint32_t   timeout_ticks;
;;;347    
;;;348            if (p_instance->update_count == 0)
00000a  7a20              LDRB     r0,[r4,#8]
00000c  b910              CBNZ     r0,|L5.20|
;;;349            {
;;;350                    // First connection parameter update
;;;351                    timeout_ticks = m_conn_params_config.first_conn_params_update_delay;
00000e  4810              LDR      r0,|L5.80|
000010  6847              LDR      r7,[r0,#4]  ; m_conn_params_config
000012  e001              B        |L5.24|
                  |L5.20|
;;;352                }
;;;353                else
;;;354                {
;;;355                    timeout_ticks = m_conn_params_config.next_conn_params_update_delay;
000014  480e              LDR      r0,|L5.80|
000016  6887              LDR      r7,[r0,#8]  ; m_conn_params_config
                  |L5.24|
;;;356                }
;;;357    
;;;358            err_code = app_timer_start(p_instance->timer_id, timeout_ticks, (void *)(uint32_t)conn_handle);
000018  462a              MOV      r2,r5
00001a  4639              MOV      r1,r7
00001c  6860              LDR      r0,[r4,#4]
00001e  f7fffffe          BL       app_timer_start
000022  4606              MOV      r6,r0
;;;359            if (err_code != NRF_SUCCESS)
000024  b116              CBZ      r6,|L5.44|
;;;360                {
;;;361                send_error_evt(err_code);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       send_error_evt
                  |L5.44|
;;;362                }
;;;363            }
00002c  e00e              B        |L5.76|
                  |L5.46|
;;;364        else
;;;365        {
;;;366            p_instance->update_count = 0;
00002e  2000              MOVS     r0,#0
000030  7220              STRB     r0,[r4,#8]
;;;367    
;;;368            // Notify the application that the procedure has succeeded
;;;369            if (m_conn_params_config.evt_handler != NULL)
000032  4807              LDR      r0,|L5.80|
000034  6940              LDR      r0,[r0,#0x14]  ; m_conn_params_config
000036  b148              CBZ      r0,|L5.76|
;;;370            {
;;;371                ble_conn_params_evt_t evt;
;;;372    
;;;373                evt.evt_type = BLE_CONN_PARAMS_EVT_SUCCEEDED;
000038  2001              MOVS     r0,#1
00003a  f88d0000          STRB     r0,[sp,#0]
;;;374                evt.conn_handle = conn_handle;
00003e  f8ad5002          STRH     r5,[sp,#2]
;;;375                m_conn_params_config.evt_handler(&evt);
000042  4803              LDR      r0,|L5.80|
000044  6941              LDR      r1,[r0,#0x14]  ; m_conn_params_config
000046  4668              MOV      r0,sp
000048  4788              BLX      r1
;;;376            }
00004a  bf00              NOP      
                  |L5.76|
;;;377        }
;;;378    }
00004c  bdf8              POP      {r3-r7,pc}
;;;379    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      m_conn_params_config

                          AREA ||i.instance_get||, CODE, READONLY, ALIGN=2

                  instance_get PROC
;;;83      */
;;;84     static ble_conn_params_instance_t * instance_get(uint16_t conn_handle)
000000  4602              MOV      r2,r0
;;;85     {
;;;86         //lint -save -e681 "Loop not entered" when NRF_BLE_CONN_PARAMS_N_INSTANCES is 0
;;;87         for (uint32_t i = 0; i < NRF_BLE_CONN_PARAMS_N_INSTANCES; i++)
000002  2100              MOVS     r1,#0
000004  e00c              B        |L6.32|
                  |L6.6|
;;;88         {
;;;89             if (m_conn_params_instances[i].conn_handle == conn_handle)
000006  eb010081          ADD      r0,r1,r1,LSL #2
00000a  4b07              LDR      r3,|L6.40|
00000c  f8330020          LDRH     r0,[r3,r0,LSL #2]
000010  4290              CMP      r0,r2
000012  d104              BNE      |L6.30|
;;;90             {
;;;91                 return &m_conn_params_instances[i];
000014  eb010081          ADD      r0,r1,r1,LSL #2
000018  eb030080          ADD      r0,r3,r0,LSL #2
                  |L6.28|
;;;92             }
;;;93         }
;;;94         //lint -restore
;;;95         return NULL;
;;;96     }
00001c  4770              BX       lr
                  |L6.30|
00001e  1c49              ADDS     r1,r1,#1              ;87
                  |L6.32|
000020  2900              CMP      r1,#0                 ;87
000022  d0f0              BEQ      |L6.6|
000024  2000              MOVS     r0,#0                 ;95
000026  e7f9              B        |L6.28|
;;;97     
                          ENDP

                  |L6.40|
                          DCD      m_conn_params_instances

                          AREA ||i.is_conn_params_ok||, CODE, READONLY, ALIGN=1

                  is_conn_params_ok PROC
;;;132     */
;;;133    static bool is_conn_params_ok(ble_gap_conn_params_t const * p_preferred_conn_params,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;134                                  ble_gap_conn_params_t const * p_actual_conn_params,
;;;135                                  uint16_t                      max_slave_latency_err,
;;;136                                  uint16_t                      max_sup_timeout_err)
;;;137    {
000004  4604              MOV      r4,r0
;;;138        uint32_t max_allowed_sl = p_preferred_conn_params->slave_latency + max_slave_latency_err;
000006  88a0              LDRH     r0,[r4,#4]
000008  eb000c02          ADD      r12,r0,r2
;;;139        uint32_t min_allowed_sl = p_preferred_conn_params->slave_latency
00000c  f8b48004          LDRH     r8,[r4,#4]
000010  4590              CMP      r8,r2
000012  dd01              BLE      |L7.24|
;;;140                                  - MIN(max_slave_latency_err, p_preferred_conn_params->slave_latency);
000014  4610              MOV      r0,r2
000016  e000              B        |L7.26|
                  |L7.24|
000018  88a0              LDRH     r0,[r4,#4]
                  |L7.26|
00001a  eba80500          SUB      r5,r8,r0
;;;141        uint32_t max_allowed_to = p_preferred_conn_params->conn_sup_timeout + max_sup_timeout_err;
00001e  88e0              LDRH     r0,[r4,#6]
000020  18c6              ADDS     r6,r0,r3
;;;142        uint32_t min_allowed_to = p_preferred_conn_params->conn_sup_timeout
000022  f8b48006          LDRH     r8,[r4,#6]
000026  4598              CMP      r8,r3
000028  dd01              BLE      |L7.46|
;;;143                                  - MIN(max_sup_timeout_err, p_preferred_conn_params->conn_sup_timeout);
00002a  4618              MOV      r0,r3
00002c  e000              B        |L7.48|
                  |L7.46|
00002e  88e0              LDRH     r0,[r4,#6]
                  |L7.48|
000030  eba80700          SUB      r7,r8,r0
;;;144    
;;;145        // Check if interval is within the acceptable range.
;;;146        // NOTE: Using max_conn_interval in the received event data because this contains
;;;147        //       the client's connection interval.
;;;148        if   ((p_actual_conn_params->max_conn_interval < p_preferred_conn_params->min_conn_interval)
000034  8848              LDRH     r0,[r1,#2]
000036  f8b48000          LDRH     r8,[r4,#0]
00003a  4540              CMP      r0,r8
00003c  db04              BLT      |L7.72|
;;;149           || (p_actual_conn_params->max_conn_interval > p_preferred_conn_params->max_conn_interval))
00003e  8848              LDRH     r0,[r1,#2]
000040  f8b48002          LDRH     r8,[r4,#2]
000044  4540              CMP      r0,r8
000046  dd02              BLE      |L7.78|
                  |L7.72|
;;;150        {
;;;151            return false;
000048  2000              MOVS     r0,#0
                  |L7.74|
;;;152        }
;;;153    
;;;154        // Check if slave latency is within the acceptable deviation.
;;;155        if   ((p_actual_conn_params->slave_latency < min_allowed_sl)
;;;156           || (p_actual_conn_params->slave_latency > max_allowed_sl))
;;;157        {
;;;158            return false;
;;;159        }
;;;160    
;;;161        // Check if supervision timeout is within the acceptable deviation.
;;;162        if   ((p_actual_conn_params->conn_sup_timeout < min_allowed_to)
;;;163           || (p_actual_conn_params->conn_sup_timeout > max_allowed_to))
;;;164        {
;;;165            return false;
;;;166        }
;;;167    
;;;168        return true;
;;;169    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L7.78|
00004e  8888              LDRH     r0,[r1,#4]            ;155
000050  42a8              CMP      r0,r5                 ;155
000052  d302              BCC      |L7.90|
000054  8888              LDRH     r0,[r1,#4]            ;156
000056  4560              CMP      r0,r12                ;156
000058  d901              BLS      |L7.94|
                  |L7.90|
00005a  2000              MOVS     r0,#0                 ;158
00005c  e7f5              B        |L7.74|
                  |L7.94|
00005e  88c8              LDRH     r0,[r1,#6]            ;162
000060  42b8              CMP      r0,r7                 ;162
000062  d302              BCC      |L7.106|
000064  88c8              LDRH     r0,[r1,#6]            ;163
000066  42b0              CMP      r0,r6                 ;163
000068  d901              BLS      |L7.110|
                  |L7.106|
00006a  2000              MOVS     r0,#0                 ;165
00006c  e7ed              B        |L7.74|
                  |L7.110|
00006e  2001              MOVS     r0,#1                 ;168
000070  e7eb              B        |L7.74|
;;;170    
                          ENDP


                          AREA ||i.on_conn_params_update||, CODE, READONLY, ALIGN=1

                  on_conn_params_update PROC
;;;491     */
;;;492    static void on_conn_params_update(ble_evt_t const * p_ble_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;493    {
000002  4605              MOV      r5,r0
;;;494        uint16_t                     conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
000004  88ae              LDRH     r6,[r5,#4]
;;;495        ble_conn_params_instance_t * p_instance  = instance_get(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       instance_get
00000c  4604              MOV      r4,r0
;;;496    
;;;497        if (p_instance != NULL)
00000e  b174              CBZ      r4,|L8.46|
;;;498        {
;;;499            p_instance->params_ok = is_conn_params_ok(
000010  f64f73ff          MOV      r3,#0xffff
000014  f24012f3          MOV      r2,#0x1f3
000018  f1050108          ADD      r1,r5,#8
00001c  f104000a          ADD      r0,r4,#0xa
000020  f7fffffe          BL       is_conn_params_ok
000024  7260              STRB     r0,[r4,#9]
;;;500                                         &p_instance->preferred_conn_params,
;;;501                                         &p_ble_evt->evt.gap_evt.params.conn_param_update.conn_params,
;;;502                                         NRF_BLE_CONN_PARAMS_MAX_SLAVE_LATENCY_DEVIATION,
;;;503                                         NRF_BLE_CONN_PARAMS_MAX_SUPERVISION_TIMEOUT_DEVIATION);
;;;504    
;;;505            conn_params_negotiation(conn_handle, p_instance);
000026  4621              MOV      r1,r4
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       conn_params_negotiation
                  |L8.46|
;;;506        }
;;;507    }
00002e  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP


                          AREA ||i.on_connect||, CODE, READONLY, ALIGN=2

                  on_connect PROC
;;;384     */
;;;385    static void on_connect(ble_evt_t const * p_ble_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;386    {
000004  4605              MOV      r5,r0
;;;387        uint8_t  role        = p_ble_evt->evt.gap_evt.params.connected.role;
000006  7bef              LDRB     r7,[r5,#0xf]
;;;388        uint16_t conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
000008  88ae              LDRH     r6,[r5,#4]
;;;389    
;;;390        if (role != BLE_GAP_ROLE_PERIPH)
00000a  2f01              CMP      r7,#1
00000c  d001              BEQ      |L9.18|
                  |L9.14|
;;;391        {
;;;392            return;
;;;393        }
;;;394    
;;;395        ble_conn_params_instance_t * p_instance  = instance_get(BLE_CONN_HANDLE_INVALID);
;;;396    
;;;397        if (p_instance == NULL)
;;;398        {
;;;399            send_error_evt(NRF_ERROR_NO_MEM);
;;;400            return;
;;;401        }
;;;402    
;;;403        instance_claim(p_instance, conn_handle);
;;;404        p_instance->params_ok = is_conn_params_ok(&p_instance->preferred_conn_params,
;;;405                                                  &p_ble_evt->evt.gap_evt.params.connected.conn_params,
;;;406                                                  NRF_BLE_CONN_PARAMS_MAX_SLAVE_LATENCY_DEVIATION,
;;;407                                                  NRF_BLE_CONN_PARAMS_MAX_SUPERVISION_TIMEOUT_DEVIATION);
;;;408    
;;;409        // Check if we shall handle negotiation on connect
;;;410        if (m_conn_params_config.start_on_notify_cccd_handle == BLE_GATT_HANDLE_INVALID)
;;;411        {
;;;412            conn_params_negotiation(conn_handle, p_instance);
;;;413        }
;;;414    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L9.18|
000012  f64f70ff          MOV      r0,#0xffff            ;395
000016  f7fffffe          BL       instance_get
00001a  4604              MOV      r4,r0                 ;395
00001c  b91c              CBNZ     r4,|L9.38|
00001e  2004              MOVS     r0,#4                 ;399
000020  f7fffffe          BL       send_error_evt
000024  e7f3              B        |L9.14|
                  |L9.38|
000026  bf00              NOP                            ;403
000028  8026              STRH     r6,[r4,#0]            ;403
00002a  2000              MOVS     r0,#0                 ;403
00002c  7220              STRB     r0,[r4,#8]            ;403
00002e  480e              LDR      r0,|L9.104|
000030  6801              LDR      r1,[r0,#0]            ;403  ; m_preferred_conn_params
000032  f8c4100a          STR      r1,[r4,#0xa]          ;403
000036  6840              LDR      r0,[r0,#4]            ;403  ; m_preferred_conn_params
000038  f8c4000e          STR      r0,[r4,#0xe]          ;403
00003c  bf00              NOP                            ;403
00003e  f64f73ff          MOV      r3,#0xffff            ;404
000042  f24012f3          MOV      r2,#0x1f3             ;404
000046  f1050110          ADD      r1,r5,#0x10           ;404
00004a  f104000a          ADD      r0,r4,#0xa            ;404
00004e  f7fffffe          BL       is_conn_params_ok
000052  7260              STRB     r0,[r4,#9]            ;404
000054  4805              LDR      r0,|L9.108|
000056  89c0              LDRH     r0,[r0,#0xe]          ;410  ; m_conn_params_config
000058  b918              CBNZ     r0,|L9.98|
00005a  4621              MOV      r1,r4                 ;412
00005c  4630              MOV      r0,r6                 ;412
00005e  f7fffffe          BL       conn_params_negotiation
                  |L9.98|
000062  bf00              NOP      
000064  e7d3              B        |L9.14|
;;;415    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      m_preferred_conn_params
                  |L9.108|
                          DCD      m_conn_params_config

                          AREA ||i.on_disconnect||, CODE, READONLY, ALIGN=1

                  on_disconnect PROC
;;;420     */
;;;421    static void on_disconnect(ble_evt_t const * p_ble_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;422    {
000004  4606              MOV      r6,r0
;;;423        ret_code_t                   err_code;
;;;424        uint16_t                     conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
000006  88b7              LDRH     r7,[r6,#4]
;;;425        ble_conn_params_instance_t * p_instance  = instance_get(conn_handle);
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       instance_get
00000e  4605              MOV      r5,r0
;;;426    
;;;427        if (p_instance != NULL)
000010  b16d              CBZ      r5,|L10.46|
;;;428        {
;;;429        // Stop timer if running
;;;430            err_code = app_timer_stop(p_instance->timer_id);
000012  6868              LDR      r0,[r5,#4]
000014  f7fffffe          BL       app_timer_stop
000018  4604              MOV      r4,r0
;;;431            if (err_code != NRF_SUCCESS)
00001a  b114              CBZ      r4,|L10.34|
;;;432            {
;;;433                send_error_evt(err_code);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       send_error_evt
                  |L10.34|
;;;434            }
;;;435    
;;;436            instance_free(p_instance);
000022  bf00              NOP      
000024  f64f70ff          MOV      r0,#0xffff
000028  8028              STRH     r0,[r5,#0]
00002a  bf00              NOP      
00002c  bf00              NOP      
                  |L10.46|
;;;437        }
;;;438    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;439    
                          ENDP


                          AREA ||i.on_write||, CODE, READONLY, ALIGN=2

                  on_write PROC
;;;446     */
;;;447    static void on_write(ble_evt_t const * p_ble_evt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;448    {
000004  4604              MOV      r4,r0
;;;449        ble_gatts_evt_write_t const * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
000006  1da5              ADDS     r5,r4,#6
;;;450    
;;;451        // Check if this is the correct CCCD
;;;452        if (
000008  8828              LDRH     r0,[r5,#0]
00000a  4912              LDR      r1,|L11.84|
00000c  89c9              LDRH     r1,[r1,#0xe]  ; m_conn_params_config
00000e  4288              CMP      r0,r1
000010  d11d              BNE      |L11.78|
;;;453            (p_evt_write->handle == m_conn_params_config.start_on_notify_cccd_handle)
;;;454            &&
;;;455            (p_evt_write->len == 2)
000012  8968              LDRH     r0,[r5,#0xa]
000014  2802              CMP      r0,#2
000016  d11a              BNE      |L11.78|
;;;456           )
;;;457        {
;;;458            uint16_t                     conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
000018  f8b48004          LDRH     r8,[r4,#4]
;;;459            ble_conn_params_instance_t * p_instance  = instance_get(conn_handle);
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       instance_get
000022  4606              MOV      r6,r0
;;;460    
;;;461            if (p_instance != NULL)
000024  b196              CBZ      r6,|L11.76|
;;;462            {
;;;463                // Check if this is a 'start notification'
;;;464                if (ble_srv_is_notification_enabled(p_evt_write->data))
000026  f105000c          ADD      r0,r5,#0xc
00002a  f7fffffe          BL       ble_srv_is_notification_enabled
00002e  b120              CBZ      r0,|L11.58|
;;;465                {
;;;466                    // Do connection parameter negotiation if necessary
;;;467                        conn_params_negotiation(conn_handle, p_instance);
000030  4631              MOV      r1,r6
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       conn_params_negotiation
000038  e008              B        |L11.76|
                  |L11.58|
;;;468                }
;;;469                else
;;;470                {
;;;471                    ret_code_t err_code;
;;;472    
;;;473                    // Stop timer if running
;;;474                    err_code = app_timer_stop(p_instance->timer_id);
00003a  6870              LDR      r0,[r6,#4]
00003c  f7fffffe          BL       app_timer_stop
000040  4607              MOV      r7,r0
;;;475                    if (err_code != NRF_SUCCESS)
000042  b117              CBZ      r7,|L11.74|
;;;476                    {
;;;477                        send_error_evt(err_code);
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       send_error_evt
                  |L11.74|
;;;478                    }
;;;479                }
00004a  bf00              NOP      
                  |L11.76|
;;;480            }
;;;481        }
00004c  bf00              NOP      
                  |L11.78|
;;;482    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;483    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
                          DCD      m_conn_params_config

                          AREA ||i.send_error_evt||, CODE, READONLY, ALIGN=2

                  send_error_evt PROC
;;;171    
;;;172    static void send_error_evt(ret_code_t err_code)
000000  b510              PUSH     {r4,lr}
;;;173    {
000002  4604              MOV      r4,r0
;;;174        if (m_conn_params_config.error_handler != NULL)
000004  4803              LDR      r0,|L12.20|
000006  6980              LDR      r0,[r0,#0x18]  ; m_conn_params_config
000008  b118              CBZ      r0,|L12.18|
;;;175        {
;;;176            m_conn_params_config.error_handler(err_code);
00000a  4802              LDR      r0,|L12.20|
00000c  6981              LDR      r1,[r0,#0x18]  ; m_conn_params_config
00000e  4620              MOV      r0,r4
000010  4788              BLX      r1
                  |L12.18|
;;;177        }
;;;178    }
000012  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  |L12.20|
                          DCD      m_conn_params_config

                          AREA ||i.send_update_request||, CODE, READONLY, ALIGN=1

                  send_update_request PROC
;;;187     */
;;;188    static bool send_update_request(uint16_t conn_handle, ble_gap_conn_params_t * p_new_conn_params)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;190        ret_code_t err_code;
;;;191    
;;;192        err_code = sd_ble_gap_conn_param_update(conn_handle, p_new_conn_params);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  df75              SVC      #0x75
00000c  4604              MOV      r4,r0
;;;193        if ((err_code != NRF_SUCCESS) && (err_code != NRF_ERROR_BUSY)) // NRF_ERROR_BUSY means another conn_param_update request is pending.
00000e  b124              CBZ      r4,|L13.26|
000010  2c11              CMP      r4,#0x11
000012  d002              BEQ      |L13.26|
;;;194        {
;;;195            send_error_evt(err_code);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       send_error_evt
                  |L13.26|
;;;196        }
;;;197    
;;;198        return (err_code == NRF_SUCCESS);
00001a  b90c              CBNZ     r4,|L13.32|
00001c  2001              MOVS     r0,#1
                  |L13.30|
;;;199    }
00001e  bd70              POP      {r4-r6,pc}
                  |L13.32|
000020  2000              MOVS     r0,#0                 ;198
000022  e7fc              B        |L13.30|
;;;200    
                          ENDP


                          AREA ||i.update_timeout_handler||, CODE, READONLY, ALIGN=2

                  update_timeout_handler PROC
;;;205     */
;;;206    static void update_timeout_handler(void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;207    {
000002  4606              MOV      r6,r0
;;;208        uint32_t                     conn_handle = (uint32_t)p_context;
000004  4635              MOV      r5,r6
;;;209        ble_conn_params_instance_t * p_instance  = instance_get(conn_handle);
000006  b2a8              UXTH     r0,r5
000008  f7fffffe          BL       instance_get
00000c  4604              MOV      r4,r0
;;;210    
;;;211        if (p_instance != NULL)
00000e  b36c              CBZ      r4,|L14.108|
;;;212        {
;;;213            // Check if we have reached the maximum number of attempts
;;;214            if (p_instance->update_count < m_conn_params_config.max_conn_params_update_count)
000010  7a20              LDRB     r0,[r4,#8]
000012  4917              LDR      r1,|L14.112|
000014  7b09              LDRB     r1,[r1,#0xc]  ; m_conn_params_config
000016  4288              CMP      r0,r1
000018  da0a              BGE      |L14.48|
;;;215            {
;;;216                bool update_sent = send_update_request(conn_handle, &p_instance->preferred_conn_params);
00001a  b2a8              UXTH     r0,r5
00001c  f104010a          ADD      r1,r4,#0xa
000020  f7fffffe          BL       send_update_request
000024  4607              MOV      r7,r0
;;;217                if (update_sent)
000026  b117              CBZ      r7,|L14.46|
;;;218                {
;;;219                    p_instance->update_count++;
000028  7a20              LDRB     r0,[r4,#8]
00002a  1c40              ADDS     r0,r0,#1
00002c  7220              STRB     r0,[r4,#8]
                  |L14.46|
;;;220                }
;;;221            }
00002e  e01d              B        |L14.108|
                  |L14.48|
;;;222            else
;;;223            {
;;;224                p_instance->update_count = 0;
000030  2000              MOVS     r0,#0
000032  7220              STRB     r0,[r4,#8]
;;;225    
;;;226                // Negotiation failed, disconnect automatically if this has been configured
;;;227                if (m_conn_params_config.disconnect_on_fail)
000034  480e              LDR      r0,|L14.112|
000036  7c00              LDRB     r0,[r0,#0x10]  ; m_conn_params_config
000038  b150              CBZ      r0,|L14.80|
;;;228                {
;;;229                    ret_code_t err_code;
;;;230    
;;;231                    err_code = sd_ble_gap_disconnect(conn_handle, BLE_HCI_CONN_INTERVAL_UNACCEPTABLE);
00003a  b2a8              UXTH     r0,r5
00003c  213b              MOVS     r1,#0x3b
00003e  df76              SVC      #0x76
000040  4607              MOV      r7,r0
;;;232                    if ((err_code != NRF_SUCCESS) && (err_code != NRF_ERROR_INVALID_STATE)) // NRF_ERROR_INVALID_STATE means disconnect is already in progress.
000042  b127              CBZ      r7,|L14.78|
000044  2f08              CMP      r7,#8
000046  d002              BEQ      |L14.78|
;;;233                    {
;;;234                        send_error_evt(err_code);
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       send_error_evt
                  |L14.78|
;;;235                    }
;;;236                }
00004e  bf00              NOP      
                  |L14.80|
;;;237    
;;;238                // Notify the application that the procedure has failed
;;;239                if (m_conn_params_config.evt_handler != NULL)
000050  4807              LDR      r0,|L14.112|
000052  6940              LDR      r0,[r0,#0x14]  ; m_conn_params_config
000054  b150              CBZ      r0,|L14.108|
;;;240                {
;;;241                    ble_conn_params_evt_t evt;
;;;242    
;;;243                    evt.evt_type = BLE_CONN_PARAMS_EVT_FAILED;
000056  2000              MOVS     r0,#0
000058  f88d0000          STRB     r0,[sp,#0]
;;;244                    evt.conn_handle = conn_handle;
00005c  b2a8              UXTH     r0,r5
00005e  f8ad0002          STRH     r0,[sp,#2]
;;;245                    m_conn_params_config.evt_handler(&evt);
000062  4803              LDR      r0,|L14.112|
000064  6941              LDR      r1,[r0,#0x14]  ; m_conn_params_config
000066  4668              MOV      r0,sp
000068  4788              BLX      r1
;;;246                }
00006a  bf00              NOP      
                  |L14.108|
;;;247            }
;;;248        }
;;;249    }
00006c  bdf8              POP      {r3-r7,pc}
;;;250    
                          ENDP

00006e  0000              DCW      0x0000
                  |L14.112|
                          DCD      m_conn_params_config

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_timer_data
                          %        32
                  m_conn_params_instances
                          %        20
                  m_conn_params_config
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  m_preferred_conn_params
                          %        8

                          AREA sdh_ble_observers2, DATA, READONLY, ALIGN=2

                  m_ble_observer
                  ||__tagsym$$used||
                          DCD      ble_evt_handler
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\common\\ble_conn_params.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_ble_conn_params_c_2dcac06e____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_ble_conn_params_c_2dcac06e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_ble_conn_params_c_2dcac06e____REVSH|
#line 402
|__asm___17_ble_conn_params_c_2dcac06e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_ble_conn_params_c_2dcac06e____RRX|
#line 587
|__asm___17_ble_conn_params_c_2dcac06e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
