; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\pm_mutex.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\pm_mutex.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\pm_mutex.crf ..\..\..\..\..\..\components\ble\peer_manager\pm_mutex.c]
                          THUMB

                          AREA ||i.lock_by_mask||, CODE, READONLY, ALIGN=1

                  lock_by_mask PROC
;;;58      */
;;;59     static bool lock_by_mask(uint8_t * p_mutex, uint8_t mutex_mask)
000000  b5f8              PUSH     {r3-r7,lr}
;;;60     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;61         bool success = false;
000006  2600              MOVS     r6,#0
;;;62     
;;;63         if ( (*p_mutex & mutex_mask) == 0 )
000008  7820              LDRB     r0,[r4,#0]
00000a  4028              ANDS     r0,r0,r5
00000c  b980              CBNZ     r0,|L1.48|
;;;64         {
;;;65             CRITICAL_REGION_ENTER();
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       app_util_critical_region_enter
;;;66             if ( (*p_mutex & mutex_mask) == 0 )
000018  7820              LDRB     r0,[r4,#0]
00001a  4028              ANDS     r0,r0,r5
00001c  b918              CBNZ     r0,|L1.38|
;;;67             {
;;;68                 *p_mutex |= mutex_mask;
00001e  7820              LDRB     r0,[r4,#0]
000020  4328              ORRS     r0,r0,r5
000022  7020              STRB     r0,[r4,#0]
;;;69     
;;;70                 success = true;
000024  2601              MOVS     r6,#1
                  |L1.38|
;;;71             }
;;;72             CRITICAL_REGION_EXIT();
000026  f89d0000          LDRB     r0,[sp,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
00002e  bf00              NOP      
                  |L1.48|
;;;73         }
;;;74     
;;;75         return ( success );
000030  4630              MOV      r0,r6
;;;76     }
000032  bdf8              POP      {r3-r7,pc}
;;;77     
                          ENDP


                          AREA ||i.pm_mutex_init||, CODE, READONLY, ALIGN=1

                  pm_mutex_init PROC
;;;78     
;;;79     void pm_mutex_init(uint8_t * p_mutex, uint16_t mutex_size)
000000  b570              PUSH     {r4-r6,lr}
;;;80     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;81         if (p_mutex != NULL)
000006  b124              CBZ      r4,|L2.18|
;;;82         {
;;;83             memset(&p_mutex[0], 0, MUTEX_STORAGE_SIZE(mutex_size));
000008  1de8              ADDS     r0,r5,#7
00000a  10c1              ASRS     r1,r0,#3
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       __aeabi_memclr
                  |L2.18|
;;;84         }
;;;85     }
000012  bd70              POP      {r4-r6,pc}
;;;86     
                          ENDP


                          AREA ||i.pm_mutex_lock||, CODE, READONLY, ALIGN=1

                  pm_mutex_lock PROC
;;;87     
;;;88     bool pm_mutex_lock(uint8_t * p_mutex, uint16_t mutex_id)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;90         if (p_mutex != NULL)
000006  b14c              CBZ      r4,|L3.28|
;;;91         {
;;;92             return ( lock_by_mask(&(p_mutex[mutex_id >> 3]), (1 << (mutex_id & 0x07))) );
000008  f0050307          AND      r3,r5,#7
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  b2d1              UXTB     r1,r2
000012  eb0400e5          ADD      r0,r4,r5,ASR #3
000016  f7fffffe          BL       lock_by_mask
                  |L3.26|
;;;93         }
;;;94         else
;;;95         {
;;;96             return false;
;;;97         }
;;;98     }
00001a  bd70              POP      {r4-r6,pc}
                  |L3.28|
00001c  2000              MOVS     r0,#0                 ;96
00001e  e7fc              B        |L3.26|
;;;99     
                          ENDP


                          AREA ||i.pm_mutex_lock_first_available||, CODE, READONLY, ALIGN=1

                  pm_mutex_lock_first_available PROC
;;;115    
;;;116    uint16_t pm_mutex_lock_first_available(uint8_t * p_mutex, uint16_t mutex_size)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;118        if (p_mutex != NULL)
000006  b18d              CBZ      r5,|L4.44|
;;;119        {
;;;120            for ( uint16_t i = 0; i < mutex_size; i++ )
000008  2400              MOVS     r4,#0
00000a  e00d              B        |L4.40|
                  |L4.12|
;;;121            {
;;;122                if ( lock_by_mask(&(p_mutex[i >> 3]), 1 << (i & 0x07)) )
00000c  f0040307          AND      r3,r4,#7
000010  2201              MOVS     r2,#1
000012  409a              LSLS     r2,r2,r3
000014  b2d1              UXTB     r1,r2
000016  eb0500e4          ADD      r0,r5,r4,ASR #3
00001a  f7fffffe          BL       lock_by_mask
00001e  b108              CBZ      r0,|L4.36|
;;;123                {
;;;124                    return ( i );
000020  4620              MOV      r0,r4
                  |L4.34|
;;;125                }
;;;126            }
;;;127        }
;;;128    
;;;129        return ( mutex_size );
;;;130    }
000022  bd70              POP      {r4-r6,pc}
                  |L4.36|
000024  1c60              ADDS     r0,r4,#1              ;120
000026  b284              UXTH     r4,r0                 ;120
                  |L4.40|
000028  42b4              CMP      r4,r6                 ;120
00002a  dbef              BLT      |L4.12|
                  |L4.44|
00002c  4630              MOV      r0,r6                 ;129
00002e  e7f8              B        |L4.34|
;;;131    
                          ENDP


                          AREA ||i.pm_mutex_lock_status_get||, CODE, READONLY, ALIGN=1

                  pm_mutex_lock_status_get PROC
;;;132    
;;;133    bool pm_mutex_lock_status_get(uint8_t * p_mutex, uint16_t mutex_id)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4602              MOV      r2,r0
;;;135        if (p_mutex != NULL)
000004  b162              CBZ      r2,|L5.32|
;;;136        {
;;;137            return ( (p_mutex[mutex_id >> 3] & (1 << (mutex_id & 0x07))) );
000006  eb0200e1          ADD      r0,r2,r1,ASR #3
00000a  7800              LDRB     r0,[r0,#0]
00000c  f0010407          AND      r4,r1,#7
000010  2301              MOVS     r3,#1
000012  40a3              LSLS     r3,r3,r4
000014  4018              ANDS     r0,r0,r3
000016  b108              CBZ      r0,|L5.28|
000018  2001              MOVS     r0,#1
                  |L5.26|
;;;138        }
;;;139        else
;;;140        {
;;;141            return true;
;;;142        }
;;;143    }
00001a  bd10              POP      {r4,pc}
                  |L5.28|
00001c  2000              MOVS     r0,#0                 ;137
00001e  e7fc              B        |L5.26|
                  |L5.32|
000020  2001              MOVS     r0,#1                 ;141
000022  e7fa              B        |L5.26|
;;;144    #endif // NRF_MODULE_ENABLED(PEER_MANAGER)
                          ENDP


                          AREA ||i.pm_mutex_unlock||, CODE, READONLY, ALIGN=1

                  pm_mutex_unlock PROC
;;;100    
;;;101    void pm_mutex_unlock(uint8_t * p_mutex, uint16_t mutex_id)
000000  b5f8              PUSH     {r3-r7,lr}
;;;102    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;103        uint8_t mutex_base = mutex_id >> 3;
000006  f3c506c7          UBFX     r6,r5,#3,#8
;;;104        uint8_t mutex_mask = (1 << (mutex_id & 0x07));
00000a  f0050107          AND      r1,r5,#7
00000e  2001              MOVS     r0,#1
000010  4088              LSLS     r0,r0,r1
000012  b2c7              UXTB     r7,r0
;;;105    
;;;106        if   ((p_mutex != NULL)
000014  b17c              CBZ      r4,|L6.54|
;;;107           && (p_mutex[mutex_base] & mutex_mask))
000016  5da0              LDRB     r0,[r4,r6]
000018  4038              ANDS     r0,r0,r7
00001a  b160              CBZ      r0,|L6.54|
;;;108        {
;;;109            CRITICAL_REGION_ENTER();
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;110            p_mutex[mutex_base] &= ~mutex_mask;
000026  5da0              LDRB     r0,[r4,r6]
000028  43b8              BICS     r0,r0,r7
00002a  55a0              STRB     r0,[r4,r6]
;;;111            CRITICAL_REGION_EXIT();
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  f7fffffe          BL       app_util_critical_region_exit
000034  bf00              NOP      
                  |L6.54|
;;;112        }
;;;113    }
000036  bdf8              POP      {r3-r7,pc}
;;;114    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\pm_mutex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_pm_mutex_c_3d8067ae____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_pm_mutex_c_3d8067ae____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_pm_mutex_c_3d8067ae____REVSH|
#line 402
|__asm___10_pm_mutex_c_3d8067ae____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_pm_mutex_c_3d8067ae____RRX|
#line 587
|__asm___10_pm_mutex_c_3d8067ae____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
