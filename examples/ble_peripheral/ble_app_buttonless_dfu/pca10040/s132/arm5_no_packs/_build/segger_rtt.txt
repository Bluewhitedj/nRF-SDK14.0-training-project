; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\segger_rtt.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\segger_rtt.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\segger_rtt.crf ..\..\..\..\..\..\external\segger_rtt\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1014   */
;;;1015   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1016     int BufferIndex;
;;;1017   
;;;1018     INIT();
00000c  bf00              NOP      
00000e  4829              LDR      r0,|L1.180|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;1019     SEGGER_RTT_LOCK();
00001a  2000              MOVS     r0,#0
00001c  9000              STR      r0,[sp,#0]
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       app_util_critical_region_enter
;;;1020     BufferIndex = 0;
000024  2400              MOVS     r4,#0
;;;1021     do {
000026  bf00              NOP      
                  |L1.40|
;;;1022       if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
000028  eb040144          ADD      r1,r4,r4,LSL #1
00002c  4821              LDR      r0,|L1.180|
00002e  3048              ADDS     r0,r0,#0x48
000030  eb0000c1          ADD      r0,r0,r1,LSL #3
000034  6840              LDR      r0,[r0,#4]
000036  b900              CBNZ     r0,|L1.58|
;;;1023         break;
000038  e004              B        |L1.68|
                  |L1.58|
;;;1024       }
;;;1025       BufferIndex++;
00003a  1c64              ADDS     r4,r4,#1
;;;1026     } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
00003c  481d              LDR      r0,|L1.180|
00003e  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000040  42a0              CMP      r0,r4
000042  dcf1              BGT      |L1.40|
                  |L1.68|
000044  bf00              NOP                            ;1023
;;;1027     if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
000046  481b              LDR      r0,|L1.180|
000048  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00004a  42a0              CMP      r0,r4
00004c  dd29              BLE      |L1.162|
;;;1028       _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
00004e  eb040144          ADD      r1,r4,r4,LSL #1
000052  4818              LDR      r0,|L1.180|
000054  3048              ADDS     r0,r0,#0x48
000056  f8405031          STR      r5,[r0,r1,LSL #3]
;;;1029       _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
00005a  eb040144          ADD      r1,r4,r4,LSL #1
00005e  eb0000c1          ADD      r0,r0,r1,LSL #3
000062  6046              STR      r6,[r0,#4]
;;;1030       _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000064  eb040144          ADD      r1,r4,r4,LSL #1
000068  4812              LDR      r0,|L1.180|
00006a  3048              ADDS     r0,r0,#0x48
00006c  eb0000c1          ADD      r0,r0,r1,LSL #3
000070  6087              STR      r7,[r0,#8]
;;;1031       _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000072  2100              MOVS     r1,#0
000074  eb040244          ADD      r2,r4,r4,LSL #1
000078  480e              LDR      r0,|L1.180|
00007a  3048              ADDS     r0,r0,#0x48
00007c  eb0000c2          ADD      r0,r0,r2,LSL #3
000080  6101              STR      r1,[r0,#0x10]
;;;1032       _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000082  eb040244          ADD      r2,r4,r4,LSL #1
000086  480b              LDR      r0,|L1.180|
000088  3048              ADDS     r0,r0,#0x48
00008a  eb0000c2          ADD      r0,r0,r2,LSL #3
00008e  60c1              STR      r1,[r0,#0xc]
;;;1033       _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
000090  eb040144          ADD      r1,r4,r4,LSL #1
000094  4807              LDR      r0,|L1.180|
000096  3048              ADDS     r0,r0,#0x48
000098  eb0000c1          ADD      r0,r0,r1,LSL #3
00009c  f8c08014          STR      r8,[r0,#0x14]
0000a0  e001              B        |L1.166|
                  |L1.162|
;;;1034     } else {
;;;1035       BufferIndex = -1;
0000a2  f04f34ff          MOV      r4,#0xffffffff
                  |L1.166|
;;;1036     }
;;;1037     SEGGER_RTT_UNLOCK();
0000a6  f89d0000          LDRB     r0,[sp,#0]
0000aa  f7fffffe          BL       app_util_critical_region_exit
;;;1038     return BufferIndex;
0000ae  4620              MOV      r0,r4
;;;1039   }
0000b0  e8bd83f8          POP      {r3-r9,pc}
;;;1040   
                          ENDP

                  |L1.180|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1059   */
;;;1060   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1061     int BufferIndex;
;;;1062   
;;;1063     INIT();
00000c  bf00              NOP      
00000e  4829              LDR      r0,|L2.180|
000010  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000012  b908              CBNZ     r0,|L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;1064     SEGGER_RTT_LOCK();
00001a  2000              MOVS     r0,#0
00001c  9000              STR      r0,[sp,#0]
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       app_util_critical_region_enter
;;;1065     BufferIndex = 0;
000024  2400              MOVS     r4,#0
;;;1066     do {
000026  bf00              NOP      
                  |L2.40|
;;;1067       if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
000028  eb040144          ADD      r1,r4,r4,LSL #1
00002c  4821              LDR      r0,|L2.180|
00002e  3018              ADDS     r0,r0,#0x18
000030  eb0000c1          ADD      r0,r0,r1,LSL #3
000034  6840              LDR      r0,[r0,#4]
000036  b900              CBNZ     r0,|L2.58|
;;;1068         break;
000038  e004              B        |L2.68|
                  |L2.58|
;;;1069       }
;;;1070       BufferIndex++;
00003a  1c64              ADDS     r4,r4,#1
;;;1071     } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
00003c  481d              LDR      r0,|L2.180|
00003e  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000040  42a0              CMP      r0,r4
000042  dcf1              BGT      |L2.40|
                  |L2.68|
000044  bf00              NOP                            ;1068
;;;1072     if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
000046  481b              LDR      r0,|L2.180|
000048  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00004a  42a0              CMP      r0,r4
00004c  dd29              BLE      |L2.162|
;;;1073       _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
00004e  eb040144          ADD      r1,r4,r4,LSL #1
000052  4818              LDR      r0,|L2.180|
000054  3018              ADDS     r0,r0,#0x18
000056  f8405031          STR      r5,[r0,r1,LSL #3]
;;;1074       _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
00005a  eb040144          ADD      r1,r4,r4,LSL #1
00005e  eb0000c1          ADD      r0,r0,r1,LSL #3
000062  6046              STR      r6,[r0,#4]
;;;1075       _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000064  eb040144          ADD      r1,r4,r4,LSL #1
000068  4812              LDR      r0,|L2.180|
00006a  3018              ADDS     r0,r0,#0x18
00006c  eb0000c1          ADD      r0,r0,r1,LSL #3
000070  6087              STR      r7,[r0,#8]
;;;1076       _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000072  2100              MOVS     r1,#0
000074  eb040244          ADD      r2,r4,r4,LSL #1
000078  480e              LDR      r0,|L2.180|
00007a  3018              ADDS     r0,r0,#0x18
00007c  eb0000c2          ADD      r0,r0,r2,LSL #3
000080  6101              STR      r1,[r0,#0x10]
;;;1077       _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000082  eb040244          ADD      r2,r4,r4,LSL #1
000086  480b              LDR      r0,|L2.180|
000088  3018              ADDS     r0,r0,#0x18
00008a  eb0000c2          ADD      r0,r0,r2,LSL #3
00008e  60c1              STR      r1,[r0,#0xc]
;;;1078       _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
000090  eb040144          ADD      r1,r4,r4,LSL #1
000094  4807              LDR      r0,|L2.180|
000096  3018              ADDS     r0,r0,#0x18
000098  eb0000c1          ADD      r0,r0,r1,LSL #3
00009c  f8c08014          STR      r8,[r0,#0x14]
0000a0  e001              B        |L2.166|
                  |L2.162|
;;;1079     } else {
;;;1080       BufferIndex = -1;
0000a2  f04f34ff          MOV      r4,#0xffffffff
                  |L2.166|
;;;1081     }
;;;1082     SEGGER_RTT_UNLOCK();
0000a6  f89d0000          LDRB     r0,[sp,#0]
0000aa  f7fffffe          BL       app_util_critical_region_exit
;;;1083     return BufferIndex;
0000ae  4620              MOV      r0,r4
;;;1084   }
0000b0  e8bd83f8          POP      {r3-r9,pc}
;;;1085   
                          ENDP

                  |L2.180|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1157   */
;;;1158   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1159     int r;
;;;1160   
;;;1161     INIT();
000010  bf00              NOP      
000012  4822              LDR      r0,|L3.156|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L3.28|
000018  f7fffffe          BL       _DoInit
                  |L3.28|
00001c  bf00              NOP      
;;;1162     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001e  481f              LDR      r0,|L3.156|
000020  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d935              BLS      |L3.146|
;;;1163       SEGGER_RTT_LOCK();
000026  2000              MOVS     r0,#0
000028  9000              STR      r0,[sp,#0]
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       app_util_critical_region_enter
;;;1164       if (BufferIndex > 0u) {
000030  b30c              CBZ      r4,|L3.118|
;;;1165         _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000032  eb040144          ADD      r1,r4,r4,LSL #1
000036  4819              LDR      r0,|L3.156|
000038  3048              ADDS     r0,r0,#0x48
00003a  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1166         _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
00003e  eb040144          ADD      r1,r4,r4,LSL #1
000042  eb0000c1          ADD      r0,r0,r1,LSL #3
000046  6047              STR      r7,[r0,#4]
;;;1167         _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000048  eb040144          ADD      r1,r4,r4,LSL #1
00004c  4813              LDR      r0,|L3.156|
00004e  3048              ADDS     r0,r0,#0x48
000050  eb0000c1          ADD      r0,r0,r1,LSL #3
000054  f8c08008          STR      r8,[r0,#8]
;;;1168         _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000058  2100              MOVS     r1,#0
00005a  eb040244          ADD      r2,r4,r4,LSL #1
00005e  480f              LDR      r0,|L3.156|
000060  3048              ADDS     r0,r0,#0x48
000062  eb0000c2          ADD      r0,r0,r2,LSL #3
000066  6101              STR      r1,[r0,#0x10]
;;;1169         _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000068  eb040244          ADD      r2,r4,r4,LSL #1
00006c  480b              LDR      r0,|L3.156|
00006e  3048              ADDS     r0,r0,#0x48
000070  eb0000c2          ADD      r0,r0,r2,LSL #3
000074  60c1              STR      r1,[r0,#0xc]
                  |L3.118|
;;;1170       }
;;;1171       _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
000076  eb040144          ADD      r1,r4,r4,LSL #1
00007a  4808              LDR      r0,|L3.156|
00007c  3048              ADDS     r0,r0,#0x48
00007e  eb0000c1          ADD      r0,r0,r1,LSL #3
000082  f8c09014          STR      r9,[r0,#0x14]
;;;1172       SEGGER_RTT_UNLOCK();
000086  f89d0000          LDRB     r0,[sp,#0]
00008a  f7fffffe          BL       app_util_critical_region_exit
;;;1173       r =  0;
00008e  2500              MOVS     r5,#0
000090  e001              B        |L3.150|
                  |L3.146|
;;;1174     } else {
;;;1175       r = -1;
000092  f04f35ff          MOV      r5,#0xffffffff
                  |L3.150|
;;;1176     }
;;;1177     return r;
000096  4628              MOV      r0,r5
;;;1178   }
000098  e8bd83f8          POP      {r3-r9,pc}
;;;1179   
                          ENDP

                  |L3.156|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1110   */
;;;1111   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1112     int r;
;;;1113   
;;;1114     INIT();
000010  bf00              NOP      
000012  4822              LDR      r0,|L4.156|
000014  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000016  b908              CBNZ     r0,|L4.28|
000018  f7fffffe          BL       _DoInit
                  |L4.28|
00001c  bf00              NOP      
;;;1115     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001e  481f              LDR      r0,|L4.156|
000020  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000022  42a0              CMP      r0,r4
000024  d935              BLS      |L4.146|
;;;1116       SEGGER_RTT_LOCK();
000026  2000              MOVS     r0,#0
000028  9000              STR      r0,[sp,#0]
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       app_util_critical_region_enter
;;;1117       if (BufferIndex > 0u) {
000030  b30c              CBZ      r4,|L4.118|
;;;1118         _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000032  eb040144          ADD      r1,r4,r4,LSL #1
000036  4819              LDR      r0,|L4.156|
000038  3018              ADDS     r0,r0,#0x18
00003a  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1119         _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
00003e  eb040144          ADD      r1,r4,r4,LSL #1
000042  eb0000c1          ADD      r0,r0,r1,LSL #3
000046  6047              STR      r7,[r0,#4]
;;;1120         _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000048  eb040144          ADD      r1,r4,r4,LSL #1
00004c  4813              LDR      r0,|L4.156|
00004e  3018              ADDS     r0,r0,#0x18
000050  eb0000c1          ADD      r0,r0,r1,LSL #3
000054  f8c08008          STR      r8,[r0,#8]
;;;1121         _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000058  2100              MOVS     r1,#0
00005a  eb040244          ADD      r2,r4,r4,LSL #1
00005e  480f              LDR      r0,|L4.156|
000060  3018              ADDS     r0,r0,#0x18
000062  eb0000c2          ADD      r0,r0,r2,LSL #3
000066  6101              STR      r1,[r0,#0x10]
;;;1122         _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000068  eb040244          ADD      r2,r4,r4,LSL #1
00006c  480b              LDR      r0,|L4.156|
00006e  3018              ADDS     r0,r0,#0x18
000070  eb0000c2          ADD      r0,r0,r2,LSL #3
000074  60c1              STR      r1,[r0,#0xc]
                  |L4.118|
;;;1123       }
;;;1124       _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
000076  eb040144          ADD      r1,r4,r4,LSL #1
00007a  4808              LDR      r0,|L4.156|
00007c  3018              ADDS     r0,r0,#0x18
00007e  eb0000c1          ADD      r0,r0,r1,LSL #3
000082  f8c09014          STR      r9,[r0,#0x14]
;;;1125       SEGGER_RTT_UNLOCK();
000086  f89d0000          LDRB     r0,[sp,#0]
00008a  f7fffffe          BL       app_util_critical_region_exit
;;;1126       r =  0;
00008e  2500              MOVS     r5,#0
000090  e001              B        |L4.150|
                  |L4.146|
;;;1127     } else {
;;;1128       r = -1;
000092  f04f35ff          MOV      r5,#0xffffffff
                  |L4.150|
;;;1129     }
;;;1130     return r;
000096  4628              MOV      r0,r5
;;;1131   }
000098  e8bd83f8          POP      {r3-r9,pc}
;;;1132   
                          ENDP

                  |L4.156|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;909    */
;;;910    int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;911      char c;
;;;912      int r;
;;;913    
;;;914      r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;915      if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L5.24|
;;;916        r = (int)(unsigned char)c;
000012  f89d4000          LDRB     r4,[sp,#0]
000016  e001              B        |L5.28|
                  |L5.24|
;;;917      } else {
;;;918        r = -1;
000018  f04f34ff          MOV      r4,#0xffffffff
                  |L5.28|
;;;919      }
;;;920      return r;
00001c  4620              MOV      r0,r4
;;;921    }
00001e  bd38              POP      {r3-r5,pc}
;;;922    
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;986    */
;;;987    unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;988      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;989      unsigned                v;
;;;990    
;;;991      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  eb010441          ADD      r4,r1,r1,LSL #1
000008  4803              LDR      r0,|L6.24|
00000a  eb0002c4          ADD      r2,r0,r4,LSL #3
;;;992      v = pRing->WrOff;
00000e  68d3              LDR      r3,[r2,#0xc]
;;;993      return v - pRing->RdOff;
000010  6910              LDR      r0,[r2,#0x10]
000012  1a18              SUBS     r0,r3,r0
;;;994    }
000014  bd10              POP      {r4,pc}
;;;995    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      _SEGGER_RTT+0x48

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;960    */
;;;961    int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;962      unsigned RdOff;
;;;963      int r;
;;;964    
;;;965      INIT();
000002  bf00              NOP      
000004  4807              LDR      r0,|L7.36|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  b908              CBNZ     r0,|L7.14|
00000a  f7fffffe          BL       _DoInit
                  |L7.14|
00000e  bf00              NOP      
;;;966      RdOff = _SEGGER_RTT.aDown[0].RdOff;
000010  4804              LDR      r0,|L7.36|
000012  6d85              LDR      r5,[r0,#0x58]
;;;967      if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000014  6d40              LDR      r0,[r0,#0x54]
000016  42a8              CMP      r0,r5
000018  d001              BEQ      |L7.30|
;;;968        r = 1;
00001a  2401              MOVS     r4,#1
00001c  e000              B        |L7.32|
                  |L7.30|
;;;969      } else {
;;;970        r = 0;
00001e  2400              MOVS     r4,#0
                  |L7.32|
;;;971      }
;;;972      return r;
000020  4620              MOV      r0,r4
;;;973    }
000022  bd70              POP      {r4-r6,pc}
;;;974    
                          ENDP

                  |L7.36|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Init PROC
;;;1312   */
;;;1313   void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;1314     _DoInit();
000002  f7fffffe          BL       _DoInit
;;;1315   }
000006  bd10              POP      {r4,pc}
;;;1316   
                          ENDP


                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;545    */
;;;546    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;547      unsigned NumBytesRead;
;;;548      //
;;;549      SEGGER_RTT_LOCK();
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       app_util_critical_region_enter
;;;550      //
;;;551      // Call the non-locking read function
;;;552      //
;;;553      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
000012  4632              MOV      r2,r6
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SEGGER_RTT_ReadNoLock
00001c  4607              MOV      r7,r0
;;;554      //
;;;555      // Finish up.
;;;556      //
;;;557      SEGGER_RTT_UNLOCK();
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  f7fffffe          BL       app_util_critical_region_exit
;;;558      //
;;;559      return NumBytesRead;
000026  4638              MOV      r0,r7
;;;560    }
000028  bdf8              POP      {r3-r7,pc}
;;;561    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;478    */
;;;479    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4617              MOV      r7,r2
;;;480      unsigned                NumBytesRem;
;;;481      unsigned                NumBytesRead;
;;;482      unsigned                RdOff;
;;;483      unsigned                WrOff;
;;;484      unsigned char*          pBuffer;
;;;485      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;486      //
;;;487      INIT();
000008  bf00              NOP      
00000a  4822              LDR      r0,|L10.148|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L10.20|
000010  f7fffffe          BL       _DoInit
                  |L10.20|
000014  bf00              NOP      
;;;488      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  eb0b014b          ADD      r1,r11,r11,LSL #1
00001a  481e              LDR      r0,|L10.148|
00001c  3048              ADDS     r0,r0,#0x48
00001e  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;489      pBuffer = (unsigned char*)pData;
000022  f8dd9004          LDR      r9,[sp,#4]
;;;490      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;491      WrOff = pRing->WrOff;
000028  f8d6a00c          LDR      r10,[r6,#0xc]
;;;492      NumBytesRead = 0u;
00002c  f04f0800          MOV      r8,#0
;;;493      //
;;;494      // Read from current read position to wrap-around of buffer, first
;;;495      //
;;;496      if (RdOff > WrOff) {
000030  4555              CMP      r5,r10
000032  d915              BLS      |L10.96|
;;;497        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000034  68b0              LDR      r0,[r6,#8]
000036  1b44              SUBS     r4,r0,r5
;;;498        NumBytesRem = MIN(NumBytesRem, BufferSize);
000038  42bc              CMP      r4,r7
00003a  d201              BCS      |L10.64|
00003c  4620              MOV      r0,r4
00003e  e000              B        |L10.66|
                  |L10.64|
000040  4638              MOV      r0,r7
                  |L10.66|
000042  4604              MOV      r4,r0
;;;499        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000044  6870              LDR      r0,[r6,#4]
000046  1941              ADDS     r1,r0,r5
000048  4622              MOV      r2,r4
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       __aeabi_memcpy
;;;500        NumBytesRead += NumBytesRem;
000050  44a0              ADD      r8,r8,r4
;;;501        pBuffer      += NumBytesRem;
000052  44a1              ADD      r9,r9,r4
;;;502        BufferSize   -= NumBytesRem;
000054  1b3f              SUBS     r7,r7,r4
;;;503        RdOff        += NumBytesRem;
000056  4425              ADD      r5,r5,r4
;;;504        //
;;;505        // Handle wrap-around of buffer
;;;506        //
;;;507        if (RdOff == pRing->SizeOfBuffer) {
000058  68b0              LDR      r0,[r6,#8]
00005a  42a8              CMP      r0,r5
00005c  d100              BNE      |L10.96|
;;;508          RdOff = 0u;
00005e  2500              MOVS     r5,#0
                  |L10.96|
;;;509        }
;;;510      }
;;;511      //
;;;512      // Read remaining items of buffer
;;;513      //
;;;514      NumBytesRem = WrOff - RdOff;
000060  ebaa0405          SUB      r4,r10,r5
;;;515      NumBytesRem = MIN(NumBytesRem, BufferSize);
000064  42bc              CMP      r4,r7
000066  d201              BCS      |L10.108|
000068  4620              MOV      r0,r4
00006a  e000              B        |L10.110|
                  |L10.108|
00006c  4638              MOV      r0,r7
                  |L10.110|
00006e  4604              MOV      r4,r0
;;;516      if (NumBytesRem > 0u) {
000070  b14c              CBZ      r4,|L10.134|
;;;517        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000072  6870              LDR      r0,[r6,#4]
000074  1941              ADDS     r1,r0,r5
000076  4622              MOV      r2,r4
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       __aeabi_memcpy
;;;518        NumBytesRead += NumBytesRem;
00007e  44a0              ADD      r8,r8,r4
;;;519        pBuffer      += NumBytesRem;
000080  44a1              ADD      r9,r9,r4
;;;520        BufferSize   -= NumBytesRem;
000082  1b3f              SUBS     r7,r7,r4
;;;521        RdOff        += NumBytesRem;
000084  4425              ADD      r5,r5,r4
                  |L10.134|
;;;522      }
;;;523      if (NumBytesRead) {
000086  f1b80f00          CMP      r8,#0
00008a  d000              BEQ      |L10.142|
;;;524        pRing->RdOff = RdOff;
00008c  6135              STR      r5,[r6,#0x10]
                  |L10.142|
;;;525      }
;;;526      //
;;;527      return NumBytesRead;
00008e  4640              MOV      r0,r8
;;;528    }
000090  e8bd8ffe          POP      {r1-r11,pc}
;;;529    
                          ENDP

                  |L10.148|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1288   */
;;;1289   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1290     int r;
;;;1291   
;;;1292     INIT();
000006  bf00              NOP      
000008  480f              LDR      r0,|L11.72|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L11.18|
00000e  f7fffffe          BL       _DoInit
                  |L11.18|
000012  bf00              NOP      
;;;1293     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480c              LDR      r0,|L11.72|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d911              BLS      |L11.64|
;;;1294       SEGGER_RTT_LOCK();
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;1295       _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
000026  eb040144          ADD      r1,r4,r4,LSL #1
00002a  4807              LDR      r0,|L11.72|
00002c  3048              ADDS     r0,r0,#0x48
00002e  eb0000c1          ADD      r0,r0,r1,LSL #3
000032  6146              STR      r6,[r0,#0x14]
;;;1296       SEGGER_RTT_UNLOCK();
000034  f89d0000          LDRB     r0,[sp,#0]
000038  f7fffffe          BL       app_util_critical_region_exit
;;;1297       r =  0;
00003c  2500              MOVS     r5,#0
00003e  e001              B        |L11.68|
                  |L11.64|
;;;1298     } else {
;;;1299       r = -1;
000040  f04f35ff          MOV      r5,#0xffffffff
                  |L11.68|
;;;1300     }
;;;1301     return r;
000044  4628              MOV      r0,r5
;;;1302   }
000046  bdf8              POP      {r3-r7,pc}
;;;1303   
                          ENDP

                  |L11.72|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1257   */
;;;1258   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1259     int r;
;;;1260   
;;;1261     INIT();
000006  bf00              NOP      
000008  480f              LDR      r0,|L12.72|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L12.18|
00000e  f7fffffe          BL       _DoInit
                  |L12.18|
000012  bf00              NOP      
;;;1262     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480c              LDR      r0,|L12.72|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d911              BLS      |L12.64|
;;;1263       SEGGER_RTT_LOCK();
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;1264       _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
000026  eb040144          ADD      r1,r4,r4,LSL #1
00002a  4807              LDR      r0,|L12.72|
00002c  3018              ADDS     r0,r0,#0x18
00002e  eb0000c1          ADD      r0,r0,r1,LSL #3
000032  6146              STR      r6,[r0,#0x14]
;;;1265       SEGGER_RTT_UNLOCK();
000034  f89d0000          LDRB     r0,[sp,#0]
000038  f7fffffe          BL       app_util_critical_region_exit
;;;1266       r =  0;
00003c  2500              MOVS     r5,#0
00003e  e001              B        |L12.68|
                  |L12.64|
;;;1267     } else {
;;;1268       r = -1;
000040  f04f35ff          MOV      r5,#0xffffffff
                  |L12.68|
;;;1269     }
;;;1270     return r;
000044  4628              MOV      r0,r5
;;;1271   }
000046  bdf8              POP      {r3-r7,pc}
;;;1272   
                          ENDP

                  |L12.72|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1226   */
;;;1227   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1228     int r;
;;;1229   
;;;1230     INIT();
000006  bf00              NOP      
000008  480f              LDR      r0,|L13.72|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L13.18|
00000e  f7fffffe          BL       _DoInit
                  |L13.18|
000012  bf00              NOP      
;;;1231     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000014  480c              LDR      r0,|L13.72|
000016  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d910              BLS      |L13.62|
;;;1232       SEGGER_RTT_LOCK();
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;1233       _SEGGER_RTT.aDown[BufferIndex].sName = sName;
000026  eb040144          ADD      r1,r4,r4,LSL #1
00002a  4807              LDR      r0,|L13.72|
00002c  3048              ADDS     r0,r0,#0x48
00002e  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1234       SEGGER_RTT_UNLOCK();
000032  f89d0000          LDRB     r0,[sp,#0]
000036  f7fffffe          BL       app_util_critical_region_exit
;;;1235       r =  0;
00003a  2500              MOVS     r5,#0
00003c  e001              B        |L13.66|
                  |L13.62|
;;;1236     } else {
;;;1237       r = -1;
00003e  f04f35ff          MOV      r5,#0xffffffff
                  |L13.66|
;;;1238     }
;;;1239     return r;
000042  4628              MOV      r0,r5
;;;1240   }
000044  bdf8              POP      {r3-r7,pc}
;;;1241   
                          ENDP

000046  0000              DCW      0x0000
                  |L13.72|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1195   */
;;;1196   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1197     int r;
;;;1198   
;;;1199     INIT();
000006  bf00              NOP      
000008  480f              LDR      r0,|L14.72|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L14.18|
00000e  f7fffffe          BL       _DoInit
                  |L14.18|
000012  bf00              NOP      
;;;1200     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000014  480c              LDR      r0,|L14.72|
000016  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
000018  42a0              CMP      r0,r4
00001a  d910              BLS      |L14.62|
;;;1201       SEGGER_RTT_LOCK();
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;1202       _SEGGER_RTT.aUp[BufferIndex].sName = sName;
000026  eb040144          ADD      r1,r4,r4,LSL #1
00002a  4807              LDR      r0,|L14.72|
00002c  3018              ADDS     r0,r0,#0x18
00002e  f8406031          STR      r6,[r0,r1,LSL #3]
;;;1203       SEGGER_RTT_UNLOCK();
000032  f89d0000          LDRB     r0,[sp,#0]
000036  f7fffffe          BL       app_util_critical_region_exit
;;;1204       r =  0;
00003a  2500              MOVS     r5,#0
00003c  e001              B        |L14.66|
                  |L14.62|
;;;1205     } else {
;;;1206       r = -1;
00003e  f04f35ff          MOV      r5,#0xffffffff
                  |L14.66|
;;;1207     }
;;;1208     return r;
000042  4628              MOV      r0,r5
;;;1209   }
000044  bdf8              POP      {r3-r7,pc}
;;;1210   
                          ENDP

000046  0000              DCW      0x0000
                  |L14.72|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1330   */
;;;1331   int SEGGER_RTT_SetTerminal (char TerminalId) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4604              MOV      r4,r0
;;;1332     char                  ac[2];
;;;1333     SEGGER_RTT_BUFFER_UP* pRing;
;;;1334     unsigned Avail;
;;;1335     int r;
;;;1336     //
;;;1337     INIT();
000006  bf00              NOP      
000008  481e              LDR      r0,|L15.132|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  b908              CBNZ     r0,|L15.18|
00000e  f7fffffe          BL       _DoInit
                  |L15.18|
000012  bf00              NOP      
;;;1338     //
;;;1339     r = 0;
000014  2700              MOVS     r7,#0
;;;1340     ac[0] = 0xFFU;
000016  20ff              MOVS     r0,#0xff
000018  f88d0004          STRB     r0,[sp,#4]
;;;1341     if ((unsigned char)TerminalId < (unsigned char)sizeof(_aTerminalId)) { // We only support a certain number of channels
00001c  2c10              CMP      r4,#0x10
00001e  da2c              BGE      |L15.122|
;;;1342       ac[1] = _aTerminalId[(unsigned char)TerminalId];
000020  4819              LDR      r0,|L15.136|
000022  5d00              LDRB     r0,[r0,r4]
000024  f88d0005          STRB     r0,[sp,#5]
;;;1343       pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000028  4d16              LDR      r5,|L15.132|
00002a  3518              ADDS     r5,r5,#0x18
;;;1344       SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002c  2000              MOVS     r0,#0
00002e  9000              STR      r0,[sp,#0]
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       app_util_critical_region_enter
;;;1345       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
000036  7d28              LDRB     r0,[r5,#0x14]
000038  f0000003          AND      r0,r0,#3
00003c  2802              CMP      r0,#2
00003e  d107              BNE      |L15.80|
;;;1346         _ActiveTerminal = TerminalId;
000040  4812              LDR      r0,|L15.140|
000042  7004              STRB     r4,[r0,#0]
;;;1347         _WriteBlocking(pRing, ac, 2u);
000044  2202              MOVS     r2,#2
000046  a901              ADD      r1,sp,#4
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       _WriteBlocking
00004e  e00f              B        |L15.112|
                  |L15.80|
;;;1348       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1349         Avail = _GetAvailWriteSpace(pRing);
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       _GetAvailWriteSpace
000056  4606              MOV      r6,r0
;;;1350         if (Avail >= 2) {
000058  2e02              CMP      r6,#2
00005a  d307              BCC      |L15.108|
;;;1351           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
00005c  480b              LDR      r0,|L15.140|
00005e  7004              STRB     r4,[r0,#0]
;;;1352           _WriteNoCheck(pRing, ac, 2u);
000060  2202              MOVS     r2,#2
000062  a901              ADD      r1,sp,#4
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       _WriteNoCheck
00006a  e001              B        |L15.112|
                  |L15.108|
;;;1353         } else {
;;;1354           r = -1;
00006c  f04f37ff          MOV      r7,#0xffffffff
                  |L15.112|
;;;1355         }
;;;1356       }
;;;1357       SEGGER_RTT_UNLOCK();
000070  f89d0000          LDRB     r0,[sp,#0]
000074  f7fffffe          BL       app_util_critical_region_exit
000078  e001              B        |L15.126|
                  |L15.122|
;;;1358     } else {
;;;1359       r = -1;
00007a  f04f37ff          MOV      r7,#0xffffffff
                  |L15.126|
;;;1360     }
;;;1361     return r;
00007e  4638              MOV      r0,r7
;;;1362   }
000080  e8bd81fc          POP      {r2-r8,pc}
;;;1363   
                          ENDP

                  |L15.132|
                          DCD      _SEGGER_RTT
                  |L15.136|
                          DCD      _aTerminalId
                  |L15.140|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1380   */
;;;1381   int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
;;;1382     int                   Status;
;;;1383     unsigned              FragLen;
;;;1384     unsigned              Avail;
;;;1385     SEGGER_RTT_BUFFER_UP* pRing;
;;;1386     //
;;;1387     INIT();
000008  bf00              NOP      
00000a  4838              LDR      r0,|L16.236|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L16.20|
000010  f7fffffe          BL       _DoInit
                  |L16.20|
000014  bf00              NOP      
;;;1388     //
;;;1389     // Validate terminal ID.
;;;1390     //
;;;1391     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da63              BGE      |L16.226|
;;;1392       //
;;;1393       // Get "to-host" ring buffer.
;;;1394       //
;;;1395       pRing = &_SEGGER_RTT.aUp[0];
00001a  f8df80d0          LDR      r8,|L16.236|
00001e  f1080818          ADD      r8,r8,#0x18
;;;1396       //
;;;1397       // Need to be able to change terminal, write data, change back.
;;;1398       // Compute the fixed and variable sizes.
;;;1399       //
;;;1400       FragLen = strlen(s);
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       strlen
000028  4606              MOV      r6,r0
;;;1401       //
;;;1402       // How we output depends upon the mode...
;;;1403       //
;;;1404       SEGGER_RTT_LOCK();
00002a  2000              MOVS     r0,#0
00002c  9000              STR      r0,[sp,#0]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       app_util_critical_region_enter
;;;1405       Avail = _GetAvailWriteSpace(pRing);
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       _GetAvailWriteSpace
00003a  4605              MOV      r5,r0
;;;1406       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
00003c  f8980014          LDRB     r0,[r8,#0x14]
000040  f0000003          AND      r0,r0,#3
000044  b120              CBZ      r0,|L16.80|
000046  2801              CMP      r0,#1
000048  d017              BEQ      |L16.122|
00004a  2802              CMP      r0,#2
00004c  d140              BNE      |L16.208|
00004e  e02f              B        |L16.176|
                  |L16.80|
;;;1407       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1408         //
;;;1409         // If we are in skip mode and there is no space for the whole
;;;1410         // of this output, don't bother switching terminals at all.
;;;1411         //
;;;1412         if (Avail < (FragLen + 4u)) {
000050  1d30              ADDS     r0,r6,#4
000052  4285              CMP      r5,r0
000054  d201              BCS      |L16.90|
;;;1413           Status = 0;
000056  2400              MOVS     r4,#0
000058  e00e              B        |L16.120|
                  |L16.90|
;;;1414         } else {
;;;1415           _PostTerminalSwitch(pRing, TerminalId);
00005a  4639              MOV      r1,r7
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       _PostTerminalSwitch
;;;1416           Status = (int)_WriteBlocking(pRing, s, FragLen);
000062  4632              MOV      r2,r6
000064  4649              MOV      r1,r9
000066  4640              MOV      r0,r8
000068  f7fffffe          BL       _WriteBlocking
00006c  4604              MOV      r4,r0
;;;1417           _PostTerminalSwitch(pRing, _ActiveTerminal);
00006e  4820              LDR      r0,|L16.240|
000070  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       _PostTerminalSwitch
                  |L16.120|
;;;1418         }
;;;1419         break;
000078  e02d              B        |L16.214|
                  |L16.122|
;;;1420       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1421         //
;;;1422         // If we are in trim mode and there is not enough space for everything,
;;;1423         // trim the output but always include the terminal switch.  If no room
;;;1424         // for terminal switch, skip that totally.
;;;1425         //
;;;1426         if (Avail < 4u) {
00007a  2d04              CMP      r5,#4
00007c  d202              BCS      |L16.132|
;;;1427           Status = -1;
00007e  f04f34ff          MOV      r4,#0xffffffff
000082  e014              B        |L16.174|
                  |L16.132|
;;;1428         } else {
;;;1429           _PostTerminalSwitch(pRing, TerminalId);
000084  4639              MOV      r1,r7
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       _PostTerminalSwitch
;;;1430           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
00008c  1f28              SUBS     r0,r5,#4
00008e  42b0              CMP      r0,r6
000090  d901              BLS      |L16.150|
000092  4630              MOV      r0,r6
000094  e000              B        |L16.152|
                  |L16.150|
000096  1f28              SUBS     r0,r5,#4
                  |L16.152|
000098  4602              MOV      r2,r0
00009a  4649              MOV      r1,r9
00009c  4640              MOV      r0,r8
00009e  f7fffffe          BL       _WriteBlocking
0000a2  4604              MOV      r4,r0
;;;1431           _PostTerminalSwitch(pRing, _ActiveTerminal);
0000a4  4812              LDR      r0,|L16.240|
0000a6  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000a8  4640              MOV      r0,r8
0000aa  f7fffffe          BL       _PostTerminalSwitch
                  |L16.174|
;;;1432         }
;;;1433         break;
0000ae  e012              B        |L16.214|
                  |L16.176|
;;;1434       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1435         //
;;;1436         // If we are in blocking mode, output everything.
;;;1437         //
;;;1438         _PostTerminalSwitch(pRing, TerminalId);
0000b0  4639              MOV      r1,r7
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       _PostTerminalSwitch
;;;1439         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000b8  4632              MOV      r2,r6
0000ba  4649              MOV      r1,r9
0000bc  4640              MOV      r0,r8
0000be  f7fffffe          BL       _WriteBlocking
0000c2  4604              MOV      r4,r0
;;;1440         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000c4  480a              LDR      r0,|L16.240|
0000c6  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000c8  4640              MOV      r0,r8
0000ca  f7fffffe          BL       _PostTerminalSwitch
;;;1441         break;
0000ce  e002              B        |L16.214|
                  |L16.208|
;;;1442       default:
;;;1443         Status = -1;
0000d0  f04f34ff          MOV      r4,#0xffffffff
;;;1444         break;
0000d4  bf00              NOP      
                  |L16.214|
0000d6  bf00              NOP                            ;1419
;;;1445       }
;;;1446       //
;;;1447       // Finish up.
;;;1448       //
;;;1449       SEGGER_RTT_UNLOCK();
0000d8  f89d0000          LDRB     r0,[sp,#0]
0000dc  f7fffffe          BL       app_util_critical_region_exit
0000e0  e001              B        |L16.230|
                  |L16.226|
;;;1450     } else {
;;;1451       Status = -1;
0000e2  f04f34ff          MOV      r4,#0xffffffff
                  |L16.230|
;;;1452     }
;;;1453     return Status;
0000e6  4620              MOV      r0,r4
;;;1454   }
0000e8  e8bd83f8          POP      {r3-r9,pc}
;;;1455   
                          ENDP

                  |L16.236|
                          DCD      _SEGGER_RTT
                  |L16.240|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;937    */
;;;938    int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;939      int r;
;;;940    
;;;941      do {
000002  bf00              NOP      
                  |L17.4|
;;;942        r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;943      } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L17.4|
;;;944      return r;
;;;945    }
00000c  bd10              POP      {r4,pc}
;;;946    
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;849    */
;;;850    unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;851      unsigned Status;
;;;852      //
;;;853      INIT();
000008  bf00              NOP      
00000a  480b              LDR      r0,|L18.56|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  b908              CBNZ     r0,|L18.20|
000010  f7fffffe          BL       _DoInit
                  |L18.20|
000014  bf00              NOP      
;;;854      SEGGER_RTT_LOCK();
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       app_util_critical_region_enter
;;;855      //
;;;856      // Call the non-locking write function
;;;857      //
;;;858      Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000020  4632              MOV      r2,r6
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       SEGGER_RTT_WriteNoLock
00002a  4607              MOV      r7,r0
;;;859      //
;;;860      // Finish up.
;;;861      //
;;;862      SEGGER_RTT_UNLOCK();
00002c  f89d0000          LDRB     r0,[sp,#0]
000030  f7fffffe          BL       app_util_critical_region_exit
;;;863      //
;;;864      return Status;
000034  4638              MOV      r0,r7
;;;865    }
000036  bdf8              POP      {r3-r7,pc}
;;;866    
                          ENDP

                  |L18.56|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;778    */
;;;779    unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;780      unsigned              Status;
;;;781      unsigned              Avail;
;;;782      const char*           pData;
;;;783      SEGGER_RTT_BUFFER_UP* pRing;
;;;784    
;;;785      pData = (const char *)pBuffer;
00000a  46c2              MOV      r10,r8
;;;786      //
;;;787      // Get "to-host" ring buffer.
;;;788      //
;;;789      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb070147          ADD      r1,r7,r7,LSL #1
000010  481b              LDR      r0,|L19.128|
000012  eb0009c1          ADD      r9,r0,r1,LSL #3
;;;790      //
;;;791      // How we output depends upon the mode...
;;;792      //
;;;793      switch (pRing->Flags) {
000016  f8d90014          LDR      r0,[r9,#0x14]
00001a  b120              CBZ      r0,|L19.38|
00001c  2801              CMP      r0,#1
00001e  d011              BEQ      |L19.68|
000020  2802              CMP      r0,#2
000022  d126              BNE      |L19.114|
000024  e01e              B        |L19.100|
                  |L19.38|
;;;794      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;795        //
;;;796        // If we are in skip mode and there is no space for the whole
;;;797        // of this output, don't bother.
;;;798        //
;;;799        Avail = _GetAvailWriteSpace(pRing);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       _GetAvailWriteSpace
00002c  4605              MOV      r5,r0
;;;800        if (Avail < NumBytes) {
00002e  42b5              CMP      r5,r6
000030  d201              BCS      |L19.54|
;;;801          Status = 0u;
000032  2400              MOVS     r4,#0
000034  e005              B        |L19.66|
                  |L19.54|
;;;802        } else {
;;;803          Status = NumBytes;
000036  4634              MOV      r4,r6
;;;804          _WriteNoCheck(pRing, pData, NumBytes);
000038  4632              MOV      r2,r6
00003a  4651              MOV      r1,r10
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       _WriteNoCheck
                  |L19.66|
;;;805        }
;;;806        break;
000042  e018              B        |L19.118|
                  |L19.68|
;;;807      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;808        //
;;;809        // If we are in trim mode, trim to what we can output without blocking.
;;;810        //
;;;811        Avail = _GetAvailWriteSpace(pRing);
000044  4648              MOV      r0,r9
000046  f7fffffe          BL       _GetAvailWriteSpace
00004a  4605              MOV      r5,r0
;;;812        Status = Avail < NumBytes ? Avail : NumBytes;
00004c  42b5              CMP      r5,r6
00004e  d201              BCS      |L19.84|
000050  4628              MOV      r0,r5
000052  e000              B        |L19.86|
                  |L19.84|
000054  4630              MOV      r0,r6
                  |L19.86|
000056  4604              MOV      r4,r0
;;;813        _WriteNoCheck(pRing, pData, Status);
000058  4622              MOV      r2,r4
00005a  4651              MOV      r1,r10
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       _WriteNoCheck
;;;814        break;
000062  e008              B        |L19.118|
                  |L19.100|
;;;815      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;816        //
;;;817        // If we are in blocking mode, output everything.
;;;818        //
;;;819        Status = _WriteBlocking(pRing, pData, NumBytes);
000064  4632              MOV      r2,r6
000066  4651              MOV      r1,r10
000068  4648              MOV      r0,r9
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;820        break;
000070  e001              B        |L19.118|
                  |L19.114|
;;;821      default:
;;;822        Status = 0u;
000072  2400              MOVS     r4,#0
;;;823        break;
000074  bf00              NOP      
                  |L19.118|
000076  bf00              NOP                            ;806
;;;824      }
;;;825      //
;;;826      // Finish up.
;;;827      //
;;;828      return Status;
000078  4620              MOV      r0,r4
;;;829    }
00007a  e8bd87f0          POP      {r4-r10,pc}
;;;830    
                          ENDP

00007e  0000              DCW      0x0000
                  |L19.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;668    */
;;;669    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4683              MOV      r11,r0
000006  4615              MOV      r5,r2
;;;670      const char*           pData;
;;;671      SEGGER_RTT_BUFFER_UP* pRing;
;;;672      unsigned              Avail;
;;;673      unsigned              RdOff;
;;;674      unsigned              WrOff;
;;;675      unsigned              Rem;
;;;676    
;;;677      pData = (const char *)pBuffer;
000008  f8dd9004          LDR      r9,[sp,#4]
;;;678      //
;;;679      // Get "to-host" ring buffer and copy some elements into local variables.
;;;680      //
;;;681      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb0b014b          ADD      r1,r11,r11,LSL #1
000010  4828              LDR      r0,|L20.180|
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;682      RdOff = pRing->RdOff;
000016  f8d4a010          LDR      r10,[r4,#0x10]
;;;683      WrOff = pRing->WrOff;
00001a  68e6              LDR      r6,[r4,#0xc]
;;;684      //
;;;685      // Handle the most common cases fastest.
;;;686      // Which is:
;;;687      //    RdOff <= WrOff -> Space until wrap around is free.
;;;688      //  AND
;;;689      //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
;;;690      //
;;;691      //  OR
;;;692      //
;;;693      //    RdOff > WrOff -> Space until RdOff - 1 is free.
;;;694      //  AND
;;;695      //    WrOff + NumBytes < RdOff -> Data fits into buffer
;;;696      //
;;;697      if (RdOff <= WrOff) {
00001c  45b2              CMP      r10,r6
00001e  d837              BHI      |L20.144|
;;;698        //
;;;699        // Get space until WrOff will be at wrap around.
;;;700        //
;;;701        Avail = pRing->SizeOfBuffer - 1u - WrOff ;
000020  68a0              LDR      r0,[r4,#8]
000022  1e40              SUBS     r0,r0,#1
000024  1b87              SUBS     r7,r0,r6
;;;702        if (Avail >= NumBytes) {
000026  42af              CMP      r7,r5
000028  d30f              BCC      |L20.74|
;;;703    #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
;;;704          char* pDst;
;;;705          pDst = pRing->pBuffer + WrOff;
00002a  6860              LDR      r0,[r4,#4]
00002c  1981              ADDS     r1,r0,r6
;;;706          WrOff += NumBytes;
00002e  442e              ADD      r6,r6,r5
;;;707          do {
000030  bf00              NOP      
                  |L20.50|
;;;708            *pDst++ = *pData++;
000032  f8190b01          LDRB     r0,[r9],#1
000036  f8010b01          STRB     r0,[r1],#1
;;;709          } while (--NumBytes);
00003a  1e68              SUBS     r0,r5,#1
00003c  1e05              SUBS     r5,r0,#0
00003e  d1f8              BNE      |L20.50|
;;;710          pRing->WrOff = WrOff + NumBytes;
000040  1970              ADDS     r0,r6,r5
000042  60e0              STR      r0,[r4,#0xc]
;;;711    #else
;;;712          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;713          pRing->WrOff = WrOff + NumBytes;
;;;714    #endif
;;;715          return 1;
000044  2001              MOVS     r0,#1
                  |L20.70|
;;;716        }
;;;717        //
;;;718        // If data did not fit into space until wrap around calculate complete space in buffer.
;;;719        //
;;;720        Avail += RdOff;
;;;721        //
;;;722        // If there is still no space for the whole of this output, don't bother.
;;;723        //
;;;724        if (Avail >= NumBytes) {
;;;725          //
;;;726          //  OK, we have enough space in buffer. Copy in one or 2 chunks
;;;727          //
;;;728          Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
;;;729          if (Rem > NumBytes) {
;;;730            memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;731            pRing->WrOff = WrOff + NumBytes;
;;;732          } else {
;;;733            //
;;;734            // We reach the end of the buffer, so need to wrap around
;;;735            //
;;;736            memcpy(pRing->pBuffer + WrOff, pData, Rem);
;;;737            memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
;;;738            pRing->WrOff = NumBytes - Rem;
;;;739          }
;;;740          return 1;
;;;741        }
;;;742      } else {
;;;743        Avail = RdOff - WrOff - 1u;
;;;744        if (Avail >= NumBytes) {
;;;745          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;746          pRing->WrOff = WrOff + NumBytes;
;;;747          return 1;
;;;748        }
;;;749      }
;;;750      //
;;;751      // If we reach this point no data has been written
;;;752      //
;;;753      return 0;
;;;754    }
000046  e8bd8ffe          POP      {r1-r11,pc}
                  |L20.74|
00004a  4457              ADD      r7,r7,r10             ;720
00004c  42af              CMP      r7,r5                 ;724
00004e  d32e              BCC      |L20.174|
000050  68a0              LDR      r0,[r4,#8]            ;728
000052  eba00806          SUB      r8,r0,r6              ;728
000056  45a8              CMP      r8,r5                 ;729
000058  d908              BLS      |L20.108|
00005a  6861              LDR      r1,[r4,#4]            ;730
00005c  1988              ADDS     r0,r1,r6              ;730
00005e  462a              MOV      r2,r5                 ;730
000060  4649              MOV      r1,r9                 ;730
000062  f7fffffe          BL       __aeabi_memcpy
000066  1970              ADDS     r0,r6,r5              ;731
000068  60e0              STR      r0,[r4,#0xc]          ;731
00006a  e00f              B        |L20.140|
                  |L20.108|
00006c  6861              LDR      r1,[r4,#4]            ;736
00006e  1988              ADDS     r0,r1,r6              ;736
000070  4642              MOV      r2,r8                 ;736
000072  4649              MOV      r1,r9                 ;736
000074  f7fffffe          BL       __aeabi_memcpy
000078  eba50208          SUB      r2,r5,r8              ;737
00007c  eb090108          ADD      r1,r9,r8              ;737
000080  6860              LDR      r0,[r4,#4]            ;737
000082  f7fffffe          BL       __aeabi_memcpy
000086  eba50008          SUB      r0,r5,r8              ;738
00008a  60e0              STR      r0,[r4,#0xc]          ;738
                  |L20.140|
00008c  2001              MOVS     r0,#1                 ;740
00008e  e7da              B        |L20.70|
                  |L20.144|
000090  ebaa0006          SUB      r0,r10,r6             ;743
000094  1e47              SUBS     r7,r0,#1              ;743
000096  42af              CMP      r7,r5                 ;744
000098  d309              BCC      |L20.174|
00009a  6861              LDR      r1,[r4,#4]            ;745
00009c  1988              ADDS     r0,r1,r6              ;745
00009e  462a              MOV      r2,r5                 ;745
0000a0  4649              MOV      r1,r9                 ;745
0000a2  f7fffffe          BL       __aeabi_memcpy
0000a6  1970              ADDS     r0,r6,r5              ;746
0000a8  60e0              STR      r0,[r4,#0xc]          ;746
0000aa  2001              MOVS     r0,#1                 ;747
0000ac  e7cb              B        |L20.70|
                  |L20.174|
0000ae  2000              MOVS     r0,#0                 ;753
0000b0  e7c9              B        |L20.70|
;;;755    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L20.180|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;887    */
;;;888    unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;889      unsigned Len;
;;;890    
;;;891      Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;892      return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;893    }
000018  bd70              POP      {r4-r6,pc}
;;;894    
                          ENDP


                          AREA ||i.SEGGER_RTT_WriteWithOverwriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;584    */
;;;585    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;586      const char*           pData;
;;;587      SEGGER_RTT_BUFFER_UP* pRing;
;;;588      unsigned              Avail;
;;;589    
;;;590      pData = (const char *)pBuffer;
00000a  464f              MOV      r7,r9
;;;591      //
;;;592      // Get "to-host" ring buffer and copy some elements into local variables.
;;;593      //
;;;594      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  eb080148          ADD      r1,r8,r8,LSL #1
000010  4827              LDR      r0,|L22.176|
000012  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;595      //
;;;596      // Check if we will overwrite data and need to adjust the RdOff.
;;;597      //
;;;598      if (pRing->WrOff == pRing->RdOff) {
000016  e9d40103          LDRD     r0,r1,[r4,#0xc]
00001a  4288              CMP      r0,r1
00001c  d102              BNE      |L22.36|
;;;599        Avail = pRing->SizeOfBuffer - 1u;
00001e  68a0              LDR      r0,[r4,#8]
000020  1e45              SUBS     r5,r0,#1
000022  e00e              B        |L22.66|
                  |L22.36|
;;;600      } else if ( pRing->WrOff < pRing->RdOff) {
000024  e9d40103          LDRD     r0,r1,[r4,#0xc]
000028  4288              CMP      r0,r1
00002a  d204              BCS      |L22.54|
;;;601        Avail = pRing->RdOff - pRing->WrOff - 1u;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1a40              SUBS     r0,r0,r1
000032  1e45              SUBS     r5,r0,#1
000034  e005              B        |L22.66|
                  |L22.54|
;;;602      } else {
;;;603        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
000036  6920              LDR      r0,[r4,#0x10]
000038  68e1              LDR      r1,[r4,#0xc]
00003a  1a40              SUBS     r0,r0,r1
00003c  1e40              SUBS     r0,r0,#1
00003e  68a1              LDR      r1,[r4,#8]
000040  1845              ADDS     r5,r0,r1
                  |L22.66|
;;;604      }
;;;605      if (NumBytes > Avail) {
000042  42ae              CMP      r6,r5
000044  d90c              BLS      |L22.96|
;;;606        pRing->RdOff += (NumBytes - Avail);
000046  6920              LDR      r0,[r4,#0x10]
000048  1b71              SUBS     r1,r6,r5
00004a  4408              ADD      r0,r0,r1
00004c  6120              STR      r0,[r4,#0x10]
;;;607        while (pRing->RdOff >= pRing->SizeOfBuffer) {
00004e  e003              B        |L22.88|
                  |L22.80|
;;;608          pRing->RdOff -= pRing->SizeOfBuffer;
000050  6920              LDR      r0,[r4,#0x10]
000052  68a1              LDR      r1,[r4,#8]
000054  1a40              SUBS     r0,r0,r1
000056  6120              STR      r0,[r4,#0x10]
                  |L22.88|
000058  6920              LDR      r0,[r4,#0x10]         ;607
00005a  68a1              LDR      r1,[r4,#8]            ;607
00005c  4288              CMP      r0,r1                 ;607
00005e  d2f7              BCS      |L22.80|
                  |L22.96|
;;;609        }
;;;610      }
;;;611      //
;;;612      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;613      //
;;;614      Avail = pRing->SizeOfBuffer - pRing->WrOff;
000060  e9d40102          LDRD     r0,r1,[r4,#8]
000064  1a45              SUBS     r5,r0,r1
;;;615      do {
000066  bf00              NOP      
                  |L22.104|
;;;616        if (Avail > NumBytes) {
000068  42b5              CMP      r5,r6
00006a  d90e              BLS      |L22.138|
;;;617          //
;;;618          // Last round
;;;619          //
;;;620    #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
;;;621          char* pDst;
;;;622          pDst = pRing->pBuffer + pRing->WrOff;
00006c  68e2              LDR      r2,[r4,#0xc]
00006e  6861              LDR      r1,[r4,#4]
000070  1888              ADDS     r0,r1,r2
;;;623          pRing->WrOff += NumBytes;
000072  68e1              LDR      r1,[r4,#0xc]
000074  4431              ADD      r1,r1,r6
000076  60e1              STR      r1,[r4,#0xc]
;;;624          do {
000078  bf00              NOP      
                  |L22.122|
;;;625            *pDst++ = *pData++;
00007a  f8171b01          LDRB     r1,[r7],#1
00007e  f8001b01          STRB     r1,[r0],#1
;;;626          } while (--NumBytes);
000082  1e71              SUBS     r1,r6,#1
000084  1e0e              SUBS     r6,r1,#0
000086  d1f8              BNE      |L22.122|
;;;627    #else
;;;628          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;629          pRing->WrOff += NumBytes;
;;;630    #endif
;;;631          break;  //Alternatively: NumBytes = 0;
000088  e00e              B        |L22.168|
                  |L22.138|
;;;632        } else {
;;;633          //
;;;634          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;635          //
;;;636          memcpy(pRing->pBuffer + pRing->WrOff, pData, Avail);
00008a  68e2              LDR      r2,[r4,#0xc]
00008c  6861              LDR      r1,[r4,#4]
00008e  1888              ADDS     r0,r1,r2
000090  462a              MOV      r2,r5
000092  4639              MOV      r1,r7
000094  f7fffffe          BL       __aeabi_memcpy
;;;637          pData += Avail;
000098  442f              ADD      r7,r7,r5
;;;638          pRing->WrOff = 0;
00009a  2000              MOVS     r0,#0
00009c  60e0              STR      r0,[r4,#0xc]
;;;639          NumBytes -= Avail;
00009e  1b76              SUBS     r6,r6,r5
;;;640          Avail = (pRing->SizeOfBuffer - 1);
0000a0  68a0              LDR      r0,[r4,#8]
0000a2  1e45              SUBS     r5,r0,#1
;;;641        }
;;;642      } while (NumBytes);
0000a4  2e00              CMP      r6,#0
0000a6  d1df              BNE      |L22.104|
                  |L22.168|
0000a8  bf00              NOP                            ;631
;;;643    }
0000aa  e8bd87f0          POP      {r4-r10,pc}
;;;644    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L22.176|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;271                    } while (0)
;;;272    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;273      SEGGER_RTT_CB* p;
;;;274      //
;;;275      // Initialize control block
;;;276      //
;;;277      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L23.76|
;;;278      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2002              MOVS     r0,#2
000006  6120              STR      r0,[r4,#0x10]
;;;279      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;280      //
;;;281      // Initialize up buffer 0
;;;282      //
;;;283      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L23.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;284      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L23.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;285      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  f44f7100          MOV      r1,#0x200
000016  6221              STR      r1,[r4,#0x20]
;;;286      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;287      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;288      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;289      //
;;;290      // Initialize down buffer 0
;;;291      //
;;;292      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L23.80|
000022  64a0              STR      r0,[r4,#0x48]
;;;293      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L23.96|
000026  64e1              STR      r1,[r4,#0x4c]
;;;294      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  6521              STR      r1,[r4,#0x50]
;;;295      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  65a1              STR      r1,[r4,#0x58]
;;;296      p->aDown[0].WrOff         = 0u;
000030  6561              STR      r1,[r4,#0x54]
;;;297      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  65e1              STR      r1,[r4,#0x5c]
;;;298      //
;;;299      // Finish initialization of the control block.
;;;300      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;301      // in initializer memory (usually flash) by J-Link
;;;302      //
;;;303      strcpy(&p->acID[7], "RTT");
000034  a10b              ADR      r1,|L23.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;304      strcpy(&p->acID[0], "SEGGER");
00003c  a10a              ADR      r1,|L23.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;305      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;306    }
000048  bd10              POP      {r4,pc}
;;;307    
                          ENDP

00004a  0000              DCW      0x0000
                  |L23.76|
                          DCD      _SEGGER_RTT
                  |L23.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L23.92|
                          DCD      _acUpBuffer
                  |L23.96|
                          DCD      _acDownBuffer
                  |L23.100|
000064  52545400          DCB      "RTT",0
                  |L23.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;437    */
;;;438    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;439      unsigned RdOff;
;;;440      unsigned WrOff;
;;;441      unsigned r;
;;;442      //
;;;443      // Avoid warnings regarding volatile access order.  It's not a problem
;;;444      // in this case, but dampen compiler enthusiasm.
;;;445      //
;;;446      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;447      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;448      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L24.22|
;;;449        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L24.26|
                  |L24.22|
;;;450      } else {
;;;451        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L24.26|
;;;452      }
;;;453      return r;
;;;454    }
00001a  bd10              POP      {r4,pc}
;;;455    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;415    */
;;;416    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;417      char ac[2];
;;;418    
;;;419      ac[0] = 0xFFu;
000006  20ff              MOVS     r0,#0xff
000008  f88d0000          STRB     r0,[sp,#0]
;;;420      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L25.32|
00000e  5d00              LDRB     r0,[r0,r4]
000010  f88d0001          STRB     r0,[sp,#1]
;;;421      _WriteBlocking(pRing, ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;422    }
00001e  bd38              POP      {r3-r5,pc}
;;;423    
                          ENDP

                  |L25.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;326    */
;;;327    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;328      unsigned NumBytesToWrite;
;;;329      unsigned NumBytesWritten;
;;;330      unsigned RdOff;
;;;331      unsigned WrOff;
;;;332      //
;;;333      // Write data to buffer and handle wrap-around if necessary
;;;334      //
;;;335      NumBytesWritten = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;336      WrOff = pRing->WrOff;
00000e  68e5              LDR      r5,[r4,#0xc]
;;;337      do {
000010  bf00              NOP      
                  |L26.18|
;;;338        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000012  f8d48010          LDR      r8,[r4,#0x10]
;;;339        if (RdOff > WrOff) {
000016  45a8              CMP      r8,r5
000018  d903              BLS      |L26.34|
;;;340          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  eba80005          SUB      r0,r8,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L26.44|
                  |L26.34|
;;;341        } else {
;;;342          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  eba50008          SUB      r0,r5,r8
000026  1c40              ADDS     r0,r0,#1
000028  68a1              LDR      r1,[r4,#8]
00002a  1a0e              SUBS     r6,r1,r0
                  |L26.44|
;;;343        }
;;;344        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L26.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L26.60|
                  |L26.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L26.60|
00003c  4606              MOV      r6,r0
;;;345        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L26.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L26.72|
                  |L26.70|
000046  4638              MOV      r0,r7
                  |L26.72|
000048  4606              MOV      r6,r0
;;;346        memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       __aeabi_memcpy
;;;347        NumBytesWritten += NumBytesToWrite;
000056  44b2              ADD      r10,r10,r6
;;;348        pBuffer         += NumBytesToWrite;
000058  44b1              ADD      r9,r9,r6
;;;349        NumBytes        -= NumBytesToWrite;
00005a  1bbf              SUBS     r7,r7,r6
;;;350        WrOff           += NumBytesToWrite;
00005c  4435              ADD      r5,r5,r6
;;;351        if (WrOff == pRing->SizeOfBuffer) {
00005e  68a0              LDR      r0,[r4,#8]
000060  42a8              CMP      r0,r5
000062  d100              BNE      |L26.102|
;;;352          WrOff = 0u;
000064  2500              MOVS     r5,#0
                  |L26.102|
;;;353        }
;;;354        pRing->WrOff = WrOff;
000066  60e5              STR      r5,[r4,#0xc]
;;;355      } while (NumBytes);
000068  2f00              CMP      r7,#0
00006a  d1d2              BNE      |L26.18|
;;;356      //
;;;357      return NumBytesWritten;
00006c  4650              MOV      r0,r10
;;;358    }
00006e  e8bd87f0          POP      {r4-r10,pc}
;;;359    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;377    */
;;;378    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;379      unsigned NumBytesAtOnce;
;;;380      unsigned WrOff;
;;;381      unsigned Rem;
;;;382    
;;;383      WrOff = pRing->WrOff;
00000a  68e6              LDR      r6,[r4,#0xc]
;;;384      Rem = pRing->SizeOfBuffer - WrOff;
00000c  68a0              LDR      r0,[r4,#8]
00000e  1b87              SUBS     r7,r0,r6
;;;385      if (Rem > NumBytes) {
000010  42af              CMP      r7,r5
000012  d908              BLS      |L27.38|
;;;386        //
;;;387        // All data fits before wrap around
;;;388        //
;;;389        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
000014  6861              LDR      r1,[r4,#4]
000016  1988              ADDS     r0,r1,r6
000018  462a              MOV      r2,r5
00001a  4649              MOV      r1,r9
00001c  f7fffffe          BL       __aeabi_memcpy
;;;390        pRing->WrOff = WrOff + NumBytes;
000020  1970              ADDS     r0,r6,r5
000022  60e0              STR      r0,[r4,#0xc]
000024  e010              B        |L27.72|
                  |L27.38|
;;;391      } else {
;;;392        //
;;;393        // We reach the end of the buffer, so need to wrap around
;;;394        //
;;;395        NumBytesAtOnce = Rem;
000026  46b8              MOV      r8,r7
;;;396        memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000028  6861              LDR      r1,[r4,#4]
00002a  1988              ADDS     r0,r1,r6
00002c  4642              MOV      r2,r8
00002e  4649              MOV      r1,r9
000030  f7fffffe          BL       __aeabi_memcpy
;;;397        NumBytesAtOnce = NumBytes - Rem;
000034  eba50807          SUB      r8,r5,r7
;;;398        memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000038  eb090107          ADD      r1,r9,r7
00003c  4642              MOV      r2,r8
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       __aeabi_memcpy
;;;399        pRing->WrOff = NumBytesAtOnce;
000044  f8c4800c          STR      r8,[r4,#0xc]
                  |L27.72|
;;;400      }
;;;401    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;402    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        120
                  _acUpBuffer
                          %        512
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\external\\segger_rtt\\SEGGER_RTT.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_SEGGER_RTT_c_c0f1166c____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_SEGGER_RTT_c_c0f1166c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_SEGGER_RTT_c_c0f1166c____REVSH|
#line 402
|__asm___12_SEGGER_RTT_c_c0f1166c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_SEGGER_RTT_c_c0f1166c____RRX|
#line 587
|__asm___12_SEGGER_RTT_c_c0f1166c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
