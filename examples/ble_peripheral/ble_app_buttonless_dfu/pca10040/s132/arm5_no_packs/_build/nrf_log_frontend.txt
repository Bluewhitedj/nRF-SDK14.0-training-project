; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_log_frontend.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_log_frontend.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_log_frontend.crf ..\..\..\..\..\..\components\libraries\experimental_log\src\nrf_log_frontend.c]
                          THUMB

                          AREA ||i.backend_id_assign||, CODE, READONLY, ALIGN=2

                  backend_id_assign PROC
;;;781    
;;;782    static int32_t backend_id_assign(void)
000000  2100              MOVS     r1,#0
;;;783    {
;;;784        int32_t candidate_id;
;;;785        nrf_log_backend_t * p_backend;
;;;786        bool id_available;
;;;787        for (candidate_id = 0; candidate_id < NRF_LOG_MAX_BACKENDS; candidate_id++)
000002  e012              B        |L1.42|
                  |L1.4|
;;;788        {
;;;789            p_backend = m_log_data.p_backend_head;
000004  480b              LDR      r0,|L1.52|
000006  f8d02410          LDR      r2,[r0,#0x410]  ; m_log_data
;;;790            id_available = true;
00000a  2301              MOVS     r3,#1
;;;791            while (p_backend)
00000c  e006              B        |L1.28|
                  |L1.14|
;;;792            {
;;;793                if (nrf_log_backend_id_get(p_backend) == candidate_id)
00000e  bf00              NOP      
000010  7a10              LDRB     r0,[r2,#8]
000012  4288              CMP      r0,r1
000014  d101              BNE      |L1.26|
;;;794                {
;;;795                    id_available = false;
000016  2300              MOVS     r3,#0
;;;796                    break;
000018  e002              B        |L1.32|
                  |L1.26|
;;;797                }
;;;798                p_backend = p_backend->p_next;
00001a  6852              LDR      r2,[r2,#4]
                  |L1.28|
00001c  2a00              CMP      r2,#0                 ;791
00001e  d1f6              BNE      |L1.14|
                  |L1.32|
000020  bf00              NOP                            ;796
;;;799            }
;;;800            if (id_available)
000022  b10b              CBZ      r3,|L1.40|
;;;801            {
;;;802                return candidate_id;
000024  4608              MOV      r0,r1
                  |L1.38|
;;;803            }
;;;804        }
;;;805        return -1;
;;;806    }
000026  4770              BX       lr
                  |L1.40|
000028  1c49              ADDS     r1,r1,#1              ;787
                  |L1.42|
00002a  290a              CMP      r1,#0xa               ;787
00002c  dbea              BLT      |L1.4|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;805
000032  e7f8              B        |L1.38|
;;;807    
                          ENDP

                  |L1.52|
                          DCD      m_log_data

                          AREA ||i.buf_prealloc||, CODE, READONLY, ALIGN=2

                  buf_prealloc PROC
;;;375     */
;;;376    static inline bool buf_prealloc(uint32_t content_len, uint32_t * p_wr_idx)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;377    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;378        uint32_t req_len = content_len + HEADER_SIZE;
000008  1ca6              ADDS     r6,r4,#2
;;;379        uint32_t ovflw_tag_size = HEADER_SIZE;
00000a  2702              MOVS     r7,#2
;;;380        bool     ret            = true;
00000c  f04f0801          MOV      r8,#1
;;;381        CRITICAL_REGION_ENTER();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       app_util_critical_region_enter
;;;382        *p_wr_idx = m_log_data.wr_idx;
00001a  4815              LDR      r0,|L2.112|
00001c  6800              LDR      r0,[r0,#0]  ; m_log_data
00001e  6028              STR      r0,[r5,#0]
;;;383        uint32_t available_words = (m_log_data.mask + 1) - (m_log_data.wr_idx - m_log_data.rd_idx);
000020  4813              LDR      r0,|L2.112|
000022  6800              LDR      r0,[r0,#0]  ; m_log_data
000024  4912              LDR      r1,|L2.112|
000026  6849              LDR      r1,[r1,#4]  ; m_log_data
000028  1a41              SUBS     r1,r0,r1
00002a  4811              LDR      r0,|L2.112|
00002c  6880              LDR      r0,[r0,#8]  ; m_log_data
00002e  1c40              ADDS     r0,r0,#1
000030  eba00901          SUB      r9,r0,r1
;;;384        uint32_t required_words  = req_len + ovflw_tag_size; // room for current entry and overflow
000034  eb060a07          ADD      r10,r6,r7
;;;385        while (required_words > available_words)
000038  e00b              B        |L2.82|
                  |L2.58|
;;;386        {
;;;387            if (NRF_LOG_ALLOW_OVERFLOW)
;;;388            {
;;;389                log_skip();
00003a  f7fffffe          BL       log_skip
;;;390                available_words = (m_log_data.mask + 1) - (m_log_data.wr_idx - m_log_data.rd_idx);
00003e  480c              LDR      r0,|L2.112|
000040  6800              LDR      r0,[r0,#0]  ; m_log_data
000042  490b              LDR      r1,|L2.112|
000044  6849              LDR      r1,[r1,#4]  ; m_log_data
000046  1a41              SUBS     r1,r0,r1
000048  4809              LDR      r0,|L2.112|
00004a  6880              LDR      r0,[r0,#8]  ; m_log_data
00004c  1c40              ADDS     r0,r0,#1
00004e  eba00901          SUB      r9,r0,r1
                  |L2.82|
000052  45ca              CMP      r10,r9                ;385
000054  d8f1              BHI      |L2.58|
;;;391            }
;;;392            else
;;;393            {
;;;394                if (available_words >= HEADER_SIZE)
;;;395                {
;;;396                    // Overflow entry is injected
;;;397                    (void)std_header_set(NRF_LOG_LEVEL_WARNING, m_overflow_info, 0, m_log_data.wr_idx, m_log_data.mask);
;;;398                    req_len = HEADER_SIZE;
;;;399                }
;;;400                else
;;;401                {
;;;402                    // overflow case
;;;403                    ret = false;
;;;404                }
;;;405                break;
;;;406            }
;;;407    
;;;408        }
;;;409        m_log_data.wr_idx += req_len;
000056  4806              LDR      r0,|L2.112|
000058  6800              LDR      r0,[r0,#0]  ; m_log_data
00005a  4430              ADD      r0,r0,r6
00005c  4904              LDR      r1,|L2.112|
00005e  6008              STR      r0,[r1,#0]  ; m_log_data
;;;410    
;;;411        CRITICAL_REGION_EXIT();
000060  f89d0000          LDRB     r0,[sp,#0]
000064  f7fffffe          BL       app_util_critical_region_exit
;;;412        return ret;
000068  4640              MOV      r0,r8
;;;413    }
00006a  e8bd8ff8          POP      {r3-r11,pc}
;;;414    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      m_log_data

                          AREA ||i.buffer_is_empty||, CODE, READONLY, ALIGN=2

                  buffer_is_empty PROC
;;;642    
;;;643    bool buffer_is_empty(void)
000000  4804              LDR      r0,|L3.20|
;;;644    {
;;;645        return (m_log_data.rd_idx == m_log_data.wr_idx);
000002  6840              LDR      r0,[r0,#4]  ; m_log_data
000004  4903              LDR      r1,|L3.20|
000006  6809              LDR      r1,[r1,#0]  ; m_log_data
000008  4288              CMP      r0,r1
00000a  d101              BNE      |L3.16|
00000c  2001              MOVS     r0,#1
                  |L3.14|
;;;646    }
00000e  4770              BX       lr
                  |L3.16|
000010  2000              MOVS     r0,#0                 ;645
000012  e7fc              B        |L3.14|
;;;647    
                          ENDP

                  |L3.20|
                          DCD      m_log_data

                          AREA ||i.cont_buf_prealloc||, CODE, READONLY, ALIGN=2

                  cont_buf_prealloc PROC
;;;429     */
;;;430    static inline uint32_t * cont_buf_prealloc(uint32_t len32,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;431                                               uint32_t * p_offset,
;;;432                                               uint32_t * p_wr_idx)
;;;433    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;434        uint32_t * p_buf = NULL;
00000a  f04f0800          MOV      r8,#0
;;;435    
;;;436        len32 += PUSHED_HEADER_SIZE; // Increment because 32bit header is needed to be stored.
00000e  1c64              ADDS     r4,r4,#1
;;;437    
;;;438        CRITICAL_REGION_ENTER();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       app_util_critical_region_enter
;;;439        *p_wr_idx = m_log_data.wr_idx;
00001a  4823              LDR      r0,|L4.168|
00001c  6800              LDR      r0,[r0,#0]  ; m_log_data
00001e  6038              STR      r0,[r7,#0]
;;;440        uint32_t available_words = (m_log_data.mask + 1) -
000020  4821              LDR      r0,|L4.168|
000022  6800              LDR      r0,[r0,#0]  ; m_log_data
000024  4920              LDR      r1,|L4.168|
000026  6889              LDR      r1,[r1,#8]  ; m_log_data
000028  4008              ANDS     r0,r0,r1
00002a  491f              LDR      r1,|L4.168|
00002c  6889              LDR      r1,[r1,#8]  ; m_log_data
00002e  1c49              ADDS     r1,r1,#1
000030  1a0d              SUBS     r5,r1,r0
;;;441                                   (m_log_data.wr_idx & m_log_data.mask);
;;;442        if (len32 <= available_words)
000032  42ac              CMP      r4,r5
000034  d811              BHI      |L4.90|
;;;443        {
;;;444            // buffer will fit as is
;;;445            p_buf              = &m_log_data.buffer[(m_log_data.wr_idx + 1) & m_log_data.mask];
000036  481c              LDR      r0,|L4.168|
000038  6800              LDR      r0,[r0,#0]  ; m_log_data
00003a  1c40              ADDS     r0,r0,#1
00003c  491a              LDR      r1,|L4.168|
00003e  6889              LDR      r1,[r1,#8]  ; m_log_data
000040  4008              ANDS     r0,r0,r1
000042  4919              LDR      r1,|L4.168|
000044  310c              ADDS     r1,r1,#0xc
000046  eb010880          ADD      r8,r1,r0,LSL #2
;;;446            m_log_data.wr_idx += len32;
00004a  4817              LDR      r0,|L4.168|
00004c  6800              LDR      r0,[r0,#0]  ; m_log_data
00004e  4420              ADD      r0,r0,r4
000050  390c              SUBS     r1,r1,#0xc
000052  6008              STR      r0,[r1,#0]  ; m_log_data
;;;447            *p_offset          = 0;
000054  2000              MOVS     r0,#0
000056  6030              STR      r0,[r6,#0]
000058  e011              B        |L4.126|
                  |L4.90|
;;;448        }
;;;449        else if (len32 < (m_log_data.rd_idx & m_log_data.mask))
00005a  4813              LDR      r0,|L4.168|
00005c  6840              LDR      r0,[r0,#4]  ; m_log_data
00005e  4912              LDR      r1,|L4.168|
000060  6889              LDR      r1,[r1,#8]  ; m_log_data
000062  4008              ANDS     r0,r0,r1
000064  42a0              CMP      r0,r4
000066  d90a              BLS      |L4.126|
;;;450        {
;;;451            // wraping to the begining of the buffer
;;;452            m_log_data.wr_idx += (len32 + available_words - 1);
000068  480f              LDR      r0,|L4.168|
00006a  6801              LDR      r1,[r0,#0]  ; m_log_data
00006c  1960              ADDS     r0,r4,r5
00006e  1e40              SUBS     r0,r0,#1
000070  4408              ADD      r0,r0,r1
000072  490d              LDR      r1,|L4.168|
000074  6008              STR      r0,[r1,#0]  ; m_log_data
;;;453            *p_offset          = available_words - 1;
000076  1e68              SUBS     r0,r5,#1
000078  6030              STR      r0,[r6,#0]
;;;454            p_buf              = m_log_data.buffer;
00007a  f101080c          ADD      r8,r1,#0xc
                  |L4.126|
;;;455        }
;;;456        available_words = (m_log_data.mask + 1) - (m_log_data.wr_idx - m_log_data.rd_idx);
00007e  480a              LDR      r0,|L4.168|
000080  6800              LDR      r0,[r0,#0]  ; m_log_data
000082  4909              LDR      r1,|L4.168|
000084  6849              LDR      r1,[r1,#4]  ; m_log_data
000086  1a41              SUBS     r1,r0,r1
000088  4807              LDR      r0,|L4.168|
00008a  6880              LDR      r0,[r0,#8]  ; m_log_data
00008c  1c40              ADDS     r0,r0,#1
00008e  1a45              SUBS     r5,r0,r1
;;;457        // If there is no more room for even overflow tag indicate failed allocation.
;;;458        if (available_words < HEADER_SIZE)
000090  2d02              CMP      r5,#2
000092  d201              BCS      |L4.152|
;;;459        {
;;;460            p_buf = NULL;
000094  f04f0800          MOV      r8,#0
                  |L4.152|
;;;461        }
;;;462        CRITICAL_REGION_EXIT();
000098  f89d0000          LDRB     r0,[sp,#0]
00009c  f7fffffe          BL       app_util_critical_region_exit
;;;463    
;;;464        return p_buf;
0000a0  4640              MOV      r0,r8
;;;465    }
0000a2  e8bd83f8          POP      {r3-r9,pc}
;;;466    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L4.168|
                          DCD      m_log_data

                          AREA ||i.higher_lvl_get||, CODE, READONLY, ALIGN=1

                  higher_lvl_get PROC
;;;237    
;;;238    static uint32_t higher_lvl_get(uint32_t lvls)
000000  b510              PUSH     {r4,lr}
;;;239    {
000002  4603              MOV      r3,r0
;;;240        uint32_t top_lvl = 0;
000004  2000              MOVS     r0,#0
;;;241        uint32_t tmp_lvl;
;;;242        uint32_t i;
;;;243    
;;;244        //Find highest level enabled by backends
;;;245        for (i = 0; i < (32/NRF_LOG_LEVEL_BITS); i+=NRF_LOG_LEVEL_BITS)
000006  2100              MOVS     r1,#0
000008  e008              B        |L5.28|
                  |L5.10|
;;;246        {
;;;247            tmp_lvl = BF_GET(lvls,NRF_LOG_LEVEL_BITS, i);
00000a  2407              MOVS     r4,#7
00000c  408c              LSLS     r4,r4,r1
00000e  401c              ANDS     r4,r4,r3
000010  fa24f201          LSR      r2,r4,r1
;;;248            if (tmp_lvl > top_lvl)
000014  4282              CMP      r2,r0
000016  d900              BLS      |L5.26|
;;;249            {
;;;250                top_lvl = tmp_lvl;
000018  4610              MOV      r0,r2
                  |L5.26|
00001a  1cc9              ADDS     r1,r1,#3              ;245
                  |L5.28|
00001c  290a              CMP      r1,#0xa               ;245
00001e  d3f4              BCC      |L5.10|
;;;251            }
;;;252        }
;;;253        return top_lvl;
;;;254    }
000020  bd10              POP      {r4,pc}
;;;255    
                          ENDP


                          AREA ||i.log_skip||, CODE, READONLY, ALIGN=2

                  log_skip PROC
;;;299    
;;;300    static void log_skip(void)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;301    {
;;;302        uint32_t           rd_idx = m_log_data.rd_idx;
000004  4828              LDR      r0,|L6.168|
000006  6844              LDR      r4,[r0,#4]  ; m_log_data
;;;303        uint32_t           mask   = m_log_data.mask;
000008  6886              LDR      r6,[r0,#8]  ; m_log_data
;;;304        nrf_log_header_t * p_header = (nrf_log_header_t *)&m_log_data.buffer[rd_idx & mask];
00000a  ea040006          AND      r0,r4,r6
00000e  4926              LDR      r1,|L6.168|
000010  310c              ADDS     r1,r1,#0xc
000012  eb010780          ADD      r7,r1,r0,LSL #2
;;;305        nrf_log_header_t   header;
;;;306    
;;;307        (void)nrf_atomic_flag_set(&m_log_data.log_skipped);
000016  f201400c          ADD      r0,r1,#0x40c
00001a  f7fffffe          BL       nrf_atomic_flag_set
;;;308        (void)nrf_atomic_flag_set(&m_log_data.log_skipping);
00001e  4823              LDR      r0,|L6.172|
000020  f7fffffe          BL       nrf_atomic_flag_set
;;;309        // Skip any string that is pushed to the circular buffer.
;;;310        while (p_header->base.generic.type == HEADER_TYPE_PUSHED)
000024  e00d              B        |L6.66|
                  |L6.38|
;;;311        {
;;;312            rd_idx       += PUSHED_HEADER_SIZE;
000026  1c64              ADDS     r4,r4,#1
;;;313            rd_idx       += (p_header->base.pushed.len + p_header->base.pushed.offset);
000028  8838              LDRH     r0,[r7,#0]
00002a  f3c01089          UBFX     r0,r0,#6,#10
00002e  6839              LDR      r1,[r7,#0]
000030  eb005091          ADD      r0,r0,r1,LSR #22
000034  4404              ADD      r4,r4,r0
;;;314            p_header = (nrf_log_header_t *)&m_log_data.buffer[rd_idx & mask];
000036  ea040006          AND      r0,r4,r6
00003a  491b              LDR      r1,|L6.168|
00003c  310c              ADDS     r1,r1,#0xc
00003e  eb010780          ADD      r7,r1,r0,LSL #2
                  |L6.66|
000042  7838              LDRB     r0,[r7,#0]            ;310
000044  f0000003          AND      r0,r0,#3              ;310
000048  2800              CMP      r0,#0                 ;310
00004a  d0ec              BEQ      |L6.38|
;;;315        }
;;;316    
;;;317        uint32_t i;
;;;318        for (i = 0; i < HEADER_SIZE; i++)
00004c  2500              MOVS     r5,#0
00004e  e009              B        |L6.100|
                  |L6.80|
;;;319        {
;;;320            ((uint32_t*)&header)[i] = m_log_data.buffer[rd_idx++ & mask];
000050  4620              MOV      r0,r4
000052  1c64              ADDS     r4,r4,#1
000054  4030              ANDS     r0,r0,r6
000056  4914              LDR      r1,|L6.168|
000058  310c              ADDS     r1,r1,#0xc
00005a  f8510020          LDR      r0,[r1,r0,LSL #2]
00005e  f84d0025          STR      r0,[sp,r5,LSL #2]
000062  1c6d              ADDS     r5,r5,#1              ;318
                  |L6.100|
000064  2d02              CMP      r5,#2                 ;318
000066  d3f3              BCC      |L6.80|
;;;321        }
;;;322    
;;;323        if (header.base.generic.type == HEADER_TYPE_HEXDUMP)
000068  9800              LDR      r0,[sp,#0]
00006a  f0000003          AND      r0,r0,#3
00006e  2802              CMP      r0,#2
000070  d10a              BNE      |L6.136|
;;;324        {
;;;325            rd_idx += CEIL_DIV(header.base.hexdump.len, 4);
000072  2204              MOVS     r2,#4
000074  9900              LDR      r1,[sp,#0]
000076  eb025191          ADD      r1,r2,r1,LSR #22
00007a  1e48              SUBS     r0,r1,#1
00007c  17c1              ASRS     r1,r0,#31
00007e  eb007191          ADD      r1,r0,r1,LSR #30
000082  eb0404a1          ADD      r4,r4,r1,ASR #2
000086  e003              B        |L6.144|
                  |L6.136|
;;;326        }
;;;327        else //HEADER_TYPE_STD
;;;328        {
;;;329            rd_idx += header.base.std.nargs;
000088  9800              LDR      r0,[sp,#0]
00008a  f3c01083          UBFX     r0,r0,#6,#4
00008e  4404              ADD      r4,r4,r0
                  |L6.144|
;;;330        }
;;;331    
;;;332        uint32_t log_skipping_tmp = nrf_atomic_flag_clear_fetch(&m_log_data.log_skipping);
000090  4806              LDR      r0,|L6.172|
000092  f7fffffe          BL       nrf_atomic_flag_clear_fetch
000096  4680              MOV      r8,r0
;;;333        //update read index only if log_skip was not interrupted by another log skip
;;;334        if (log_skipping_tmp)
000098  f1b80f00          CMP      r8,#0
00009c  d001              BEQ      |L6.162|
;;;335        {
;;;336            m_log_data.rd_idx = rd_idx;
00009e  4802              LDR      r0,|L6.168|
0000a0  6044              STR      r4,[r0,#4]  ; m_log_data
                  |L6.162|
;;;337        }
;;;338    }
0000a2  e8bd83fe          POP      {r1-r9,pc}
;;;339    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L6.168|
                          DCD      m_log_data
                  |L6.172|
                          DCD      m_log_data+0x414

                          AREA ||i.module_idx_get||, CODE, READONLY, ALIGN=2

                  module_idx_get PROC
;;;177    
;;;178    static ret_code_t module_idx_get(uint32_t * p_idx, bool ordered_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;179    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;180        uint32_t module_cnt = nrf_log_module_cnt_get();
000006  f7fffffe          BL       nrf_log_module_cnt_get
00000a  4604              MOV      r4,r0
;;;181        if (ordered_idx)
00000c  b193              CBZ      r3,|L7.52|
;;;182        {
;;;183            uint32_t i;
;;;184            for (i = 0; i < module_cnt; i++)
00000e  2100              MOVS     r1,#0
000010  e00c              B        |L7.44|
                  |L7.18|
;;;185            {
;;;186                nrf_log_module_dynamic_data_t * p_module_data = NRF_LOG_DYNAMIC_SECTION_VARS_GET(i);
000012  eb010041          ADD      r0,r1,r1,LSL #1
000016  4e08              LDR      r6,|L7.56|
000018  eb060580          ADD      r5,r6,r0,LSL #2
;;;187                if (p_module_data->order_idx == *p_idx)
00001c  8868              LDRH     r0,[r5,#2]
00001e  6816              LDR      r6,[r2,#0]
000020  42b0              CMP      r0,r6
000022  d102              BNE      |L7.42|
;;;188                {
;;;189                    *p_idx = i;
000024  6011              STR      r1,[r2,#0]
;;;190                    return NRF_SUCCESS;
000026  2000              MOVS     r0,#0
                  |L7.40|
;;;191                }
;;;192            }
;;;193            return NRF_ERROR_NOT_FOUND;
;;;194        }
;;;195        else
;;;196        {
;;;197            return NRF_SUCCESS;
;;;198        }
;;;199    }
000028  bd70              POP      {r4-r6,pc}
                  |L7.42|
00002a  1c49              ADDS     r1,r1,#1              ;184
                  |L7.44|
00002c  42a1              CMP      r1,r4                 ;184
00002e  d3f0              BCC      |L7.18|
000030  2005              MOVS     r0,#5                 ;193
000032  e7f9              B        |L7.40|
                  |L7.52|
000034  2000              MOVS     r0,#0                 ;197
000036  e7f7              B        |L7.40|
;;;200    const char * nrf_log_module_name_get(uint32_t module_id, bool ordered_idx)
                          ENDP

                  |L7.56|
                          DCD      ||log_dynamic_data$$Base||

                          AREA ||i.nrf_atomic_flag_clear_fetch||, CODE, READONLY, ALIGN=1

                  nrf_atomic_flag_clear_fetch PROC
;;;471     * */
;;;472    static inline uint32_t nrf_atomic_flag_clear_fetch(nrf_atomic_flag_t * p_data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;473    {
000002  4604              MOV      r4,r0
;;;474        return nrf_atomic_u32_fetch_and(p_data, 0);
000004  2500              MOVS     r5,#0
000006  466a              MOV      r2,sp
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_and
000010  4606              MOV      r6,r0
000012  4630              MOV      r0,r6
;;;475    }
000014  bdf8              POP      {r3-r7,pc}
;;;476    
                          ENDP


                          AREA ||i.nrf_atomic_flag_set||, CODE, READONLY, ALIGN=1

                  nrf_atomic_flag_set PROC
;;;459     * */
;;;460    static inline uint32_t nrf_atomic_flag_set(nrf_atomic_flag_t * p_data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;461    {
000002  4604              MOV      r4,r0
;;;462        return nrf_atomic_u32_or(p_data, 1);
000004  2501              MOVS     r5,#1
000006  466a              MOV      r2,sp
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_orr
000010  4606              MOV      r6,r0
000012  9800              LDR      r0,[sp,#0]
;;;463    }
000014  bdf8              POP      {r3-r7,pc}
;;;464    
                          ENDP


                          AREA ||i.nrf_log_backend_add||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_add PROC
;;;807    
;;;808    int32_t nrf_log_backend_add(nrf_log_backend_t * p_backend, nrf_log_severity_t severity)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;809    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;810        int32_t id = backend_id_assign();
000008  f7fffffe          BL       backend_id_assign
00000c  4606              MOV      r6,r0
;;;811        if (id == -1)
00000e  1c70              ADDS     r0,r6,#1
000010  b910              CBNZ     r0,|L10.24|
;;;812        {
;;;813            return id;
000012  4630              MOV      r0,r6
                  |L10.20|
;;;814        }
;;;815    
;;;816        nrf_log_backend_id_set(p_backend, id);
;;;817        //add to list
;;;818        if (m_log_data.p_backend_head == NULL)
;;;819        {
;;;820           m_log_data.p_backend_head   = p_backend;
;;;821           p_backend->p_next = NULL;
;;;822        }
;;;823        else
;;;824        {
;;;825            p_backend->p_next = m_log_data.p_backend_head->p_next;
;;;826            m_log_data.p_backend_head->p_next = p_backend;
;;;827        }
;;;828    
;;;829        uint32_t i;
;;;830        for (i = 0; i < nrf_log_module_cnt_get(); i++)
;;;831        {
;;;832            nrf_log_severity_t buildin_lvl = nrf_log_module_filter_get(id, i, false, false);
;;;833            nrf_log_severity_t actual_severity = MIN(buildin_lvl, severity);
;;;834            nrf_log_module_filter_set(nrf_log_backend_id_get(p_backend), i, actual_severity);
;;;835        }
;;;836    
;;;837        return id;
;;;838    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L10.24|
000018  b2f0              UXTB     r0,r6                 ;816
00001a  7220              STRB     r0,[r4,#8]            ;816
00001c  bf00              NOP                            ;816
00001e  4818              LDR      r0,|L10.128|
000020  f8d00410          LDR      r0,[r0,#0x410]        ;818  ; m_log_data
000024  b928              CBNZ     r0,|L10.50|
000026  4816              LDR      r0,|L10.128|
000028  f8c04410          STR      r4,[r0,#0x410]        ;820  ; m_log_data
00002c  2000              MOVS     r0,#0                 ;821
00002e  6060              STR      r0,[r4,#4]            ;821
000030  e008              B        |L10.68|
                  |L10.50|
000032  4813              LDR      r0,|L10.128|
000034  f8d00410          LDR      r0,[r0,#0x410]        ;825  ; m_log_data
000038  6840              LDR      r0,[r0,#4]            ;825
00003a  6060              STR      r0,[r4,#4]            ;825
00003c  4810              LDR      r0,|L10.128|
00003e  f8d00410          LDR      r0,[r0,#0x410]        ;826  ; m_log_data
000042  6044              STR      r4,[r0,#4]            ;826
                  |L10.68|
000044  2500              MOVS     r5,#0                 ;830
000046  e014              B        |L10.114|
                  |L10.72|
000048  2300              MOVS     r3,#0                 ;832
00004a  461a              MOV      r2,r3                 ;832
00004c  4629              MOV      r1,r5                 ;832
00004e  4630              MOV      r0,r6                 ;832
000050  f7fffffe          BL       nrf_log_module_filter_get
000054  4680              MOV      r8,r0                 ;832
000056  45b8              CMP      r8,r7                 ;833
000058  da01              BGE      |L10.94|
00005a  4640              MOV      r0,r8                 ;833
00005c  e000              B        |L10.96|
                  |L10.94|
00005e  4638              MOV      r0,r7                 ;833
                  |L10.96|
000060  4681              MOV      r9,r0                 ;833
000062  bf00              NOP                            ;834
000064  7a20              LDRB     r0,[r4,#8]            ;834
000066  4603              MOV      r3,r0                 ;834
000068  464a              MOV      r2,r9                 ;834
00006a  4629              MOV      r1,r5                 ;834
00006c  f7fffffe          BL       nrf_log_module_filter_set
000070  1c6d              ADDS     r5,r5,#1              ;830
                  |L10.114|
000072  f7fffffe          BL       nrf_log_module_cnt_get
000076  42a8              CMP      r0,r5                 ;830
000078  d8e6              BHI      |L10.72|
00007a  4630              MOV      r0,r6                 ;837
00007c  e7ca              B        |L10.20|
;;;839    
                          ENDP

00007e  0000              DCW      0x0000
                  |L10.128|
                          DCD      m_log_data

                          AREA ||i.nrf_log_backend_remove||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_remove PROC
;;;839    
;;;840    void nrf_log_backend_remove(nrf_log_backend_t * p_backend)
000000  b510              PUSH     {r4,lr}
;;;841    {
;;;842        nrf_log_backend_t * p_curr = m_log_data.p_backend_head;
000002  4b09              LDR      r3,|L11.40|
000004  f8d31410          LDR      r1,[r3,#0x410]  ; m_log_data
;;;843        nrf_log_backend_t * p_prev = NULL;
000008  2200              MOVS     r2,#0
;;;844        while (p_curr != p_backend)
00000a  e001              B        |L11.16|
                  |L11.12|
;;;845        {
;;;846            p_prev = p_curr;
00000c  460a              MOV      r2,r1
;;;847            p_curr = p_curr->p_next;
00000e  6849              LDR      r1,[r1,#4]
                  |L11.16|
000010  4281              CMP      r1,r0                 ;844
000012  d1fb              BNE      |L11.12|
;;;848        }
;;;849    
;;;850        if (p_prev)
000014  b112              CBZ      r2,|L11.28|
;;;851        {
;;;852            p_prev->p_next = p_backend->p_next;
000016  6843              LDR      r3,[r0,#4]
000018  6053              STR      r3,[r2,#4]
00001a  e003              B        |L11.36|
                  |L11.28|
;;;853        }
;;;854        else
;;;855        {
;;;856            m_log_data.p_backend_head = NULL;
00001c  2300              MOVS     r3,#0
00001e  4c02              LDR      r4,|L11.40|
000020  f8c43410          STR      r3,[r4,#0x410]  ; m_log_data
                  |L11.36|
;;;857        }
;;;858    }
000024  bd10              POP      {r4,pc}
;;;859    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      m_log_data

                          AREA ||i.nrf_log_color_id_get||, CODE, READONLY, ALIGN=2

                  nrf_log_color_id_get PROC
;;;212    
;;;213    uint8_t nrf_log_color_id_get(uint32_t module_id, nrf_log_severity_t severity)
000000  b510              PUSH     {r4,lr}
;;;214    {
000002  4602              MOV      r2,r0
;;;215        nrf_log_module_const_data_t * p_module_data = NRF_LOG_CONST_SECTION_VARS_GET(module_id);
000004  4c0b              LDR      r4,|L12.52|
000006  eb0403c2          ADD      r3,r4,r2,LSL #3
;;;216        uint8_t color_id;
;;;217        switch (severity)
00000a  2901              CMP      r1,#1
00000c  d006              BEQ      |L12.28|
00000e  2902              CMP      r1,#2
000010  d006              BEQ      |L12.32|
000012  2903              CMP      r1,#3
000014  d006              BEQ      |L12.36|
000016  2904              CMP      r1,#4
000018  d108              BNE      |L12.44|
00001a  e005              B        |L12.40|
                  |L12.28|
;;;218        {
;;;219        case NRF_LOG_SEVERITY_ERROR:
;;;220            color_id = NRF_LOG_ERROR_COLOR;
00001c  2000              MOVS     r0,#0
;;;221            break;
00001e  e007              B        |L12.48|
                  |L12.32|
;;;222        case NRF_LOG_SEVERITY_WARNING:
;;;223            color_id = NRF_LOG_WARNING_COLOR;
000020  2000              MOVS     r0,#0
;;;224            break;
000022  e005              B        |L12.48|
                  |L12.36|
;;;225        case NRF_LOG_SEVERITY_INFO:
;;;226            color_id = p_module_data->info_color_id;
000024  7918              LDRB     r0,[r3,#4]
;;;227            break;
000026  e003              B        |L12.48|
                  |L12.40|
;;;228        case NRF_LOG_SEVERITY_DEBUG:
;;;229            color_id = p_module_data->debug_color_id;
000028  7958              LDRB     r0,[r3,#5]
;;;230            break;
00002a  e001              B        |L12.48|
                  |L12.44|
;;;231        default:
;;;232            color_id = 0;
00002c  2000              MOVS     r0,#0
;;;233            break;
00002e  bf00              NOP      
                  |L12.48|
000030  bf00              NOP                            ;221
;;;234        }
;;;235        return color_id;
;;;236    }
000032  bd10              POP      {r4,pc}
;;;237    
                          ENDP

                  |L12.52|
                          DCD      ||log_const_data$$Base||

                          AREA ||i.nrf_log_frontend_dequeue||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_dequeue PROC
;;;648    
;;;649    bool nrf_log_frontend_dequeue(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;650    {
000004  b08b              SUB      sp,sp,#0x2c
;;;651        if (buffer_is_empty())
000006  f7fffffe          BL       buffer_is_empty
00000a  b118              CBZ      r0,|L13.20|
;;;652        {
;;;653            return false;
00000c  2000              MOVS     r0,#0
                  |L13.14|
;;;654        }
;;;655        m_log_data.log_skipping     = 0;
;;;656        uint32_t           rd_idx   = m_log_data.rd_idx;
;;;657        uint32_t           mask     = m_log_data.mask;
;;;658        nrf_log_header_t * p_header = (nrf_log_header_t *)&m_log_data.buffer[rd_idx & mask];
;;;659        nrf_log_header_t   header;
;;;660        nrf_memobj_t *     p_msg_buf;
;;;661        uint32_t           memobj_offset = 0;
;;;662        uint32_t           severity;
;;;663    
;;;664        // Skip any string that is pushed to the circular buffer.
;;;665        while (p_header->base.generic.type == HEADER_TYPE_PUSHED)
;;;666        {
;;;667            rd_idx       += PUSHED_HEADER_SIZE;
;;;668            rd_idx       += (p_header->base.pushed.len + p_header->base.pushed.offset);
;;;669            p_header = (nrf_log_header_t *)&m_log_data.buffer[rd_idx & mask];
;;;670        }
;;;671    
;;;672        uint32_t i;
;;;673        for (i = 0; i < HEADER_SIZE; i++)
;;;674        {
;;;675            ((uint32_t*)&header)[i] = m_log_data.buffer[rd_idx++ & mask];
;;;676        }
;;;677    
;;;678        if (header.base.generic.type == HEADER_TYPE_HEXDUMP)
;;;679        {
;;;680            uint32_t orig_data_len  = header.base.hexdump.len;
;;;681            uint32_t data_len       = MIN(header.base.hexdump.len, NRF_LOG_MAX_HEXDUMP); //limit the data
;;;682            header.base.hexdump.len = data_len;
;;;683            uint32_t msg_buf_size8  = sizeof(uint32_t)*HEADER_SIZE + data_len;
;;;684            severity = header.base.hexdump.severity;
;;;685            p_msg_buf = nrf_memobj_alloc(&mempool, msg_buf_size8);
;;;686    
;;;687            if (p_msg_buf)
;;;688            {
;;;689                nrf_memobj_get(p_msg_buf);
;;;690                nrf_memobj_write(p_msg_buf, &header, HEADER_SIZE*sizeof(uint32_t), memobj_offset);
;;;691                memobj_offset += HEADER_SIZE*sizeof(uint32_t);
;;;692    
;;;693                uint32_t space0 = sizeof(uint32_t) * (mask + 1 - (rd_idx & mask));
;;;694                if (data_len > space0)
;;;695                        {
;;;696                    uint8_t * ptr0 = space0 ?
;;;697                                     (uint8_t *)&m_log_data.buffer[rd_idx & mask] :
;;;698                                     (uint8_t *)&m_log_data.buffer[0];
;;;699                    uint8_t   len0 = space0 ? space0 : data_len;
;;;700                    uint8_t * ptr1 = space0 ?
;;;701                                     (uint8_t *)&m_log_data.buffer[0] : NULL;
;;;702                    uint8_t len1 = space0 ? data_len - space0 : 0;
;;;703    
;;;704                    nrf_memobj_write(p_msg_buf, ptr0, len0, memobj_offset);
;;;705                    memobj_offset += len0;
;;;706                    if (ptr1)
;;;707                    {
;;;708                        nrf_memobj_write(p_msg_buf, ptr1, len1, memobj_offset);
;;;709                    }
;;;710                }
;;;711                else
;;;712                {
;;;713                    uint8_t * p_data = (uint8_t *)&m_log_data.buffer[rd_idx & mask];
;;;714                    nrf_memobj_write(p_msg_buf, p_data, data_len, memobj_offset);
;;;715                }
;;;716                rd_idx += CEIL_DIV(orig_data_len, 4);
;;;717            }
;;;718        }
;;;719        else // standard entry
;;;720        {
;;;721            header.base.std.nargs = MIN(header.base.std.nargs, NRF_LOG_MAX_NUM_OF_ARGS);
;;;722            uint32_t msg_buf_size32 = HEADER_SIZE + header.base.std.nargs;
;;;723            severity = header.base.std.severity;
;;;724            p_msg_buf = nrf_memobj_alloc(&mempool, msg_buf_size32*sizeof(uint32_t));
;;;725    
;;;726            if (p_msg_buf)
;;;727            {
;;;728                nrf_memobj_get(p_msg_buf);
;;;729                nrf_memobj_write(p_msg_buf, &header, HEADER_SIZE*sizeof(uint32_t), memobj_offset);
;;;730                memobj_offset += HEADER_SIZE*sizeof(uint32_t);
;;;731    
;;;732                for (i = 0; i < header.base.std.nargs; i++)
;;;733                {
;;;734                    nrf_memobj_write(p_msg_buf, &m_log_data.buffer[rd_idx++ & mask],
;;;735                                     sizeof(uint32_t), memobj_offset);
;;;736                    memobj_offset += sizeof(uint32_t);
;;;737                }
;;;738            }
;;;739        }
;;;740        if (p_msg_buf)
;;;741        {
;;;742            // Check if any log was skipped during log processing. Do not forward log if skipping occured
;;;743            // because data may be invalid.
;;;744            uint32_t skipping = nrf_atomic_flag_clear_fetch(&m_log_data.log_skipping);
;;;745            nrf_log_backend_t * p_backend = m_log_data.p_backend_head;
;;;746             while (p_backend && (skipping == 0))
;;;747             {
;;;748                 bool entry_accepted = false;
;;;749                 if (nrf_log_backend_is_enabled(p_backend) == true)
;;;750                 {
;;;751                     if (NRF_LOG_FILTERS_ENABLED)
;;;752                     {
;;;753                         uint8_t backend_id = nrf_log_backend_id_get(p_backend);
;;;754                         uint32_t filter_lvls = NRF_LOG_DYNAMIC_SECTION_VARS_GET(header.module_id)->filter_lvls;
;;;755                         uint32_t backend_lvl = (filter_lvls >> (backend_id*NRF_LOG_LEVEL_BITS))
;;;756                                                 & NRF_LOG_LEVEL_MASK;
;;;757                         if (backend_lvl >= severity)
;;;758                         {
;;;759                             entry_accepted = true;
;;;760                         }
;;;761                     }
;;;762                     else
;;;763                     {
;;;764                         (void)severity;
;;;765                         entry_accepted = true;
;;;766                     }
;;;767                 }
;;;768                 if (entry_accepted)
;;;769                 {
;;;770                     nrf_log_backend_put(p_backend, p_msg_buf);
;;;771                 }
;;;772                 p_backend = p_backend->p_next;
;;;773             }
;;;774    
;;;775             nrf_memobj_put(p_msg_buf);
;;;776             m_log_data.rd_idx = rd_idx;
;;;777        }
;;;778    
;;;779        return buffer_is_empty() ? false : true;
;;;780    }
00000e  b00b              ADD      sp,sp,#0x2c
000010  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.20|
000014  2000              MOVS     r0,#0                 ;655
000016  4994              LDR      r1,|L13.616|
000018  f8c10414          STR      r0,[r1,#0x414]        ;655  ; m_log_data
00001c  4608              MOV      r0,r1                 ;656
00001e  6844              LDR      r4,[r0,#4]            ;656  ; m_log_data
000020  6885              LDR      r5,[r0,#8]            ;657  ; m_log_data
000022  ea040005          AND      r0,r4,r5              ;658
000026  310c              ADDS     r1,r1,#0xc            ;658
000028  eb010a80          ADD      r10,r1,r0,LSL #2      ;658
00002c  2700              MOVS     r7,#0                 ;661
00002e  e00f              B        |L13.80|
                  |L13.48|
000030  1c64              ADDS     r4,r4,#1              ;667
000032  f8ba0000          LDRH     r0,[r10,#0]           ;668
000036  f3c01089          UBFX     r0,r0,#6,#10          ;668
00003a  f8da1000          LDR      r1,[r10,#0]           ;668
00003e  eb005091          ADD      r0,r0,r1,LSR #22      ;668
000042  4404              ADD      r4,r4,r0              ;668
000044  ea040005          AND      r0,r4,r5              ;669
000048  4987              LDR      r1,|L13.616|
00004a  310c              ADDS     r1,r1,#0xc            ;669
00004c  eb010a80          ADD      r10,r1,r0,LSL #2      ;669
                  |L13.80|
000050  f89a0000          LDRB     r0,[r10,#0]           ;665
000054  f0000003          AND      r0,r0,#3              ;665
000058  2800              CMP      r0,#0                 ;665
00005a  d0e9              BEQ      |L13.48|
00005c  f04f0800          MOV      r8,#0                 ;673
000060  e00b              B        |L13.122|
                  |L13.98|
000062  4620              MOV      r0,r4                 ;675
000064  1c64              ADDS     r4,r4,#1              ;675
000066  4028              ANDS     r0,r0,r5              ;675
000068  497f              LDR      r1,|L13.616|
00006a  310c              ADDS     r1,r1,#0xc            ;675
00006c  f8510020          LDR      r0,[r1,r0,LSL #2]     ;675
000070  a908              ADD      r1,sp,#0x20           ;675
000072  f8410028          STR      r0,[r1,r8,LSL #2]     ;675
000076  f1080801          ADD      r8,r8,#1              ;673
                  |L13.122|
00007a  f1b80f02          CMP      r8,#2                 ;673
00007e  d3f0              BCC      |L13.98|
000080  9808              LDR      r0,[sp,#0x20]         ;678
000082  f0000003          AND      r0,r0,#3              ;678
000086  2802              CMP      r0,#2                 ;678
000088  d17c              BNE      |L13.388|
00008a  9808              LDR      r0,[sp,#0x20]         ;680
00008c  0d80              LSRS     r0,r0,#22             ;680
00008e  9006              STR      r0,[sp,#0x18]         ;680
000090  2150              MOVS     r1,#0x50              ;681
000092  9808              LDR      r0,[sp,#0x20]         ;681
000094  ebb15f90          CMP      r1,r0,LSR #22         ;681
000098  dd02              BLE      |L13.160|
00009a  9808              LDR      r0,[sp,#0x20]         ;681
00009c  0d80              LSRS     r0,r0,#22             ;681
00009e  e000              B        |L13.162|
                  |L13.160|
0000a0  2050              MOVS     r0,#0x50              ;681
                  |L13.162|
0000a2  4683              MOV      r11,r0                ;681
0000a4  9808              LDR      r0,[sp,#0x20]         ;682
0000a6  f36b509f          BFI      r0,r11,#22,#10        ;682
0000aa  9008              STR      r0,[sp,#0x20]         ;682
0000ac  f10b0008          ADD      r0,r11,#8             ;683
0000b0  9005              STR      r0,[sp,#0x14]         ;683
0000b2  9808              LDR      r0,[sp,#0x20]         ;684
0000b4  f3c000c2          UBFX     r0,r0,#3,#3           ;684
0000b8  9007              STR      r0,[sp,#0x1c]         ;684
0000ba  486c              LDR      r0,|L13.620|
0000bc  9905              LDR      r1,[sp,#0x14]         ;685
0000be  f7fffffe          BL       nrf_memobj_alloc
0000c2  4606              MOV      r6,r0                 ;685
0000c4  2e00              CMP      r6,#0                 ;687
0000c6  d05b              BEQ      |L13.384|
0000c8  4630              MOV      r0,r6                 ;689
0000ca  f7fffffe          BL       nrf_memobj_get
0000ce  463b              MOV      r3,r7                 ;690
0000d0  2208              MOVS     r2,#8                 ;690
0000d2  a908              ADD      r1,sp,#0x20           ;690
0000d4  4630              MOV      r0,r6                 ;690
0000d6  f7fffffe          BL       nrf_memobj_write
0000da  3708              ADDS     r7,r7,#8              ;691
0000dc  ea040005          AND      r0,r4,r5              ;693
0000e0  1c69              ADDS     r1,r5,#1              ;693
0000e2  1a08              SUBS     r0,r1,r0              ;693
0000e4  ea4f0980          LSL      r9,r0,#2              ;693
0000e8  45cb              CMP      r11,r9                ;694
0000ea  d936              BLS      |L13.346|
0000ec  f1b90f00          CMP      r9,#0                 ;696
0000f0  d006              BEQ      |L13.256|
0000f2  ea040005          AND      r0,r4,r5              ;697
0000f6  495c              LDR      r1,|L13.616|
0000f8  310c              ADDS     r1,r1,#0xc            ;697
0000fa  eb010080          ADD      r0,r1,r0,LSL #2       ;697
0000fe  e001              B        |L13.260|
                  |L13.256|
000100  4859              LDR      r0,|L13.616|
000102  300c              ADDS     r0,r0,#0xc            ;698
                  |L13.260|
000104  9004              STR      r0,[sp,#0x10]         ;698
000106  f1b90f00          CMP      r9,#0                 ;699
00010a  d001              BEQ      |L13.272|
00010c  4648              MOV      r0,r9                 ;699
00010e  e000              B        |L13.274|
                  |L13.272|
000110  4658              MOV      r0,r11                ;699
                  |L13.274|
000112  b2c0              UXTB     r0,r0                 ;699
000114  9003              STR      r0,[sp,#0xc]          ;699
000116  f1b90f00          CMP      r9,#0                 ;700
00011a  d002              BEQ      |L13.290|
00011c  4852              LDR      r0,|L13.616|
00011e  300c              ADDS     r0,r0,#0xc            ;701
000120  e000              B        |L13.292|
                  |L13.290|
000122  2000              MOVS     r0,#0                 ;701
                  |L13.292|
000124  9002              STR      r0,[sp,#8]            ;701
000126  f1b90f00          CMP      r9,#0                 ;702
00012a  d002              BEQ      |L13.306|
00012c  ebab0009          SUB      r0,r11,r9             ;702
000130  e000              B        |L13.308|
                  |L13.306|
000132  2000              MOVS     r0,#0                 ;702
                  |L13.308|
000134  b2c0              UXTB     r0,r0                 ;702
000136  9001              STR      r0,[sp,#4]            ;702
000138  463b              MOV      r3,r7                 ;704
00013a  4630              MOV      r0,r6                 ;704
00013c  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;704
000140  f7fffffe          BL       nrf_memobj_write
000144  9803              LDR      r0,[sp,#0xc]          ;705
000146  4407              ADD      r7,r7,r0              ;705
000148  9802              LDR      r0,[sp,#8]            ;706
00014a  b128              CBZ      r0,|L13.344|
00014c  463b              MOV      r3,r7                 ;708
00014e  4630              MOV      r0,r6                 ;708
000150  e9dd2101          LDRD     r2,r1,[sp,#4]         ;708
000154  f7fffffe          BL       nrf_memobj_write
                  |L13.344|
000158  e00d              B        |L13.374|
                  |L13.346|
00015a  ea040005          AND      r0,r4,r5              ;713
00015e  4942              LDR      r1,|L13.616|
000160  310c              ADDS     r1,r1,#0xc            ;713
000162  eb010080          ADD      r0,r1,r0,LSL #2       ;713
000166  9004              STR      r0,[sp,#0x10]         ;713
000168  463b              MOV      r3,r7                 ;714
00016a  465a              MOV      r2,r11                ;714
00016c  4630              MOV      r0,r6                 ;714
00016e  9904              LDR      r1,[sp,#0x10]         ;714
000170  f7fffffe          BL       nrf_memobj_write
000174  bf00              NOP                            ;715
                  |L13.374|
000176  9806              LDR      r0,[sp,#0x18]         ;716
000178  1cc0              ADDS     r0,r0,#3              ;716
00017a  eb040490          ADD      r4,r4,r0,LSR #2       ;716
00017e  bf00              NOP                            ;717
                  |L13.384|
000180  e040              B        |L13.516|
000182  e7ff              B        |L13.388|
                  |L13.388|
000184  9808              LDR      r0,[sp,#0x20]         ;721
000186  f3c01083          UBFX     r0,r0,#6,#4           ;721
00018a  2806              CMP      r0,#6                 ;721
00018c  da03              BGE      |L13.406|
00018e  9808              LDR      r0,[sp,#0x20]         ;721
000190  f3c01083          UBFX     r0,r0,#6,#4           ;721
000194  e000              B        |L13.408|
                  |L13.406|
000196  2006              MOVS     r0,#6                 ;721
                  |L13.408|
000198  9908              LDR      r1,[sp,#0x20]         ;721
00019a  f3601189          BFI      r1,r0,#6,#4           ;721
00019e  9108              STR      r1,[sp,#0x20]         ;721
0001a0  9808              LDR      r0,[sp,#0x20]         ;722
0001a2  f3c01083          UBFX     r0,r0,#6,#4           ;722
0001a6  f1000902          ADD      r9,r0,#2              ;722
0001aa  9808              LDR      r0,[sp,#0x20]         ;723
0001ac  f3c000c2          UBFX     r0,r0,#3,#3           ;723
0001b0  9007              STR      r0,[sp,#0x1c]         ;723
0001b2  ea4f0189          LSL      r1,r9,#2              ;724
0001b6  482d              LDR      r0,|L13.620|
0001b8  f7fffffe          BL       nrf_memobj_alloc
0001bc  4606              MOV      r6,r0                 ;724
0001be  b306              CBZ      r6,|L13.514|
0001c0  4630              MOV      r0,r6                 ;728
0001c2  f7fffffe          BL       nrf_memobj_get
0001c6  463b              MOV      r3,r7                 ;729
0001c8  2208              MOVS     r2,#8                 ;729
0001ca  a908              ADD      r1,sp,#0x20           ;729
0001cc  4630              MOV      r0,r6                 ;729
0001ce  f7fffffe          BL       nrf_memobj_write
0001d2  3708              ADDS     r7,r7,#8              ;730
0001d4  f04f0800          MOV      r8,#0                 ;732
0001d8  e00e              B        |L13.504|
                  |L13.474|
0001da  4620              MOV      r0,r4                 ;734
0001dc  1c64              ADDS     r4,r4,#1              ;734
0001de  4028              ANDS     r0,r0,r5              ;734
0001e0  4a21              LDR      r2,|L13.616|
0001e2  320c              ADDS     r2,r2,#0xc            ;734
0001e4  eb020180          ADD      r1,r2,r0,LSL #2       ;734
0001e8  463b              MOV      r3,r7                 ;734
0001ea  2204              MOVS     r2,#4                 ;734
0001ec  4630              MOV      r0,r6                 ;734
0001ee  f7fffffe          BL       nrf_memobj_write
0001f2  1d3f              ADDS     r7,r7,#4              ;736
0001f4  f1080801          ADD      r8,r8,#1              ;732
                  |L13.504|
0001f8  9808              LDR      r0,[sp,#0x20]         ;732
0001fa  f3c01083          UBFX     r0,r0,#6,#4           ;732
0001fe  4540              CMP      r0,r8                 ;732
000200  d8eb              BHI      |L13.474|
                  |L13.514|
000202  bf00              NOP                            ;739
                  |L13.516|
000204  b356              CBZ      r6,|L13.604|
000206  481a              LDR      r0,|L13.624|
000208  f7fffffe          BL       nrf_atomic_flag_clear_fetch
00020c  9006              STR      r0,[sp,#0x18]         ;744
00020e  4816              LDR      r0,|L13.616|
000210  f8d09410          LDR      r9,[r0,#0x410]        ;745  ; m_log_data
000214  e016              B        |L13.580|
                  |L13.534|
000216  f04f0b00          MOV      r11,#0                ;748
00021a  bf00              NOP                            ;749
00021c  f8990009          LDRB     r0,[r9,#9]            ;749
000220  2801              CMP      r0,#1                 ;749
000222  d100              BNE      |L13.550|
000224  4683              MOV      r11,r0                ;765
                  |L13.550|
000226  f1bb0f00          CMP      r11,#0                ;768
00022a  d008              BEQ      |L13.574|
00022c  bf00              NOP                            ;770
00022e  f8d90000          LDR      r0,[r9,#0]            ;770
000232  4631              MOV      r1,r6                 ;770
000234  6802              LDR      r2,[r0,#0]            ;770
000236  4648              MOV      r0,r9                 ;770
000238  4790              BLX      r2                    ;770
00023a  bf00              NOP                            ;770
00023c  bf00              NOP                            ;770
                  |L13.574|
00023e  f8d99004          LDR      r9,[r9,#4]            ;772
000242  bf00              NOP                            ;773
                  |L13.580|
000244  f1b90f00          CMP      r9,#0                 ;746
000248  d002              BEQ      |L13.592|
00024a  9806              LDR      r0,[sp,#0x18]         ;746
00024c  2800              CMP      r0,#0                 ;746
00024e  d0e2              BEQ      |L13.534|
                  |L13.592|
000250  4630              MOV      r0,r6                 ;775
000252  f7fffffe          BL       nrf_memobj_put
000256  4804              LDR      r0,|L13.616|
000258  6044              STR      r4,[r0,#4]            ;776  ; m_log_data
00025a  bf00              NOP                            ;777
                  |L13.604|
00025c  f7fffffe          BL       buffer_is_empty
000260  f0800001          EOR      r0,r0,#1              ;779
000264  e6d3              B        |L13.14|
;;;781    
                          ENDP

000266  0000              DCW      0x0000
                  |L13.616|
                          DCD      m_log_data
                  |L13.620|
                          DCD      mempool
                  |L13.624|
                          DCD      m_log_data+0x414

                          AREA ||i.nrf_log_frontend_hexdump||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_hexdump PROC
;;;592    
;;;593    void nrf_log_frontend_hexdump(uint32_t           severity_mid,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;594                                  const void * const p_data,
;;;595                                  uint16_t           length)
;;;596    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;597        if (m_log_data.panic)
00000a  4833              LDR      r0,|L14.216|
00000c  f890041c          LDRB     r0,[r0,#0x41c]  ; m_log_data
000010  b108              CBZ      r0,|L14.22|
                  |L14.18|
;;;598        {
;;;599            return;
;;;600        }
;;;601    
;;;602        uint32_t mask   = m_log_data.mask;
;;;603    
;;;604        uint32_t wr_idx;
;;;605        if (buf_prealloc(CEIL_DIV(length, 4), &wr_idx))
;;;606        {
;;;607            //Header prepare
;;;608            nrf_log_header_t * p_header = (nrf_log_header_t *)&m_log_data.buffer[wr_idx++ & mask];
;;;609            p_header->base.hexdump.type     = HEADER_TYPE_HEXDUMP;
;;;610            p_header->base.hexdump.raw      = (severity_mid & NRF_LOG_RAW) ? 1 : 0;
;;;611            p_header->base.hexdump.severity = severity_mid & NRF_LOG_LEVEL_MASK;
;;;612            p_header->base.hexdump.offset   = 0;
;;;613            p_header->base.hexdump.len      = length;
;;;614    
;;;615            m_log_data.buffer[wr_idx++ & mask] = severity_mid >> NRF_LOG_MODULE_ID_POS;
;;;616    
;;;617    
;;;618            if (NRF_LOG_USES_TIMESTAMP)
;;;619            {
;;;620               m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;621            }
;;;622    
;;;623            uint32_t space0 = sizeof(uint32_t) * (m_log_data.mask + 1 - (wr_idx & mask));
;;;624            if (length <= space0)
;;;625            {
;;;626                memcpy(&m_log_data.buffer[wr_idx & mask], p_data, length);
;;;627            }
;;;628            else
;;;629            {
;;;630                memcpy(&m_log_data.buffer[wr_idx & mask], p_data, space0);
;;;631                length -= space0;
;;;632                memcpy(&m_log_data.buffer[0], &((uint8_t *)p_data)[space0], length);
;;;633            }
;;;634        }
;;;635    
;;;636        if (NRF_LOG_DEFERRED == 0)
;;;637        {
;;;638            NRF_LOG_FLUSH();
;;;639        }
;;;640    }
000012  e8bd83f8          POP      {r3-r9,pc}
                  |L14.22|
000016  4830              LDR      r0,|L14.216|
000018  6885              LDR      r5,[r0,#8]            ;602  ; m_log_data
00001a  1cfc              ADDS     r4,r7,#3              ;605
00001c  17e1              ASRS     r1,r4,#31             ;605
00001e  eb047191          ADD      r1,r4,r1,LSR #30      ;605
000022  1088              ASRS     r0,r1,#2              ;605
000024  4669              MOV      r1,sp                 ;605
000026  f7fffffe          BL       buf_prealloc
00002a  2800              CMP      r0,#0                 ;605
00002c  d051              BEQ      |L14.210|
00002e  9800              LDR      r0,[sp,#0]            ;608
000030  1c41              ADDS     r1,r0,#1              ;608
000032  4028              ANDS     r0,r0,r5              ;608
000034  9100              STR      r1,[sp,#0]            ;608
000036  4928              LDR      r1,|L14.216|
000038  310c              ADDS     r1,r1,#0xc            ;608
00003a  eb010480          ADD      r4,r1,r0,LSL #2       ;608
00003e  6820              LDR      r0,[r4,#0]            ;609
000040  f0200003          BIC      r0,r0,#3              ;609
000044  1c80              ADDS     r0,r0,#2              ;609
000046  6020              STR      r0,[r4,#0]            ;609
000048  0931              LSRS     r1,r6,#4              ;610
00004a  6820              LDR      r0,[r4,#0]            ;610
00004c  f3610082          BFI      r0,r1,#2,#1           ;610
000050  6020              STR      r0,[r4,#0]            ;610
000052  6820              LDR      r0,[r4,#0]            ;611
000054  f36600c5          BFI      r0,r6,#3,#3           ;611
000058  6020              STR      r0,[r4,#0]            ;611
00005a  2100              MOVS     r1,#0                 ;612
00005c  6820              LDR      r0,[r4,#0]            ;612
00005e  f361108f          BFI      r0,r1,#6,#10          ;612
000062  6020              STR      r0,[r4,#0]            ;612
000064  6820              LDR      r0,[r4,#0]            ;613
000066  f367509f          BFI      r0,r7,#22,#10         ;613
00006a  6020              STR      r0,[r4,#0]            ;613
00006c  0c32              LSRS     r2,r6,#16             ;615
00006e  9800              LDR      r0,[sp,#0]            ;615
000070  1c41              ADDS     r1,r0,#1              ;615
000072  4028              ANDS     r0,r0,r5              ;615
000074  9100              STR      r1,[sp,#0]            ;615
000076  4918              LDR      r1,|L14.216|
000078  310c              ADDS     r1,r1,#0xc            ;615
00007a  f8412020          STR      r2,[r1,r0,LSL #2]     ;615
00007e  4816              LDR      r0,|L14.216|
000080  6881              LDR      r1,[r0,#8]            ;623  ; m_log_data
000082  1c49              ADDS     r1,r1,#1              ;623
000084  9800              LDR      r0,[sp,#0]            ;623
000086  4028              ANDS     r0,r0,r5              ;623
000088  1a08              SUBS     r0,r1,r0              ;623
00008a  ea4f0880          LSL      r8,r0,#2              ;623
00008e  4547              CMP      r7,r8                 ;624
000090  d80a              BHI      |L14.168|
000092  9900              LDR      r1,[sp,#0]            ;626
000094  4029              ANDS     r1,r1,r5              ;626
000096  4a10              LDR      r2,|L14.216|
000098  320c              ADDS     r2,r2,#0xc            ;626
00009a  eb020081          ADD      r0,r2,r1,LSL #2       ;626
00009e  463a              MOV      r2,r7                 ;626
0000a0  4649              MOV      r1,r9                 ;626
0000a2  f7fffffe          BL       __aeabi_memcpy
0000a6  e013              B        |L14.208|
                  |L14.168|
0000a8  9900              LDR      r1,[sp,#0]            ;630
0000aa  4029              ANDS     r1,r1,r5              ;630
0000ac  4a0a              LDR      r2,|L14.216|
0000ae  320c              ADDS     r2,r2,#0xc            ;630
0000b0  eb020081          ADD      r0,r2,r1,LSL #2       ;630
0000b4  4642              MOV      r2,r8                 ;630
0000b6  4649              MOV      r1,r9                 ;630
0000b8  f7fffffe          BL       __aeabi_memcpy
0000bc  eba70008          SUB      r0,r7,r8              ;631
0000c0  b287              UXTH     r7,r0                 ;631
0000c2  eb090108          ADD      r1,r9,r8              ;632
0000c6  463a              MOV      r2,r7                 ;632
0000c8  4803              LDR      r0,|L14.216|
0000ca  300c              ADDS     r0,r0,#0xc            ;632
0000cc  f7fffffe          BL       __aeabi_memcpy
                  |L14.208|
0000d0  bf00              NOP                            ;634
                  |L14.210|
0000d2  bf00              NOP      
0000d4  e79d              B        |L14.18|
;;;641    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L14.216|
                          DCD      m_log_data

                          AREA ||i.nrf_log_frontend_std_0||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_0 PROC
;;;517    
;;;518    void nrf_log_frontend_std_0(uint32_t severity_mid, char const * const p_str)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;520        std_n(severity_mid, p_str, NULL, 0);
000006  2300              MOVS     r3,#0
000008  461a              MOV      r2,r3
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       std_n
;;;521    }
000012  bd70              POP      {r4-r6,pc}
;;;522    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_1||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_1 PROC
;;;523    
;;;524    void nrf_log_frontend_std_1(uint32_t            severity_mid,
000000  b5f8              PUSH     {r3-r7,lr}
;;;525                                char const * const p_str,
;;;526                                uint32_t           val0)
;;;527    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;528        uint32_t args[] = {val0};
000008  9400              STR      r4,[sp,#0]
;;;529        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
00000a  2301              MOVS     r3,#1
00000c  466a              MOV      r2,sp
00000e  4631              MOV      r1,r6
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       std_n
;;;530    }
000016  bdf8              POP      {r3-r7,pc}
;;;531    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_2||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_2 PROC
;;;532    
;;;533    void nrf_log_frontend_std_2(uint32_t           severity_mid,
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;534                                char const * const p_str,
;;;535                                uint32_t           val0,
;;;536                                uint32_t           val1)
;;;537    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;538        uint32_t args[] = {val0, val1};
00000c  9400              STR      r4,[sp,#0]
00000e  9501              STR      r5,[sp,#4]
;;;539        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
000010  2302              MOVS     r3,#2
000012  466a              MOV      r2,sp
000014  4639              MOV      r1,r7
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       std_n
;;;540    }
00001c  e8bd81fc          POP      {r2-r8,pc}
;;;541    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_3||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_3 PROC
;;;542    
;;;543    void nrf_log_frontend_std_3(uint32_t           severity_mid,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;544                                char const * const p_str,
;;;545                                uint32_t           val0,
;;;546                                uint32_t           val1,
;;;547                                uint32_t           val2)
;;;548    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;549        uint32_t args[] = {val0, val1, val2};
000010  9400              STR      r4,[sp,#0]
000012  9501              STR      r5,[sp,#4]
000014  f8cd8008          STR      r8,[sp,#8]
;;;550        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
000018  2303              MOVS     r3,#3
00001a  466a              MOV      r2,sp
00001c  4639              MOV      r1,r7
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       std_n
;;;551    }
000024  e8bd83fe          POP      {r1-r9,pc}
;;;552    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_4||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_4 PROC
;;;553    
;;;554    void nrf_log_frontend_std_4(uint32_t           severity_mid,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;555                                char const * const p_str,
;;;556                                uint32_t           val0,
;;;557                                uint32_t           val1,
;;;558                                uint32_t           val2,
;;;559                                uint32_t           val3)
;;;560    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;561        uint32_t args[] = {val0, val1, val2, val3};
000010  9400              STR      r4,[sp,#0]
000012  9501              STR      r5,[sp,#4]
000014  f8cd8008          STR      r8,[sp,#8]
000018  f8cd900c          STR      r9,[sp,#0xc]
;;;562        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
00001c  2304              MOVS     r3,#4
00001e  466a              MOV      r2,sp
000020  4639              MOV      r1,r7
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       std_n
;;;563    }
000028  e8bd87ff          POP      {r0-r10,pc}
;;;564    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_5||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_5 PROC
;;;565    
;;;566    void nrf_log_frontend_std_5(uint32_t           severity_mid,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;567                                char const * const p_str,
;;;568                                uint32_t           val0,
;;;569                                uint32_t           val1,
;;;570                                uint32_t           val2,
;;;571                                uint32_t           val3,
;;;572                                uint32_t           val4)
;;;573    {
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
00000e  e9dd9a0f          LDRD     r9,r10,[sp,#0x3c]
000012  f8dd8038          LDR      r8,[sp,#0x38]
;;;574        uint32_t args[] = {val0, val1, val2, val3, val4};
000016  9401              STR      r4,[sp,#4]
000018  9502              STR      r5,[sp,#8]
00001a  f8cd800c          STR      r8,[sp,#0xc]
00001e  f8cd9010          STR      r9,[sp,#0x10]
000022  f8cda014          STR      r10,[sp,#0x14]
;;;575        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
000026  2305              MOVS     r3,#5
000028  aa01              ADD      r2,sp,#4
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       std_n
;;;576    }
000032  b006              ADD      sp,sp,#0x18
000034  e8bd87f0          POP      {r4-r10,pc}
;;;577    
                          ENDP


                          AREA ||i.nrf_log_frontend_std_6||, CODE, READONLY, ALIGN=1

                  nrf_log_frontend_std_6 PROC
;;;578    
;;;579    void nrf_log_frontend_std_6(uint32_t           severity_mid,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;580                                char const * const p_str,
;;;581                                uint32_t           val0,
;;;582                                uint32_t           val1,
;;;583                                uint32_t           val2,
;;;584                                uint32_t           val3,
;;;585                                uint32_t           val4,
;;;586                                uint32_t           val5)
;;;587    {
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
00000e  e9ddab12          LDRD     r10,r11,[sp,#0x48]
000012  e9dd8910          LDRD     r8,r9,[sp,#0x40]
;;;588        uint32_t args[] = {val0, val1, val2, val3, val4, val5};
000016  9401              STR      r4,[sp,#4]
000018  9502              STR      r5,[sp,#8]
00001a  f8cd800c          STR      r8,[sp,#0xc]
00001e  f8cd9010          STR      r9,[sp,#0x10]
000022  f8cda014          STR      r10,[sp,#0x14]
000026  f8cdb018          STR      r11,[sp,#0x18]
;;;589        std_n(severity_mid, p_str, args,  ARRAY_SIZE(args));
00002a  2306              MOVS     r3,#6
00002c  aa01              ADD      r2,sp,#4
00002e  4639              MOV      r1,r7
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       std_n
;;;590    }
000036  b007              ADD      sp,sp,#0x1c
000038  e8bd8ff0          POP      {r4-r11,pc}
;;;591    
                          ENDP


                          AREA ||i.nrf_log_init||, CODE, READONLY, ALIGN=2

                  nrf_log_init PROC
;;;107    
;;;108    ret_code_t nrf_log_init(nrf_log_timestamp_func_t timestamp_func)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;109    {
000004  4607              MOV      r7,r0
;;;110        if (NRF_LOG_USES_TIMESTAMP && (timestamp_func == NULL))
000006  bf00              NOP      
;;;111        {
;;;112            return NRF_ERROR_INVALID_PARAM;
;;;113        }
;;;114    
;;;115        m_log_data.mask         = NRF_LOG_BUF_WORDS - 1;
000008  20ff              MOVS     r0,#0xff
00000a  4912              LDR      r1,|L22.84|
00000c  6088              STR      r0,[r1,#8]  ; m_log_data
;;;116        m_log_data.wr_idx       = 0;
00000e  2000              MOVS     r0,#0
000010  6008              STR      r0,[r1,#0]  ; m_log_data
;;;117        m_log_data.rd_idx       = 0;
000012  6048              STR      r0,[r1,#4]  ; m_log_data
;;;118        m_log_data.log_skipped  = 0;
000014  f8c10418          STR      r0,[r1,#0x418]  ; m_log_data
;;;119        m_log_data.log_skipping = 0;
000018  f8c10414          STR      r0,[r1,#0x414]  ; m_log_data
;;;120        m_log_data.panic        = false;
00001c  f881041c          STRB     r0,[r1,#0x41c]
;;;121        if (NRF_LOG_USES_TIMESTAMP)
;;;122        {
;;;123            m_log_data.timestamp_func = timestamp_func;
;;;124        }
;;;125    
;;;126        ret_code_t err_code = nrf_memobj_pool_init(&mempool);
000020  480d              LDR      r0,|L22.88|
000022  f7fffffe          BL       nrf_memobj_pool_init
000026  4605              MOV      r5,r0
;;;127        if (err_code != NRF_SUCCESS)
000028  b115              CBZ      r5,|L22.48|
;;;128        {
;;;129            return err_code;
00002a  4628              MOV      r0,r5
                  |L22.44|
;;;130        }
;;;131    
;;;132        uint32_t modules_cnt = NRF_LOG_CONST_SECTION_VARS_COUNT;
;;;133        uint32_t i;
;;;134        if (NRF_LOG_FILTERS_ENABLED)
;;;135        {
;;;136            uint32_t j;
;;;137            //sort modules by name
;;;138            for (i = 0; i < modules_cnt; i++)
;;;139            {
;;;140                uint32_t idx = 0;
;;;141    
;;;142                for (j = 0; j < modules_cnt; j++)
;;;143                {
;;;144                    if  (i != j)
;;;145                    {
;;;146                        char const * p_name0 = NRF_LOG_CONST_SECTION_VARS_GET(i)->p_module_name;
;;;147                        char const * p_name1 = NRF_LOG_CONST_SECTION_VARS_GET(j)->p_module_name;
;;;148                        if (strncmp(p_name0, p_name1, 20) > 0)
;;;149                        {
;;;150                            idx++;
;;;151                        }
;;;152                    }
;;;153    
;;;154                }
;;;155                nrf_log_module_dynamic_data_t * p_module_ddata = NRF_LOG_DYNAMIC_SECTION_VARS_GET(i);
;;;156                p_module_ddata->filter = 0;
;;;157                p_module_ddata->module_id = i;
;;;158                p_module_ddata->order_idx = idx;
;;;159            }
;;;160        }
;;;161        else
;;;162        {
;;;163            for(i = 0; i < modules_cnt; i++)
;;;164            {
;;;165                nrf_log_module_dynamic_data_t * p_module_ddata = NRF_LOG_DYNAMIC_SECTION_VARS_GET(i);
;;;166                p_module_ddata->module_id = i;
;;;167            }
;;;168        }
;;;169    
;;;170        return NRF_SUCCESS;
;;;171    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L22.48|
000030  480a              LDR      r0,|L22.92|
000032  490b              LDR      r1,|L22.96|
000034  1a40              SUBS     r0,r0,r1              ;132
000036  08c6              LSRS     r6,r0,#3              ;132
000038  2400              MOVS     r4,#0                 ;163
00003a  e006              B        |L22.74|
                  |L22.60|
00003c  eb040144          ADD      r1,r4,r4,LSL #1       ;165
000040  4a08              LDR      r2,|L22.100|
000042  eb020081          ADD      r0,r2,r1,LSL #2       ;165
000046  8004              STRH     r4,[r0,#0]            ;166
000048  1c64              ADDS     r4,r4,#1              ;163
                  |L22.74|
00004a  42b4              CMP      r4,r6                 ;163
00004c  d3f6              BCC      |L22.60|
00004e  2000              MOVS     r0,#0                 ;170
000050  e7ec              B        |L22.44|
;;;172    
                          ENDP

000052  0000              DCW      0x0000
                  |L22.84|
                          DCD      m_log_data
                  |L22.88|
                          DCD      mempool
                  |L22.92|
                          DCD      ||log_const_data$$Limit||
                  |L22.96|
                          DCD      ||log_const_data$$Base||
                  |L22.100|
                          DCD      ||log_dynamic_data$$Base||

                          AREA ||i.nrf_log_module_cnt_get||, CODE, READONLY, ALIGN=2

                  nrf_log_module_cnt_get PROC
;;;172    
;;;173    uint32_t nrf_log_module_cnt_get(void)
000000  4802              LDR      r0,|L23.12|
;;;174    {
;;;175        return NRF_LOG_CONST_SECTION_VARS_COUNT;
000002  4903              LDR      r1,|L23.16|
000004  1a40              SUBS     r0,r0,r1
000006  08c0              LSRS     r0,r0,#3
;;;176    }
000008  4770              BX       lr
;;;177    
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      ||log_const_data$$Limit||
                  |L23.16|
                          DCD      ||log_const_data$$Base||

                          AREA ||i.nrf_log_module_filter_get||, CODE, READONLY, ALIGN=2

                  nrf_log_module_filter_get PROC
;;;266    
;;;267    nrf_log_severity_t nrf_log_module_filter_get(uint32_t backend_id,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;268                                                 uint32_t module_id,
;;;269                                                 bool ordered_idx,
;;;270                                                 bool dynamic)
;;;271    {
000004  4607              MOV      r7,r0
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
;;;272        nrf_log_severity_t severity = NRF_LOG_SEVERITY_NONE;
00000a  2600              MOVS     r6,#0
;;;273        if (NRF_LOG_FILTERS_ENABLED && dynamic)
00000c  bf00              NOP      
;;;274        {
;;;275            if (module_idx_get(&module_id, ordered_idx) == NRF_SUCCESS)
;;;276            {
;;;277                nrf_log_module_dynamic_data_t * p_module_filter =
;;;278                                                    NRF_LOG_DYNAMIC_SECTION_VARS_GET(module_id);
;;;279                severity = (nrf_log_severity_t)((p_module_filter->filter_lvls >> (NRF_LOG_LEVEL_BITS * backend_id)) &
;;;280                                                                            NRF_LOG_LEVEL_MASK);
;;;281            }
;;;282        }
;;;283        else if (!dynamic)
00000e  b955              CBNZ     r5,|L24.38|
;;;284        {
;;;285            if (module_idx_get(&module_id, ordered_idx) == NRF_SUCCESS)
000010  4621              MOV      r1,r4
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       module_idx_get
000018  b928              CBNZ     r0,|L24.38|
;;;286            {
;;;287                nrf_log_module_const_data_t * p_module_data =
00001a  4905              LDR      r1,|L24.48|
00001c  9a01              LDR      r2,[sp,#4]
00001e  eb0100c2          ADD      r0,r1,r2,LSL #3
;;;288                                                    NRF_LOG_CONST_SECTION_VARS_GET(module_id);
;;;289                severity = (nrf_log_severity_t)p_module_data->compiled_lvl;
000022  7986              LDRB     r6,[r0,#6]
;;;290            }
000024  bf00              NOP      
                  |L24.38|
;;;291        }
;;;292        return severity;
000026  4630              MOV      r0,r6
;;;293    }
000028  b004              ADD      sp,sp,#0x10
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;294    
                          ENDP

00002e  0000              DCW      0x0000
                  |L24.48|
                          DCD      ||log_const_data$$Base||

                          AREA ||i.nrf_log_module_filter_set||, CODE, READONLY, ALIGN=1

                  nrf_log_module_filter_set PROC
;;;255    
;;;256    void nrf_log_module_filter_set(uint32_t backend_id, uint32_t module_id, nrf_log_severity_t severity)
000000  4770              BX       lr
;;;257    {
;;;258        if (NRF_LOG_FILTERS_ENABLED)
;;;259        {
;;;260            nrf_log_module_dynamic_data_t * p_module_filter = NRF_LOG_DYNAMIC_SECTION_VARS_GET(module_id);
;;;261            p_module_filter->filter_lvls &= ~(NRF_LOG_LEVEL_MASK << (NRF_LOG_LEVEL_BITS * backend_id));
;;;262            p_module_filter->filter_lvls |= (severity & NRF_LOG_LEVEL_MASK) << (NRF_LOG_LEVEL_BITS * backend_id);
;;;263            p_module_filter->filter = higher_lvl_get(p_module_filter->filter_lvls);
;;;264        }
;;;265    }
;;;266    
                          ENDP


                          AREA ||i.nrf_log_module_name_get||, CODE, READONLY, ALIGN=2

                  nrf_log_module_name_get PROC
;;;199    }
;;;200    const char * nrf_log_module_name_get(uint32_t module_id, bool ordered_idx)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;201    {
000002  460c              MOV      r4,r1
;;;202        if (module_idx_get(&module_id, ordered_idx) == NRF_SUCCESS)
000004  4621              MOV      r1,r4
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       module_idx_get
00000c  b928              CBNZ     r0,|L26.26|
;;;203        {
;;;204            nrf_log_module_const_data_t * p_module_data = NRF_LOG_CONST_SECTION_VARS_GET(module_id);
00000e  4804              LDR      r0,|L26.32|
000010  9a00              LDR      r2,[sp,#0]
000012  eb0001c2          ADD      r1,r0,r2,LSL #3
;;;205            return p_module_data->p_module_name;
000016  6808              LDR      r0,[r1,#0]
                  |L26.24|
;;;206        }
;;;207        else
;;;208        {
;;;209            return NULL;
;;;210        }
;;;211    }
000018  bd1c              POP      {r2-r4,pc}
                  |L26.26|
00001a  2000              MOVS     r0,#0                 ;209
00001c  e7fc              B        |L26.24|
;;;212    
                          ENDP

00001e  0000              DCW      0x0000
                  |L26.32|
                          DCD      ||log_const_data$$Base||

                          AREA ||i.nrf_log_panic||, CODE, READONLY, ALIGN=2

                  nrf_log_panic PROC
;;;859    
;;;860    void nrf_log_panic(void)
000000  b570              PUSH     {r4-r6,lr}
;;;861    {
;;;862        nrf_log_backend_t * p_backend = m_log_data.p_backend_head;
000002  480b              LDR      r0,|L27.48|
000004  f8d04410          LDR      r4,[r0,#0x410]  ; m_log_data
;;;863        m_log_data.panic = true;
000008  2001              MOVS     r0,#1
00000a  4909              LDR      r1,|L27.48|
00000c  f881041c          STRB     r0,[r1,#0x41c]
;;;864        while (p_backend)
000010  e00a              B        |L27.40|
                  |L27.18|
;;;865        {
;;;866            nrf_log_backend_enable(p_backend);
000012  bf00              NOP      
000014  2001              MOVS     r0,#1
000016  7260              STRB     r0,[r4,#9]
000018  bf00              NOP      
;;;867            nrf_log_backend_panic_set(p_backend);
00001a  4625              MOV      r5,r4
00001c  6828              LDR      r0,[r5,#0]
00001e  6841              LDR      r1,[r0,#4]
000020  4628              MOV      r0,r5
000022  4788              BLX      r1
000024  bf00              NOP      
;;;868            p_backend = p_backend->p_next;
000026  6864              LDR      r4,[r4,#4]
                  |L27.40|
000028  2c00              CMP      r4,#0                 ;864
00002a  d1f2              BNE      |L27.18|
;;;869        }
;;;870    }
00002c  bd70              POP      {r4-r6,pc}
;;;871    
                          ENDP

00002e  0000              DCW      0x0000
                  |L27.48|
                          DCD      m_log_data

                          AREA ||i.nrf_log_push||, CODE, READONLY, ALIGN=2

                  nrf_log_push PROC
;;;467    
;;;468    uint32_t nrf_log_push(char * const p_str)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;469    {
000004  4605              MOV      r5,r0
;;;470        if ((NRF_LOG_DEFERRED == 0) || (p_str == NULL) || m_log_data.panic)
000006  b11d              CBZ      r5,|L28.16|
000008  481b              LDR      r0,|L28.120|
00000a  f890041c          LDRB     r0,[r0,#0x41c]  ; m_log_data
00000e  b110              CBZ      r0,|L28.22|
                  |L28.16|
;;;471        {
;;;472            return (uint32_t)p_str;
000010  4628              MOV      r0,r5
                  |L28.18|
;;;473        }
;;;474    
;;;475        uint32_t mask      = m_log_data.mask;
;;;476        uint32_t slen      = strlen(p_str) + 1;
;;;477        uint32_t buflen    = CEIL_DIV(slen, 4);
;;;478        uint32_t offset    = 0;
;;;479        uint32_t wr_idx;
;;;480        char   * p_dst_str = (char *)cont_buf_prealloc(buflen, &offset, &wr_idx);
;;;481        if (p_dst_str)
;;;482        {
;;;483            nrf_log_header_t * p_header = (nrf_log_header_t *)&m_log_data.buffer[wr_idx & mask];
;;;484            PUSHED_HEADER_FILL(p_header, offset, buflen);
;;;485            memcpy(p_dst_str, p_str, slen);
;;;486        }
;;;487        return (uint32_t)p_dst_str;
;;;488    }
000012  e8bd87fc          POP      {r2-r10,pc}
                  |L28.22|
000016  4818              LDR      r0,|L28.120|
000018  f8d09008          LDR      r9,[r0,#8]            ;475  ; m_log_data
00001c  4628              MOV      r0,r5                 ;476
00001e  f7fffffe          BL       strlen
000022  1c46              ADDS     r6,r0,#1              ;476
000024  1cf0              ADDS     r0,r6,#3              ;477
000026  0887              LSRS     r7,r0,#2              ;477
000028  2000              MOVS     r0,#0                 ;478
00002a  9001              STR      r0,[sp,#4]            ;478
00002c  466a              MOV      r2,sp                 ;480
00002e  a901              ADD      r1,sp,#4              ;480
000030  4638              MOV      r0,r7                 ;480
000032  f7fffffe          BL       cont_buf_prealloc
000036  4680              MOV      r8,r0                 ;480
000038  f1b80f00          CMP      r8,#0                 ;481
00003c  d019              BEQ      |L28.114|
00003e  9800              LDR      r0,[sp,#0]            ;483
000040  ea000009          AND      r0,r0,r9              ;483
000044  490c              LDR      r1,|L28.120|
000046  310c              ADDS     r1,r1,#0xc            ;483
000048  eb010480          ADD      r4,r1,r0,LSL #2       ;483
00004c  6820              LDR      r0,[r4,#0]            ;484
00004e  f0200003          BIC      r0,r0,#3              ;484
000052  6020              STR      r0,[r4,#0]            ;484
000054  9901              LDR      r1,[sp,#4]            ;484
000056  6820              LDR      r0,[r4,#0]            ;484
000058  f361108f          BFI      r0,r1,#6,#10          ;484
00005c  6020              STR      r0,[r4,#0]            ;484
00005e  6820              LDR      r0,[r4,#0]            ;484
000060  f367509f          BFI      r0,r7,#22,#10         ;484
000064  6020              STR      r0,[r4,#0]            ;484
000066  4632              MOV      r2,r6                 ;485
000068  4629              MOV      r1,r5                 ;485
00006a  4640              MOV      r0,r8                 ;485
00006c  f7fffffe          BL       __aeabi_memcpy
000070  bf00              NOP                            ;486
                  |L28.114|
000072  4640              MOV      r0,r8                 ;487
000074  e7cd              B        |L28.18|
;;;489    
                          ENDP

000076  0000              DCW      0x0000
                  |L28.120|
                          DCD      m_log_data

                          AREA ||i.std_header_set||, CODE, READONLY, ALIGN=2

                  std_header_set PROC
;;;340    
;;;341    static inline uint32_t std_header_set(uint32_t severity_mid,
000000  b5f0              PUSH     {r4-r7,lr}
;;;342                                          char const * const p_str,
;;;343                                          uint32_t nargs,
;;;344                                          uint32_t wr_idx,
;;;345                                          uint32_t mask)
;;;346    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  9e05              LDR      r6,[sp,#0x14]
;;;347    
;;;348        nrf_log_header_t * p_header = (nrf_log_header_t *)&m_log_data.buffer[wr_idx++ & mask];
000008  4618              MOV      r0,r3
00000a  1c5b              ADDS     r3,r3,#1
00000c  4030              ANDS     r0,r0,r6
00000e  4f11              LDR      r7,|L29.84|
000010  eb070180          ADD      r1,r7,r0,LSL #2
;;;349        p_header->base.std.type = HEADER_TYPE_STD;
000014  6808              LDR      r0,[r1,#0]
000016  f0200003          BIC      r0,r0,#3
00001a  1c40              ADDS     r0,r0,#1
00001c  6008              STR      r0,[r1,#0]
;;;350        p_header->base.std.raw      = (severity_mid & NRF_LOG_RAW) ? 1 : 0;
00001e  0927              LSRS     r7,r4,#4
000020  6808              LDR      r0,[r1,#0]
000022  f3670082          BFI      r0,r7,#2,#1
000026  6008              STR      r0,[r1,#0]
;;;351        p_header->base.std.severity = severity_mid & NRF_LOG_LEVEL_MASK;
000028  6808              LDR      r0,[r1,#0]
00002a  f36400c5          BFI      r0,r4,#3,#3
00002e  6008              STR      r0,[r1,#0]
;;;352        p_header->base.std.nargs    = nargs;
000030  6808              LDR      r0,[r1,#0]
000032  f3621089          BFI      r0,r2,#6,#4
000036  6008              STR      r0,[r1,#0]
;;;353        p_header->base.std.addr     = ((uint32_t)(p_str) & STD_ADDR_MASK);
000038  6808              LDR      r0,[r1,#0]
00003a  f365209f          BFI      r0,r5,#10,#22
00003e  6008              STR      r0,[r1,#0]
;;;354    
;;;355        m_log_data.buffer[wr_idx++ & mask] = severity_mid >> NRF_LOG_MODULE_ID_POS;
000040  ea4f4c14          LSR      r12,r4,#16
000044  4618              MOV      r0,r3
000046  1c5b              ADDS     r3,r3,#1
000048  4030              ANDS     r0,r0,r6
00004a  4f02              LDR      r7,|L29.84|
00004c  f847c020          STR      r12,[r7,r0,LSL #2]
;;;356    
;;;357        if (NRF_LOG_USES_TIMESTAMP)
;;;358        {
;;;359            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;360        }
;;;361    
;;;362        return wr_idx;
000050  4618              MOV      r0,r3
;;;363    }
000052  bdf0              POP      {r4-r7,pc}
;;;364    
                          ENDP

                  |L29.84|
                          DCD      m_log_data+0xc

                          AREA ||i.std_n||, CODE, READONLY, ALIGN=2

                  std_n PROC
;;;489    
;;;490    static inline void std_n(uint32_t severity_mid, char const * const p_str, uint32_t const * args, uint32_t nargs)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;491    {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;492        uint32_t mask   = m_log_data.mask;
00000c  4812              LDR      r0,|L30.88|
00000e  6887              LDR      r7,[r0,#8]  ; m_log_data
;;;493        uint32_t wr_idx;
;;;494    
;;;495        if (m_log_data.panic)
000010  f890041c          LDRB     r0,[r0,#0x41c]  ; m_log_data
000014  b108              CBZ      r0,|L30.26|
                  |L30.22|
;;;496        {
;;;497            return;
;;;498        }
;;;499    
;;;500        if (buf_prealloc(nargs, &wr_idx))
;;;501        {
;;;502            // Proceed only if buffer was successfully preallocated.
;;;503            wr_idx = std_header_set(severity_mid, p_str, nargs, wr_idx, mask);
;;;504    
;;;505            uint32_t i;
;;;506            for (i = 0; i < nargs; i++)
;;;507            {
;;;508                m_log_data.buffer[wr_idx++ & mask] =args[i];
;;;509            }
;;;510        }
;;;511        if (NRF_LOG_DEFERRED == 0)
;;;512        {
;;;513            NRF_LOG_FLUSH();
;;;514        }
;;;515    
;;;516    }
000016  e8bd87fc          POP      {r2-r10,pc}
                  |L30.26|
00001a  a901              ADD      r1,sp,#4              ;500
00001c  4620              MOV      r0,r4                 ;500
00001e  f7fffffe          BL       buf_prealloc
000022  b1b8              CBZ      r0,|L30.84|
000024  9700              STR      r7,[sp,#0]            ;503
000026  4622              MOV      r2,r4                 ;503
000028  4649              MOV      r1,r9                 ;503
00002a  4640              MOV      r0,r8                 ;503
00002c  9b01              LDR      r3,[sp,#4]            ;503
00002e  f7fffffe          BL       std_header_set
000032  9001              STR      r0,[sp,#4]            ;503
000034  2500              MOVS     r5,#0                 ;506
000036  e00a              B        |L30.78|
                  |L30.56|
000038  f8562025          LDR      r2,[r6,r5,LSL #2]     ;508
00003c  9801              LDR      r0,[sp,#4]            ;508
00003e  1c41              ADDS     r1,r0,#1              ;508
000040  4038              ANDS     r0,r0,r7              ;508
000042  9101              STR      r1,[sp,#4]            ;508
000044  4904              LDR      r1,|L30.88|
000046  310c              ADDS     r1,r1,#0xc            ;508
000048  f8412020          STR      r2,[r1,r0,LSL #2]     ;508
00004c  1c6d              ADDS     r5,r5,#1              ;506
                  |L30.78|
00004e  42a5              CMP      r5,r4                 ;506
000050  d3f2              BCC      |L30.56|
000052  bf00              NOP                            ;510
                  |L30.84|
000054  bf00              NOP      
000056  e7de              B        |L30.22|
;;;517    
                          ENDP

                  |L30.88|
                          DCD      m_log_data

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mempool_nrf_balloc_pool_mem
                          %        192
                  m_log_data
                          %        1056

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  mempool
                          DCD      mempool_nrf_balloc_cb
                          DCD      mempool_nrf_balloc_pool_stack
                          DCD      mempool_nrf_balloc_pool_stack+0x8
                          DCD      mempool_nrf_balloc_pool_mem
000010  0018              DCW      0x0018
000012  0000              DCB      0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4f766572          DCB      "Overflow",0
000004  666c6f77
000008  00      

                          AREA ||.conststrlit||, DATA, READONLY, ALIGN=2

000000  61707000          DCB      0x61,0x70,0x70,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  mempool_nrf_balloc_pool_stack
                          %        8
                  mempool_nrf_balloc_cb
                          %        8
                  m_overflow_info
                          DCD      ||.conststring||

                          AREA log_const_data, DATA, READONLY, ALIGN=2

                  m_nrf_log_app_logs_data_const
                  ||__tagsym$$used||
                          DCD      ||.conststrlit||
000004  00000400          DCB      0x00,0x00,0x04,0x00

                          AREA log_dynamic_data, DATA, ALIGN=2

                  m_nrf_log_app_logs_data_dynamic
                  |symbol_number.251|
                          %        12

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\experimental_log\\src\\nrf_log_frontend.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_nrf_log_frontend_c_bc460776____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776____REVSH|
#line 402
|__asm___18_nrf_log_frontend_c_bc460776____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776____RRX|
#line 587
|__asm___18_nrf_log_frontend_c_bc460776____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_mov|
#line 65 "..\\..\\..\\..\\..\\..\\components\\libraries\\atomic\\nrf_atomic_internal.h"
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_mov| PROC
#line 68

#line 72
 
 push {r4, r5}
 mov r4, r0

loop_mov
 ldrex r0, [r4]
 mov r5, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_mov

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_orr|
#line 89
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_orr| PROC
#line 92

 push {r4, r5}
 mov r4, r0

loop_orr
 ldrex r0, [r4]
 orr r5, r0, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_orr

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_and|
#line 108
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_and| PROC
#line 111

 push {r4, r5}
 mov r4, r0

loop_and
 ldrex r0, [r4]
 and r5, r0, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_and

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_eor|
#line 127
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_eor| PROC
#line 130

 push {r4, r5}
 mov r4, r0

loop_eor
 ldrex r0, [r4]
 eor r5, r0, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_eor

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_add|
#line 146
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_add| PROC
#line 149

 push {r4, r5}
 mov r4, r0

loop_add
 ldrex r0, [r4]
 add r5, r0, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_add

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_sub|
#line 165
|__asm___18_nrf_log_frontend_c_bc460776__nrf_atomic_internal_sub| PROC
#line 168

 push {r4, r5}
 mov r4, r0

loop_sub
 ldrex r0, [r4]
 sub r5, r0, r1
 strex r3, r5, [r4]
 cmp r3, #0
 bne loop_sub

 str r5, [r2]
 pop {r4, r5}
 bx lr
	ENDP

;*** End   embedded assembler ***
