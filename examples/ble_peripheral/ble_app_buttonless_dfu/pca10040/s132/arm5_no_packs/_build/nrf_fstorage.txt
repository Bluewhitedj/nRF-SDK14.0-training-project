; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --reduce_paths -o.\_build\nrf_fstorage.o --asm_dir=.\_build\ --list_dir=.\_build\ --depend=.\_build\nrf_fstorage.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_gatt -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\libraries\atomic -I..\..\..\..\..\..\components\libraries\balloc -I..\..\..\..\..\..\components\libraries\bootloader\dfu -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\experimental_log -I..\..\..\..\..\..\components\libraries\experimental_log\src -I..\..\..\..\..\..\components\libraries\experimental_memobj -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\mutex -I..\..\..\..\..\..\components\libraries\pwr_mgmt -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\strerror -I..\..\..\..\..\..\components\libraries\svc -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common -I..\..\..\..\..\..\components\softdevice\s132\headers -I..\..\..\..\..\..\components\softdevice\s132\headers\nrf52 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\fprintf -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\libraries\fifo -I.\RTE\_nrf52832_xxaa -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.14.1\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DNRF52 -DBL_SETTINGS_ACCESS_ONLY -DBOARD_PCA10040 -DCONFIG_GPIO_AS_PINRESET -DNRF52 -DNRF52832_XXAA -DNRF52_PAN_74 -DNRF_SD_BLE_API_VERSION=5 -DS132 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 -DDEBUG --omf_browse=.\_build\nrf_fstorage.crf ..\..\..\..\..\..\components\libraries\fstorage\nrf_fstorage.c]
                          THUMB

                          AREA ||i.addr_is_aligned32||, CODE, READONLY, ALIGN=1

                  addr_is_aligned32 PROC
;;;234    
;;;235    static bool addr_is_aligned32(uint32_t addr)
000000  4601              MOV      r1,r0
;;;236    {
;;;237        return !(addr & 0x03);
000002  f0010003          AND      r0,r1,#3
000006  b908              CBNZ     r0,|L1.12|
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;238    }
00000a  4770              BX       lr
                  |L1.12|
00000c  2000              MOVS     r0,#0                 ;237
00000e  e7fc              B        |L1.10|
;;;239    
                          ENDP


                          AREA ||i.addr_within_bounds||, CODE, READONLY, ALIGN=1

                  addr_within_bounds PROC
;;;225    
;;;226    static bool addr_within_bounds(nrf_fstorage_t const * p_fs,
000000  b510              PUSH     {r4,lr}
;;;227                                   uint32_t               addr,
;;;228                                   uint32_t               len)
;;;229    {
000002  4603              MOV      r3,r0
;;;230        return ((addr           >= p_fs->start_addr) &&
000004  68d8              LDR      r0,[r3,#0xc]
000006  4288              CMP      r0,r1
000008  d806              BHI      |L2.24|
;;;231                (addr + len - 1 <= p_fs->end_addr));
00000a  1888              ADDS     r0,r1,r2
00000c  1e40              SUBS     r0,r0,#1
00000e  691c              LDR      r4,[r3,#0x10]
000010  42a0              CMP      r0,r4
000012  d801              BHI      |L2.24|
000014  2001              MOVS     r0,#1
                  |L2.22|
;;;232    }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  2000              MOVS     r0,#0                 ;231
00001a  e7fc              B        |L2.22|
;;;233    
                          ENDP


                          AREA ||i.nrf_fstorage_erase||, CODE, READONLY, ALIGN=1

                  nrf_fstorage_erase PROC
;;;162    
;;;163    ret_code_t nrf_fstorage_erase(nrf_fstorage_t const * p_fs,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;164                                  uint32_t               page_addr,
;;;165                                  uint32_t               len,
;;;166                                  void                 * p_context)
;;;167    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;168        if (p_fs == NULL)
00000c  b914              CBNZ     r4,|L3.20|
;;;169        {
;;;170            return NRF_ERROR_NULL;
00000e  200e              MOVS     r0,#0xe
                  |L3.16|
;;;171        }
;;;172    
;;;173        if (p_fs->p_api == NULL)
;;;174        {
;;;175            return NRF_ERROR_INVALID_STATE;
;;;176        }
;;;177    
;;;178        if (len == 0)
;;;179        {
;;;180            return NRF_ERROR_INVALID_LENGTH;
;;;181        }
;;;182    
;;;183        /* Address must be aligned to a page boundary. */
;;;184        if (    ((page_addr & (p_fs->p_flash_info->erase_unit - 1)) != 0)
;;;185            ||  !addr_within_bounds(p_fs, page_addr, (len * p_fs->p_flash_info->erase_unit)))
;;;186        {
;;;187            return NRF_ERROR_INVALID_ADDR;
;;;188        }
;;;189    
;;;190        return ((nrf_fstorage_api_t *)p_fs->p_api)->erase(p_fs, page_addr, len, p_context);
;;;191    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L3.20|
000014  6820              LDR      r0,[r4,#0]            ;173
000016  b908              CBNZ     r0,|L3.28|
000018  2008              MOVS     r0,#8                 ;175
00001a  e7f9              B        |L3.16|
                  |L3.28|
00001c  b90d              CBNZ     r5,|L3.34|
00001e  2009              MOVS     r0,#9                 ;180
000020  e7f6              B        |L3.16|
                  |L3.34|
000022  6860              LDR      r0,[r4,#4]            ;184
000024  6800              LDR      r0,[r0,#0]            ;184
000026  1e40              SUBS     r0,r0,#1              ;184
000028  4030              ANDS     r0,r0,r6              ;184
00002a  b940              CBNZ     r0,|L3.62|
00002c  6860              LDR      r0,[r4,#4]            ;185
00002e  6800              LDR      r0,[r0,#0]            ;185
000030  fb00f205          MUL      r2,r0,r5              ;185
000034  4631              MOV      r1,r6                 ;185
000036  4620              MOV      r0,r4                 ;185
000038  f7fffffe          BL       addr_within_bounds
00003c  b908              CBNZ     r0,|L3.66|
                  |L3.62|
00003e  2010              MOVS     r0,#0x10              ;187
000040  e7e6              B        |L3.16|
                  |L3.66|
000042  6820              LDR      r0,[r4,#0]            ;190
000044  463b              MOV      r3,r7                 ;190
000046  462a              MOV      r2,r5                 ;190
000048  4631              MOV      r1,r6                 ;190
00004a  f8d0c010          LDR      r12,[r0,#0x10]        ;190
00004e  4620              MOV      r0,r4                 ;190
000050  47e0              BLX      r12                   ;190
000052  e7dd              B        |L3.16|
;;;192    
                          ENDP


                          AREA ||i.nrf_fstorage_init||, CODE, READONLY, ALIGN=1

                  nrf_fstorage_init PROC
;;;57     
;;;58     ret_code_t nrf_fstorage_init(nrf_fstorage_t     * p_fs,
000000  b570              PUSH     {r4-r6,lr}
;;;59                                  nrf_fstorage_api_t * p_api,
;;;60                                  void               * p_param)
;;;61     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;62         if ((p_fs == NULL) || (p_api == NULL))
000008  b104              CBZ      r4,|L4.12|
00000a  b90d              CBNZ     r5,|L4.16|
                  |L4.12|
;;;63         {
;;;64             return NRF_ERROR_NULL;
00000c  200e              MOVS     r0,#0xe
                  |L4.14|
;;;65         }
;;;66     
;;;67         p_fs->p_api = (struct nrf_fstorage_api_t *) p_api;
;;;68     
;;;69         return ((nrf_fstorage_api_t*)p_fs->p_api)->init(p_fs, p_param);
;;;70     }
00000e  bd70              POP      {r4-r6,pc}
                  |L4.16|
000010  6025              STR      r5,[r4,#0]            ;67
000012  6820              LDR      r0,[r4,#0]            ;69
000014  4631              MOV      r1,r6                 ;69
000016  6802              LDR      r2,[r0,#0]            ;69
000018  4620              MOV      r0,r4                 ;69
00001a  4790              BLX      r2                    ;69
00001c  e7f7              B        |L4.14|
;;;71     
                          ENDP


                          AREA ||i.nrf_fstorage_is_busy||, CODE, READONLY, ALIGN=2

                  nrf_fstorage_is_busy PROC
;;;193    
;;;194    bool nrf_fstorage_is_busy(nrf_fstorage_t const * p_fs)
000000  b570              PUSH     {r4-r6,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196        nrf_fstorage_api_t const * p_api;
;;;197    
;;;198        /* If a NULL instance is provided, return true if any instance is busy.
;;;199         * Uninitialized instances are considered not busy. */
;;;200        if ((p_fs == NULL) || (p_fs->p_api == NULL))
000004  b10c              CBZ      r4,|L5.10|
000006  6820              LDR      r0,[r4,#0]
000008  b9c8              CBNZ     r0,|L5.62|
                  |L5.10|
;;;201        {
;;;202            for (uint32_t i = 0; i < NRF_FSTORAGE_INSTANCE_CNT; i++)
00000a  2600              MOVS     r6,#0
00000c  e00d              B        |L5.42|
                  |L5.14|
;;;203            {
;;;204                p_fs  = NRF_FSTORAGE_INSTANCE_GET(i);   /* cannot be NULL. */
00000e  eb060086          ADD      r0,r6,r6,LSL #2
000012  490d              LDR      r1,|L5.72|
000014  eb010480          ADD      r4,r1,r0,LSL #2
;;;205                p_api = (nrf_fstorage_api_t*)p_fs->p_api;
000018  6825              LDR      r5,[r4,#0]
;;;206    
;;;207                if (p_api != NULL)
00001a  b12d              CBZ      r5,|L5.40|
;;;208                {
;;;209                    /* p_api->is_busy() cannot be NULL. */
;;;210                    if (p_api->is_busy(p_fs))
00001c  4620              MOV      r0,r4
00001e  6969              LDR      r1,[r5,#0x14]
000020  4788              BLX      r1
000022  b108              CBZ      r0,|L5.40|
;;;211                    {
;;;212                        return true;
000024  2001              MOVS     r0,#1
                  |L5.38|
;;;213                    }
;;;214                }
;;;215            }
;;;216    
;;;217            return false;
;;;218        }
;;;219    
;;;220        p_api = (nrf_fstorage_api_t*)p_fs->p_api;
;;;221    
;;;222        return p_api->is_busy(p_fs);
;;;223    }
000026  bd70              POP      {r4-r6,pc}
                  |L5.40|
000028  1c76              ADDS     r6,r6,#1              ;202
                  |L5.42|
00002a  4808              LDR      r0,|L5.76|
00002c  4906              LDR      r1,|L5.72|
00002e  1a40              SUBS     r0,r0,r1              ;202
000030  2114              MOVS     r1,#0x14              ;202
000032  fbb0f0f1          UDIV     r0,r0,r1              ;202
000036  42b0              CMP      r0,r6                 ;202
000038  d8e9              BHI      |L5.14|
00003a  2000              MOVS     r0,#0                 ;217
00003c  e7f3              B        |L5.38|
                  |L5.62|
00003e  6825              LDR      r5,[r4,#0]            ;220
000040  4620              MOV      r0,r4                 ;222
000042  6969              LDR      r1,[r5,#0x14]         ;222
000044  4788              BLX      r1                    ;222
000046  e7ee              B        |L5.38|
;;;224    
                          ENDP

                  |L5.72|
                          DCD      ||fs_data$$Base||
                  |L5.76|
                          DCD      ||fs_data$$Limit||

                          AREA ||i.nrf_fstorage_read||, CODE, READONLY, ALIGN=1

                  nrf_fstorage_read PROC
;;;97     
;;;98     ret_code_t nrf_fstorage_read(nrf_fstorage_t const * p_fs,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;99                                  uint32_t               src,
;;;100                                 void                 * p_dest,
;;;101                                 uint32_t               len)
;;;102    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;103        if ((p_fs == NULL) || (p_dest == NULL))
00000c  b104              CBZ      r4,|L6.16|
00000e  b917              CBNZ     r7,|L6.22|
                  |L6.16|
;;;104        {
;;;105            return NRF_ERROR_NULL;
000010  200e              MOVS     r0,#0xe
                  |L6.18|
;;;106        }
;;;107    
;;;108        if (p_fs->p_api == NULL)
;;;109        {
;;;110            return NRF_ERROR_INVALID_STATE;
;;;111        }
;;;112    
;;;113        if (len == 0)
;;;114        {
;;;115            return NRF_ERROR_INVALID_LENGTH;
;;;116        }
;;;117    
;;;118        /* Source addres must be word-aligned. */
;;;119        if (    !addr_is_aligned32(src)
;;;120            ||  !addr_within_bounds(p_fs, src, len))
;;;121        {
;;;122            return NRF_ERROR_INVALID_ADDR;
;;;123        }
;;;124    
;;;125        return ((nrf_fstorage_api_t *)p_fs->p_api)->read(p_fs, src, p_dest, len);
;;;126    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L6.22|
000016  6820              LDR      r0,[r4,#0]            ;108
000018  b908              CBNZ     r0,|L6.30|
00001a  2008              MOVS     r0,#8                 ;110
00001c  e7f9              B        |L6.18|
                  |L6.30|
00001e  b90d              CBNZ     r5,|L6.36|
000020  2009              MOVS     r0,#9                 ;115
000022  e7f6              B        |L6.18|
                  |L6.36|
000024  4630              MOV      r0,r6                 ;119
000026  f7fffffe          BL       addr_is_aligned32
00002a  b128              CBZ      r0,|L6.56|
00002c  462a              MOV      r2,r5                 ;120
00002e  4631              MOV      r1,r6                 ;120
000030  4620              MOV      r0,r4                 ;120
000032  f7fffffe          BL       addr_within_bounds
000036  b908              CBNZ     r0,|L6.60|
                  |L6.56|
000038  2010              MOVS     r0,#0x10              ;122
00003a  e7ea              B        |L6.18|
                  |L6.60|
00003c  6820              LDR      r0,[r4,#0]            ;125
00003e  462b              MOV      r3,r5                 ;125
000040  463a              MOV      r2,r7                 ;125
000042  4631              MOV      r1,r6                 ;125
000044  f8d0c008          LDR      r12,[r0,#8]           ;125
000048  4620              MOV      r0,r4                 ;125
00004a  47e0              BLX      r12                   ;125
00004c  e7e1              B        |L6.18|
;;;127    
                          ENDP


                          AREA ||i.nrf_fstorage_uninit||, CODE, READONLY, ALIGN=1

                  nrf_fstorage_uninit PROC
;;;72     
;;;73     ret_code_t nrf_fstorage_uninit(nrf_fstorage_t * p_fs,
000000  b570              PUSH     {r4-r6,lr}
;;;74                                    void           * p_param)
;;;75     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;76         ret_code_t rc;
;;;77     
;;;78         if (p_fs == NULL)
000006  b90c              CBNZ     r4,|L7.12|
;;;79         {
;;;80             return NRF_ERROR_NULL;
000008  200e              MOVS     r0,#0xe
                  |L7.10|
;;;81         }
;;;82     
;;;83         if (p_fs->p_api == NULL)
;;;84         {
;;;85             return NRF_ERROR_INVALID_STATE;
;;;86         }
;;;87     
;;;88         rc = ((nrf_fstorage_api_t *)p_fs->p_api)->uninit(p_fs, p_param);
;;;89     
;;;90         /* Uninitialize the API. */
;;;91         p_fs->p_api        = NULL;
;;;92         p_fs->p_flash_info = NULL;
;;;93     
;;;94         return rc;
;;;95     }
00000a  bd70              POP      {r4-r6,pc}
                  |L7.12|
00000c  6820              LDR      r0,[r4,#0]            ;83
00000e  b908              CBNZ     r0,|L7.20|
000010  2008              MOVS     r0,#8                 ;85
000012  e7fa              B        |L7.10|
                  |L7.20|
000014  6820              LDR      r0,[r4,#0]            ;88
000016  4629              MOV      r1,r5                 ;88
000018  6842              LDR      r2,[r0,#4]            ;88
00001a  4620              MOV      r0,r4                 ;88
00001c  4790              BLX      r2                    ;88
00001e  4606              MOV      r6,r0                 ;88
000020  2000              MOVS     r0,#0                 ;91
000022  6020              STR      r0,[r4,#0]            ;91
000024  6060              STR      r0,[r4,#4]            ;92
000026  4630              MOV      r0,r6                 ;94
000028  e7ef              B        |L7.10|
;;;96     
                          ENDP


                          AREA ||i.nrf_fstorage_write||, CODE, READONLY, ALIGN=1

                  nrf_fstorage_write PROC
;;;128    
;;;129    ret_code_t nrf_fstorage_write(nrf_fstorage_t const * p_fs,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;130                                  uint32_t               dest,
;;;131                                  void           const * p_src,
;;;132                                  uint32_t               len,
;;;133                                  void                 * p_context)
;;;134    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;135        if ((p_fs == NULL) || (p_src == NULL))
000010  b104              CBZ      r4,|L8.20|
000012  b916              CBNZ     r6,|L8.26|
                  |L8.20|
;;;136        {
;;;137            return NRF_ERROR_NULL;
000014  200e              MOVS     r0,#0xe
                  |L8.22|
;;;138        }
;;;139    
;;;140        if (p_fs->p_api == NULL)
;;;141        {
;;;142            return NRF_ERROR_INVALID_STATE;
;;;143        }
;;;144    
;;;145        /* Length must be a multiple of the program unit. */
;;;146        if ((len == 0) || ((len % p_fs->p_flash_info->program_unit) != 0))
;;;147        {
;;;148            return NRF_ERROR_INVALID_LENGTH;
;;;149        }
;;;150    
;;;151        /* Source and destination addresses must be word-aligned. */
;;;152        if (    !addr_is_aligned32(dest)
;;;153            ||  !addr_is_aligned32((uint32_t)p_src)
;;;154            ||  !addr_within_bounds(p_fs, dest, len))
;;;155        {
;;;156            return NRF_ERROR_INVALID_ADDR;
;;;157        }
;;;158    
;;;159        return ((nrf_fstorage_api_t *)p_fs->p_api)->write(p_fs, dest, p_src, len, p_context);
;;;160    }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L8.26|
00001a  6820              LDR      r0,[r4,#0]            ;140
00001c  b908              CBNZ     r0,|L8.34|
00001e  2008              MOVS     r0,#8                 ;142
000020  e7f9              B        |L8.22|
                  |L8.34|
000022  b135              CBZ      r5,|L8.50|
000024  6860              LDR      r0,[r4,#4]            ;146
000026  6840              LDR      r0,[r0,#4]            ;146
000028  fbb5f1f0          UDIV     r1,r5,r0              ;146
00002c  fb005011          MLS      r0,r0,r1,r5           ;146
000030  b108              CBZ      r0,|L8.54|
                  |L8.50|
000032  2009              MOVS     r0,#9                 ;148
000034  e7ef              B        |L8.22|
                  |L8.54|
000036  4638              MOV      r0,r7                 ;152
000038  f7fffffe          BL       addr_is_aligned32
00003c  b148              CBZ      r0,|L8.82|
00003e  4630              MOV      r0,r6                 ;153
000040  f7fffffe          BL       addr_is_aligned32
000044  b128              CBZ      r0,|L8.82|
000046  462a              MOV      r2,r5                 ;154
000048  4639              MOV      r1,r7                 ;154
00004a  4620              MOV      r0,r4                 ;154
00004c  f7fffffe          BL       addr_within_bounds
000050  b908              CBNZ     r0,|L8.86|
                  |L8.82|
000052  2010              MOVS     r0,#0x10              ;156
000054  e7df              B        |L8.22|
                  |L8.86|
000056  f8cd8000          STR      r8,[sp,#0]            ;159
00005a  6820              LDR      r0,[r4,#0]            ;159
00005c  462b              MOV      r3,r5                 ;159
00005e  4632              MOV      r2,r6                 ;159
000060  4639              MOV      r1,r7                 ;159
000062  f8d0c00c          LDR      r12,[r0,#0xc]         ;159
000066  4620              MOV      r0,r4                 ;159
000068  47e0              BLX      r12                   ;159
00006a  e7d4              B        |L8.22|
;;;161    
                          ENDP

